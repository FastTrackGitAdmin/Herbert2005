//#define SPOOL\
#define INVOKER
#define NEWCODE
#define EXCEPTION
#define COMPRESSION
//IC2007
//#define PROBE
//End
//comment this for interview site.
#define STROPT
#define TOOLBAR

//For Designer
//#define DESIGNER
//#define PATTERN_GENERATER
//End

//For Herbert Start
#define CONTEST
#define RUNSTATE
#define SESSIONMAGEMENT
//end

#define MS10MAR
#define MODULAR_INTERPRETER

//#define RTDEBUG

//#define BUCKETING
//#define RUNSTATE
//#define MS10MAR
//#define DLL


using System;
using System.Drawing;
using System.Windows.Forms;
using System.Data;
using System.IO;
using System.Threading;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Globalization;
using Designer;
using System.Diagnostics;
using System.Collections;



#if DESIGNER
	using System.Text.RegularExpressions;
#endif

#if(DLL)
using NDataAccess;
#endif


[assembly: AllowPartiallyTrustedCallers]
namespace Designer
{
    /// <summary>
    /// Summary description for Form1.
    /// </summary> 
    [System.Net.WebPermission(System.Security.Permissions.SecurityAction.Assert, Unrestricted = true)]
    public class HerbertMain : System.Windows.Forms.Form
    {

        #region Constants
#if (DESIGNER)
        private static string[] arrLevelType ={ "Normal", "Maze", "Numeric Series" };
#endif
        /// <summary>
        /// offset which is used to display herbert.
        /// </summary>
        private const int HOFFSET = 4;

        /// <summary>
        /// Max number of characters allowed in one line of Herbert code. 
        /// <p>This is not Herbert Char count but simple char count.</p>
        /// </summary>
        private const int MAXCHARSONLINE = 127;

        /// <summary>
        /// offset which is used to display herbert.
        /// </summary>
        //private const int OFFSET = 4;

        /// <summary>
        /// defined some constants like static SIZE, TRUE and FALSE
        /// </summary>
        /// Vijay, check why only 20 lines.
        //bc1311		private const int MAXLINES = 20, STACKSIZE = 1024*256;
        private const int MAXNUM = 255, MINNUM = -256;

        /// <summary>
        /// Max number of lines allowed in the code editor. Which is 15.
        /// </summary>
        public const int MAXLINES = 15;

        /// <summary>
        /// Stack size which is used to store call of herbert functions.
        /// </summary>
        public const int STACKSIZE = 1024 * 16; /* stacksize can be no more than 1024*16 */

        /// <summary>
        /// Short constants defined, TRUE = 1 and FALSE = 0.
        /// </summary>
        private const short TRUE = 1, FALSE = 0;

        /// <summary>
        /// CR is char which represents the retrun key.
        /// </summary>
        private const char CR = '\n';

        /// <summary>
        /// In simple text box return is represented by two chars one is '\n' and other is '\r'
        /// but interperter takes only '\n' as return char. So for removing the extra char '\r' 
        /// this constant contains this value.
        /// </summary>
        private const char cRemoveCR = '\r';

        /// <summary>
        /// these contants are defined for different states of herbert.
        /// HFBLINK is used for blinking herbert.		
        /// </summary>
        private const short HFBLINK = 0x01;

        /// <summary>
        /// these contants are defined for different states of herbert.
        /// HFSSTEP is used for steps.	
        /// </summary>
        private const short HFSSTEP = 0x02;

        /// <summary>
        /// these contants are defined for different states of herbert.
        /// and HFSTEPD is for saying that herbert is in normal position.
        /// </summary>
        private const short HFSTEPD = 0x04;

        /// <summary>
        /// these contants are defined for different states of herbert.
        /// HFNWLIN is used for saying that new line execution is now started.
        /// </summary>
        private const short HFNWLIN = 0x08;

        /// <summary>
        /// offset defined for calculating the with of the tracing string 
        /// to be displayed on tracing box.
        /// </summary>
        private const int WIDTHOFFSET = 15;

        /// <summary>
        /// defines the radious of the small dot.
        /// </summary>
        public const float DOTRADIOUS = 1.6F;

        /// <summary>
        /// number of lines that can be displayed on editor tracing box.
        /// </summary>
        private const int DISPLINES = 13;

        //Commented by Vivek for saving the run state
        //private bool blnFirstStepClick = true;	
        #endregion

        #region System Variables

        /// <summary>
        /// Context menu to be displayed on Txt Code Editor.
        /// </summary>
        //private System.Windows.Forms.ContextMenu cM;
        /// <summary>
        /// code eidtor.
        /// </summary>
        //private System.Windows.Forms.RichTextBox txtCodeEditor;
        private System.Windows.Forms.TextBox txtCodeEditor;

        /// <summary>
        /// Image box to contain herbert image
        /// </summary>
        //private System.Windows.Forms.PictureBox herbertPicBox;
        private Designer.MyPicBox herbertPicBox;
        private System.ComponentModel.IContainer components;

        /// <summary>
        /// this is the board where dots are drawn and
        /// hurdles and targets are displayed.
        /// herbert is also displayed on this.
        /// </summary>
        //private System.Windows.Forms.Panel HerbertBoard;
        private cHerbertBoard HerbertBoard;

        /// <summary>
        /// Main menu of this application.
        /// </summary>
        private System.Windows.Forms.MainMenu HerbertMenu;

        /// <summary>
        /// panal used for editor tracing and displaying a dark
        /// 		/// line across the code editor. its graphics is also 
        /// used to display editor tracing.
        /// </summary>
        private System.Windows.Forms.Panel PanalTxtCodeEdit;
        /// <summary>
        /// these three labels are used for bottom or line tracing.
        /// </summary>
        private System.Windows.Forms.Label lblTraceFirst;
        private System.Windows.Forms.Label lblBlack;
        private System.Windows.Forms.Label lblTraceSecond;

        /// buffer label.
        /// </summary>
        private System.Windows.Forms.Label lbl2;
        /// <summary>
        /// Menu item to upload solutions during contest
        /// </summary>
        private System.Windows.Forms.MenuItem mnuUploadSolutions;

        private string plain = "karthikeyan";
        /// <summary>
        /// buffer label.
        /// </summary>
        private System.Windows.Forms.Label lblLT;

        /// <summary>
        /// buffer label
        /// </summary>
        //private System.Windows.Forms.Label label6; 

        /// <summary>
        /// picture box that contains the herbert image with eye closed.
        /// </summary>

        //todo kkk

        private System.Windows.Forms.PictureBox StandingEyeClosed;

# if(DESIGNER)
		/// <summary>
		/// designer's white button menu. 
		/// </summary>
		private System.Windows.Forms.MenuItem mnuWhitebttn;

		/// <summary>
		/// designer's wall right menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuWallRight;

		/// <summary>
		/// designer's wall down menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuWallDown;

		/// <summary>
		/// designer's eraser menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuEraser;

		/// <summary>
		/// designer's herbie menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuHerbie;

		/// <summary>
		/// designer's clear all menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuClearAll;

		/// <summary>
		/// designer's save level menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuSaveLevel;

		/// <summary>
		/// designer's grey button menu.
		/// </summary>
		private System.Windows.Forms.MenuItem mnuGreybttn;
# endif
        /// <summary>
        /// game timer for ending the application after 
        /// a certion time interval.
        /// </summary>
        //private System.Windows.Forms.Timer GameTimer;



        /// <summary>
        /// for keeping track of how much time programer 
        /// has given to this level.
        /// </summary>
        private System.Windows.Forms.Timer LevelTimer;

        /// <summary>
        /// exit menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuExit;

        /// <summary>
        /// undo menu
        /// 		/// </summary>
        private System.Windows.Forms.MenuItem mnuTxtUndo;

        /// <summary>
        /// cut menu
        /// </summary>
        private System.Windows.Forms.MenuItem mnuTxtCut;

        /// <summary>
        /// copy menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuTxtCopy;

        /// <summary>
        /// past menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuTxtPaste;

        /// <summary>
        /// clear menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuTxtClear;

        /// <summary>
        /// trace menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuTrace;

        /// <summary>
        /// path menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuPath;

        /// <summary>
        /// Show Pattern menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuShowPattern;

        /// <summary>
        /// fast image left side of speed scroll bar.
        /// </summary>
        private System.Windows.Forms.PictureBox picBFastHrbt;

        /// <summary>
        /// slow image right side of speed scroll bar.
        /// </summary>
        private System.Windows.Forms.PictureBox picBSlowHrbt;

        /// <summary>
        /// tooltip used for application.
        /// </summary>
        private System.Windows.Forms.ToolTip hTooltip;

        /// <summary>
        /// label used for displaying the highest level score of all programs of that level
        /// in single run of application.
        /// </summary>
        private System.Windows.Forms.Label lblScoreCurrent;

        /// <summary>
        /// label used for displaying text "Point:".
        /// </summary>
        private System.Windows.Forms.Label lblPointTxt;

        /// <summary>
        /// label used for displaying the score as herbert achives each target.
        /// </summary>
        private System.Windows.Forms.Label lblScorePerDot;

        /// <summary>
        /// label used for displaying the bytes used by programer
        /// for currently active level.
        /// </summary>
        private System.Windows.Forms.Label lblBytesUsed;

        /// <summary>
        /// label used for displaying the max chars allowed for
        /// the currently active level.
        /// </summary>
        private System.Windows.Forms.Label lblMaxChars;

        /// <summary>
        /// label used for displaying text "Level"
        /// </summary>
        private System.Windows.Forms.Label lblLevelTxt;

        /// <summary>
        /// label used for displaying the current level no.
        /// </summary>
        private System.Windows.Forms.Label lblLevelNo;

        /// <summary>
        /// displays that level is solved or not.
        /// </summary>
        private System.Windows.Forms.Label lblLevelSolved;


        /// <summary>
        /// displays text "Socre:"
        /// </summary>
        private System.Windows.Forms.Label lblScoreTxt;

        /// <summary>
        /// level displays the total score.
        /// </summary>
        private System.Windows.Forms.Label lblTotalScore;


        /// <summary>
        /// displays the total number of level available.
        /// </summary>
        private System.Windows.Forms.Label lblTotalLevels;

        /// <summary>
        /// displays text "Speed"
        /// </summary>
        private System.Windows.Forms.Label lblSpeedTxt;

        /// <summary>
        /// displays text "Levels"
        /// </summary>
        private System.Windows.Forms.Label lblLevelsTxt;

        /// <summary>
        /// this is a message box displayed at the bottom of the 
        /// from this is used for displaying the error message 
        /// and other welcome messages.
        /// </summary>
        private System.Windows.Forms.Label lblMsgBox;

        /// <summary>
        /// menu step.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuStepHrbt;

        /// <summary>
        /// menu item Go.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuGoHrbt;

        /// <summary>
        /// menu item Resume.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuResumeHrtb;

        /// <summary>
        /// menu item halt.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuHaltHrbt;

        /// <summary>
        /// menu item reset.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuResetHerbt;

        /// <summary>
        /// menu item about herbert.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuAboutHerbert;

        /// <summary>
        /// picture box containing the normal herbert image.
        /// </summary>
        private System.Windows.Forms.PictureBox pbHrbtStanding;

        /// <summary>
        /// picture box containing the left leg up herbert image.
        /// </summary>
        private System.Windows.Forms.PictureBox pbHrbtLeftLeg;

        /// <summary>
        /// picture box containing the right leg up herbert image.
        /// </summary>
        private System.Windows.Forms.PictureBox pbHrbtRightLeg;

        /// <summary>
        /// file Main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuMainFile;

        /// <summary>
        /// Edit Main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuMainEdit;

        /// <summary>
        /// Options Main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuMainOptions;

        /// <summary>
        /// Run Main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuMainRun;

        /// <summary>
        /// Help Main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuMainHelp;

        /// <summary>
        /// label used at the bottom of the editor for displaying 
        /// line tracing.
        /// </summary>
        private System.Windows.Forms.Label lblLineTracing;

        /// <summary>
        /// main panel which contains control like game baord, 
        /// line tracer, editor etc.
        /// </summary>
        private cHerbertBoard pnlMain;

        /// <summary>
        /// bar used for level changing.
        /// </summary>
        private System.Windows.Forms.VScrollBar LevelChangeBar;

        /// <summary>
        /// Separator menu used in Run main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuSeparatorRun;
# if(DESIGNER)
        private System.Windows.Forms.MenuItem menuItem1;
# endif
        /// <summary>
        /// Separator used in Edit main menu.
        /// </summary>
        private System.Windows.Forms.MenuItem mnuSeparator1Edit;

        /// <summary>
        /// picture box containing the image rotated to 45 degree.
        /// </summary>
        private System.Windows.Forms.PictureBox Herbert45;
        //		private System.Windows.Forms.MenuItem mnuWhitebttn;
        private System.Windows.Forms.MenuItem mnuMainDesign;
        //		private System.Windows.Forms.MenuItem menuItem1;
        //		private System.Windows.Forms.MenuItem mnuGreybttn;
        //		private System.Windows.Forms.MenuItem mnuWallRight;
        //		private System.Windows.Forms.MenuItem mnuHerbie;
        //		private System.Windows.Forms.MenuItem mnuWallDown;
        //		private System.Windows.Forms.MenuItem mnuClearAll;
        //		private System.Windows.Forms.MenuItem mnuEraser;
        //		private System.Windows.Forms.MenuItem mnuSaveLevel;



# if(DESIGNER)
        private System.Windows.Forms.TextBox txtLevelPoints;
        private System.Windows.Forms.Label lblLevelPoints;
        private int Xdn = 0;
        private int Ydn = 0;
        private int Xup = 0;
        private int Yup = 0;		
# endif
        /// <summary>
        /// picture box containing the image rotated to 45 degree.
        /// </summary>
        private System.Windows.Forms.PictureBox Herbert_45;

        #endregion

        #region User variables

        /// <summary>
        /// -by Pavan this is used to check the level solve message thread, so as to check during DoEvents
        /// </summary>
        private bool LevelSolveMsg = false;

        /// <summary>
        /// -by Pavan this helps in checking and adding the bucketing levels 
        /// </summary>
        private int BucketingLevels = 0;


        /// <summary>
        /// -by Pavan this helps in calculating the total solved levels implemented for bucketing 
        /// </summary>
        private int TotalSolvedLevels = 0;

        private object objScrollMonitor = new object();
        private object objMonitorLevelChange = new object();
#if(CONTEST)
        /// <summary>
        /// Boolean variable which indicates whether a warning message was displayed to user saying that he 
        /// </summary>
        private bool isInstanceInvalidWarningDisplayed = false;
#endif

        /// <summary>
        /// used to check whether the mouse is moving the thumb of levelchange scroll bar. till the time mouse is scrollign 
        /// the thumb it is set to false and when mouse is released it is set to true. and when button is clicked on the scroll bar 
        /// it is set to ture;
        /// </summary>
        private bool blnScrollMouseRelease = false;

        /// <summary>
        /// this for skeeping the paint event of pnlMain which is painting the image for scroll. if this variable is not set to 
        /// true before doing this app will crash.
        /// </summary>
        private bool blnSkeepSmoothScrollPaint = true;

        /// <summary>
        /// to skeep the call of smoothScroll fucntion.
        /// </summary>
        private bool blnSkeepLevel = false;


        DialogResult YesNoNextLevel = System.Windows.Forms.DialogResult.No;
        /// <summary>
        /// used this bool var for avoiding levelchange if it is changed in my program to keep it at proper place in event of level change.
        /// </summary>
        private bool blnProgramaticallyLevelChanged = false;

#if(RTDEBUG)
		private string strDebugLog;
#endif

        private int iFormHeight = 375;
        private int iSumOfAllLevelPoints = 0;
        private int isSiteDefaultUserId = 0;
        private int iMinTimeForPolling = 5;
        private int iTimeForPollingBeforeMsg = 10;
        private int mHBIntervalInMin;
        private int mHeartBeatCounter = 0;
        private int iNumWarningMsg;
        private int[] iPoolingRandTime;
        private bool[] blnToDoPooling;
        private bool[] blnMsgShown;
        private int[] iTimeRemainingForWarningX;
        private bool[] isForceClose;
        //private int[] iValidityOfWarningX;
        private string[] strWarningMsgX;
        private DateTime InstanceStartTime;
#if(CONTEST)
        private bool isSilentCloseSaveDone = false;
#endif


        /* 
		//Commented by Vivek for saving the run state
		private bool blnStepState = false;
		private bool blnResumeState = false;
		private bool blnGoState = false;
		private bool blnHaltState = false;
		private bool blnResetState = false;
		*/
        //private bool blnLevelFinishedMsg = false;

        //Added by Vivek 
        //This variable is added to check if a congratulatory messagebox is displayed or not
        //true : Messagebox displayed
        //false : Messagebox not displayed or it is disposed
        //		private bool isMessageDisplayed = false;
        int NextUnsolvedLevel = 0;
        // added by Nikhil Kardale on 24/10/2007
        int PrevUnsolvedLevel = 0;
        private bool blnChangeLevel = false;

        //Commented by Vivek for saving the run state
        //private int[] actualVirtualLineNum = new int[MAXLINES];

        //private int HrbtHaltDir = 0;
        private bool blnCloseInitiated = false;
#if(CONTEST)
        private int ScoreSaveDBRetryCount = 0;
#endif
        private bool blnLoadError = false;
        private bool dataLoaded = false;
        private bool blnAfterTimeOver = false;
        private System.Windows.Forms.DialogResult YesNoCancel = System.Windows.Forms.DialogResult.Yes;
        private System.Windows.Forms.DialogResult YesNoCancelOffline = System.Windows.Forms.DialogResult.Yes;
        private System.Windows.Forms.DialogResult YesNo = System.Windows.Forms.DialogResult.Yes;
        private bool errorShown = false;
        private int TotalGameTimeInMinSpent = 0;
        private int ScoreId = -1;

#if(CONTEST)
        /// <summary>
        /// An array of boolean variables for the status of controls used. <br>
        /// true: control enabled <br>
        /// false: control disabled
        /// </summary>
        private bool[] ControlStatus;


        /// <summary>
        /// An array of boolean variables for the status of menu. \n
        /// true: control enabled \n
        /// 		/// false: control disabled
        /// </summary>
        private bool[] MenuStatus;
#endif
        /// <summary>
        /// a variable which helps to keep track of number of times this level is visited.
        /// it's value is incremented by one each second at level timer till it's value is 2
        /// then level visited variable is incremented by one. this variable is reseted to 0
        /// on every level change.
        /// </summary>
        private int iNumTimesLevelVisitedHelper = 0;

        /// <summary>
        /// this variable keeps track of whether user has already attempted to run 
        /// the application or has finished
        /// playing the contest. 1 is not attempted, 2 means attempted, 3 means finished.
        /// </summary>
        //private int iGameStatus = 1;

        /// <summary>
        /// shows that game is not valid to run the game. This is true if statusId is 1 else it is false.
        /// </summary>
        //private bool blnGameStatus = true;

        /// <summary>
        /// buffer image and graphics.
        /// </summary>
        //private Graphics gHrbtBoard;
        //private Bitmap tempBoardImg;

        /// <summary>
        /// Game interval in mins.
        /// </summary> 
        public int GameInterval = 0;

        //private int MTimeInSecToStart = 0;
        //private int MTimeInSecRemainingToStart = 0;
        public int TotalTimeInSecRemaining = 0;

#if(CONTEST)
        /// <summary>
        /// checks whether the silent save 20 to 10 minutes before that contest end is succesful or not.
        /// </summary>
        internal bool blnIsSilentSaveSuccessful = false;


        /// <summary>
        /// variable to keep track for silent save for herbert data.
        /// </summary>
        public int TotalTimeInSilentSaveSecRemaining = 1;
#endif
        /// <summary>
        /// check if herbert board is redrawn
        /// </summary>
        private bool hrbtBoardRedrawn = true;

        /// <summary>
        /// this variable is used for editor text box tracing. which keeps the number of lines in txtbox
        /// </summary>		
        //Commented by Vivek for saving the run state
        //private int lineCount = 0;

        /// <summary>
        /// this variable is used to keep track of whether some code in txtbox is hidden or not.
        /// or it takes care of whether vertical and horizontal scroll is present or not.  
        /// </summary>		
        private bool blnHScroll = false;
        //private bool blnVScroll = false;

        /// <summary>
        /// if this is set to true only level 0 will be displayed and 
        /// no data will be saved for scores.
        /// if all levels are needed then set it to false;
        /// </summary>
        internal static bool blnTutorial = false;

        /// <summary>
        /// flag for Microsoft Demo only
        /// </summary>
        //private bool blnMSDemo = false;


        /// <summary>
        /// variable which takes care of herbert is reset or not.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private bool blnHReset = false;

        /// <summary>
        /// images to contain herbert images. it only contains 3 images used for straight
        /// movement.
        /// </summary>
        private Image[] arrHrbtImage;

        /// <summary>
        /// image that contains herbert 45 degree turned
        /// </summary>
        private Image img45;

        /// <summary>
        /// image that contains herbert 315 degree turned
        /// </summary>
        private Image img_45;

        /// <summary>
        /// this image contains image of herbert eye closed.
        /// </summary>
        private Image imgEyeClose;

        /// <summary>
        /// int variables to contain herbert current previous and destination positions.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private int curPosX, curPosY,prePosX, prePosY;

        /// <summary>
        /// int variables to contain herbert current previous and destination positions.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private int destPosX, destPosY, preDestPosX, preDestPosY;

        /// <summary>
        /// specifies the current direction of herbert. 
        ///0 is up direction 
        ///1 is right direction
        ///2 is down direction
        ///3 is left direction
        /// </summary>
        //Commented by Vivek for saving the run state
        //private int CurDir = 0;



        //private int bakCurDir = 0;

        /// <summary>
        /// Command that is given to herbert like s, r or l.
        /// </summary>
        private string command = "";
        /// <summary>
        /// Added By Rajesh To check for level saved
        /// </summary>
        bool isCurrentLevelSaved = false;

        /// <summary>
        /// variables defined to be used in interperter.
        /// iProgLen is used for program length.
        /// iTrashedSP for stack tracing.
        /// iSP is used for current stack pointer.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private int iProgLen, iTrashedSP, iSP;

        /// <summary>
        /// bool variable is for stackTraced and
        /// int array is defined as stack.
        /// </summary>
        //private bool arrLevels[currentLevelIndex].sStackTrashed = false;
        //private int[] aiStack = new int[STACKSIZE];

        //Commented by Vivek for saving the run state
        //private int[] aiStack = new int[STACKSIZE];

        //private int[] bakaiStack;

        /// <summary>
        /// this char array contains program written in code editor
        /// as char formate.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private char[] pcProg;

        /// <summary>
        /// this variable contains currently executing line.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private char[] acCurrentLine = new char[1010];

        //private char[] bakacCurrentLine;

        /// <summary>
        /// variable to check whether trace is displayed or not.
        /// </summary>
        private short sTraceDisplayed;

        /// <summary>
        /// this is an array defined to be used in interpreter.
        /// </summary>
        private short[] asOptions = { TRUE, TRUE, FALSE };

        /// <summary>
        /// boolean variable which tells thread that herbert is finished
        /// it's execution of char assigned previously and now it's ready
        /// to accept new char.
        /// sNeedChar = true says this.
        /// </summary>
        private bool sNeedChar = true;

        //Commented by Vivek for saving the run state
        //private AtLineInfoStruct[] atLineInfo = new AtLineInfoStruct[MAXLINES];

        /// <summary>
        /// number of lines in the code editor.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private int iNumLines;

        //Commented by Vivek for saving the run state
        //private tHStateStruct tHState = new tHStateStruct();
        //private tHStateStruct baktHState = new tHStateStruct();

        /// <summary>
        /// this is the thread which runs herbert.
        /// </summary>
        private Thread t;

        /// <summary>
        /// this is the int variable which defines the sleep time in miliseconds 
        /// for a given thread. 
        /// </summary>
        internal static int herbtSpeed = 90;



        /// <summary>
        /// this variable indicate whether smooth scroll feature is enabled or not
        /// </summary>
        private bool isSmoothScrollEnabled = true;

        /// <summary>
        /// this variable indicate whether smooth scroll feature is enabled or not
        /// </summary>
        private bool isBucketingEnabled = false;

        //Commented by Vivek for saving the run state
        //private tCurLineStruct tCurLine;

        //private tCurLineStruct baktCurLine;

        /// <summary>
        /// this is the horizontal scroll bar used for changing the speed of 
        /// herbert.
        /// </summary>
        private System.Windows.Forms.HScrollBar SpeedBar;

        /// <summary>
        /// this variable is used for killing the thread which is 
        /// running in an infinite loop. This thread runs herbert.
        /// </summary>
        public volatile object progClosing = true;
        private volatile object m_blnThreadStarted = false;

        /// <summary>
        /// <P>BoardHeight: height of the game board.</P>
        /// <P>BoardWidth: widht of the game board.</P>
        /// <P>Buttons: number of small dots present on the 
        /// game board in one direction.</P>
        /// <P>dotDist: defines the distance between the 
        /// two small dots.</P>
        /// <P>herbertState: herbert complets it's movement 
        /// btwn two dots in 8 steps this variable contains
        /// this state of next movement(step).</P>
        /// </summary>
        private int BoardHeight, BoardWidth;
        public static int herbertState = 0;
        //numDots, dotDist,

        /// <summary>
        /// these are 9 different states of herbert btn 
        /// one small dot to next small dot.
        /// </summary>
        private int[] stateArray = { 0, 2, 0, 1, 0, 2, 0, 1, 0 };

        /// <summary>
        /// initial point of herbert or point used for resetting herbert position.
        /// </summary>
        internal static Point InitialOrResetHrbt;

        /// <summary>
        /// Object of level Class. this class defines all the levels.
        /// </summary> 
        internal static Level[] arrLevels = null;

        /// <summary>
        /// contains the number of currently active level.
        /// </summary>
        private int currentLevelId = 0;

        /// <summary>
        /// contains the index of currently active levels index.
        /// </summary>
        private int _currentLevelIndex = 0;
        private int currentLevelIndex
        {
            get { return _currentLevelIndex; }
            // This is what I can use to hold a lock & purge the other threads ...
            set { _currentLevelIndex = value; }
        }

#if(CONTEST)
        /// <summary>
        /// Web Service while uploading solutions through file menu.
        /// </summary>
        HService.HDataService HSUploadSolution;

        /// <summary>
        /// Web Service while saving solutions on exit.
        /// </summary>
        HService.HDataService HSSaveOnExit;

        /// <summary>
        /// Web Service while saving level data on scroll.
        /// </summary>
        HService.HDataService HSLevelSave;
#endif


        /// <summary>
        /// variable used to indicate that step by step Menu is in use.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private bool stepByStep = false;

        /// <summary>
        /// Variable to indicate that herbert has completed one step.
        /// this is used for step by step execution.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private bool OneStepDone = false;

        /// <summary>
        /// Variable to see if go button is clicked this is 
        /// used only in case of Step by Step process.
        /// </summary>
        //Commented by Vivek for saving the run state
        //private bool goClicked = false;
        /// <summary>
        /// used for step of herbert to indicate that end of program is reached. 
        /// </summary>

        //Commented by Vivek for saving the run state
        //private volatile object EndofProg = false;

        /// <summary>
        /// checks whether herbert is halted or not.
        /// </summary>
        //private bool hrbthalted = false; commented by karthikeyan 16/03

        /// <summary>
        /// variable to set trace on or off.
        /// </summary>
        private bool traceOn = false;

        /// <summary>
        /// variable to set Path on or off.
        /// </summary>
        private bool PathOn = true;

        /// <summary>
        /// check if herbert is redrawn
        /// this is to avoid the error of 
        /// object locking this variable is
        /// set to true in paint method of herbertPicbox
        /// and it is set to false if location of pic box
        /// is changed in our thread.
        /// </summary>		
        private bool hrbtRedrawn = true;

        /// <summary>
        /// check for validity of user if invalid close application.
        /// </summary>
        private bool blnIsValid = true;

        /// <summary>
        /// returns the id of the level score inserted in the
        /// level socre main table.
        /// </summary>
        //private int levelScoreID = 0;

        /// <summary>
        /// contains the start time of the game.
        /// </summary>
        private DateTime startdate;

        private bool isErrorLogged = true;
        private bool isInternalErrorLogged = true;
        private bool isUserErrorLogged = true;
        private bool isLevelChangeLogged = true;
        private bool isExceptionLogged = true;
        private bool isMismatchProbeOn = true;

        /// <summary>
        /// bool varaible indicates system error.
        /// </summary>
        private volatile bool blnSystemError = false;

        /// <summary>
        /// This variable is used to log all errors in the application.
        /// </summary>
        private System.Text.StringBuilder sbErrorLog = new StringBuilder("");

        /*variable to reset reset herbert's position.*/
# if(DESIGNER)
		private bool resetHrtbPos = false;	
	
		/// <summary>
		/// This variable indicates whether the designer is for editing a single level.
		/// </summary>
		private static bool isSingleLevelDesigner=false;
#endif

#if(CONTEST)
        //Added by Vivek Balagangadharan
        // Description : This variable is used only for the levelchange_valuechanged event.
        //				 It indicates whether it is the first time the event is fired.
        //				 true : event fired for the first time,i.e. during data load.
        //				 false : event fired due to click on scroll bar
        /// <summary>
        /// This variable indicates whether it is the first time this event is fired.
        /// </summary>
        private bool blnFirstFunctionCall = true;
#endif

        /// <summary>
        /// bool variable to indicate that game time is over.
        /// </summary>
        private bool TimeOver = false;
        //private bool MaintenanceStarted = false;
        private System.Windows.Forms.Panel pnlContainer;
        private System.Windows.Forms.PictureBox pbHrbtStandingZOOMIN;
        private System.Windows.Forms.PictureBox StandingEyeClosedZOOMIN;
        private System.Windows.Forms.PictureBox Herbert_45ZOOMIN;
        private System.Windows.Forms.PictureBox Herbert45ZOOMIN;
        private System.Windows.Forms.PictureBox pbHrbtRightLegZOOMIN;
        private System.Windows.Forms.PictureBox pbHrbtLeftLegZOOMIN;
        private System.Windows.Forms.Button btPath;
        private System.Windows.Forms.Button btTrace;
        private System.Windows.Forms.Button btStep;
        private System.Windows.Forms.Button btGoPause;
        private System.Windows.Forms.Button btStop;
        private System.Windows.Forms.Button btPaste;
        private System.Windows.Forms.Button btCut;
        private System.Windows.Forms.Button btCopy;
        private System.Windows.Forms.Button btRight;
        private System.Windows.Forms.Button btStraight;
        private System.Windows.Forms.Button btLeft;
#if(CONTEST)
        private System.Windows.Forms.Button btRestore;
#endif
        private System.Windows.Forms.Panel pnlToolBar;
        private System.Windows.Forms.Label lblLoading;
        private System.Windows.Forms.Label lbl3;
        private System.Windows.Forms.Label lblClosing;
        private System.Windows.Forms.PictureBox pbRun;
        private System.Windows.Forms.PictureBox pbPause;
        private System.Windows.Forms.Label lblTxtBytes;
        private System.Windows.Forms.MenuItem mnuToolBar;
        private System.Windows.Forms.MenuItem mnuSmoothScroll;

        /// <summary>
        /// total time game was running excluding the time spend on level 0.
        /// </summary>
        //private int totaltime = 0;

        /// <summary>
        /// variables for storing the data of richtext box
        /// </summary>

        int txtTotalLength;
        int txtTotalLines;
        string[] txtLines;

        private bool blnLevelChanging = false;
        /// <summary>
        /// Added By rajesh,To detect Path menu change while herbert moving. to resolve issue 3297
        /// </summary>
        private bool blnPathChange = false;
#if(CONTEST)
        private MenuItem mnuSeperator2Edit;
        private MenuItem mnuRestoreBest;
        private Label lblTimer;
        private Label lblTimeLeft;
#endif
#if(DESIGNER)
        private ComboBox cmbxLevelType;
        private Label lblLevelType;        
        private Button btShowPattern;
#endif
        /// <summary>
        /// 
        /// </summary>
        private int iLoadtime = 0;
        #endregion
        private System.Windows.Forms.MenuItem menuSwitchContest;
        private Button btnPrevUnsolved;
        private Button btnNextUnsolved;
        private MenuItem mnuTimer;
        //private Label lblLevelPoints;
        //private TextBox txtLevelPoints;
        //this.txtLevelPoints = new System.Windows.Forms.TextBox();
        //this.lblLevelPoints = new System.Windows.Forms.Label();
        #region For 2.0 Compatible
        /// <summary>
        /// Rajesh:: 29/07/06 :: For Thread safe call to message box
        /// </summary>
        /// <param name="strMessage"></param>
        /// <param name="strMessageTitle"></param>
        // delegate void MessagBoxtCallback(string strMessage, string strMessageTitle);


        #endregion

        object MessageBoxResult = null;

        #region Entry point
        private static string baseURL = "";
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main(string[] argsFromMain)
        {
            // added by Nikhil Kardale to fix issue 9910 - incorrect record of culture info in DB
            GlobalData.startingCulture = System.Threading.Thread.CurrentThread.CurrentCulture;
            DateTimeFormatInfo dfi1 = new DateTimeFormatInfo();
            CultureInfo ci1 = new CultureInfo("en-us");
            dfi1.MonthDayPattern = "mm/dd/yy";
            ci1.DateTimeFormat = dfi1;
            dfi1.DateSeparator = "/";
            System.Threading.Thread.CurrentThread.CurrentCulture = ci1;
            try
            {
                //baseURL = (string)AppDomain.CurrentDomain.GetData("APPBASE");
                //GlobalData.URL = baseURL + "HDataService.asmx";


# if(CONTEST)
                //												GlobalData.GUID = "B7C1A67D-B060-4990-828E-A103BE05A7C2";
                //				//				//				GlobalData.GUID = "764AF82E-2085-46D6-BB92-6E9523FE34E7";
                //												GlobalData.HerbertMode = HMode.Contest;
#endif
#if(DESIGNER)
//				GlobalData.HerbertMode = HMode.Designer; 
//				GlobalData.GUID = "64b7d2f1-d8be-4a30-8ad5-fa4c1fff30b6";
#endif
                //								baseURL = "http://www.ft-india.com/ic2006stage/";
                //				//				//baseURL = "http://vivek/ic2006/";
                //								GlobalData.URL = baseURL + "HDataService.asmx";


                try
                {
                    GlobalData.sessionTimeOut = int.Parse(System.Configuration.ConfigurationSettings.AppSettings["HServiceTimeOut"]);
                    GlobalData.herbertTitle = System.Configuration.ConfigurationSettings.AppSettings["HerbertTitle"];
                    GlobalData.smoothScrollInterval = int.Parse(System.Configuration.ConfigurationSettings.AppSettings["SmoothScrollSpeed"]);
                    GlobalData.strLocalVersion = System.Configuration.ConfigurationSettings.AppSettings["LocalVersion"].ToString();
                    GlobalData.iContestId = int.Parse(System.Configuration.ConfigurationSettings.AppSettings.Get("ContestId").ToString());
                    GlobalData.iIniSeedRandomDelay = int.Parse(System.Configuration.ConfigurationSettings.AppSettings.Get("IniSeedRandomDelay").ToString());
#if(!DEBUG)                   
                    GlobalData.isHerbertFromSite = true;
#endif
                }
                catch
                {
                    GlobalData.sessionTimeOut = 90000;
                    GlobalData.herbertTitle = "Herbert - Tutorial";
                    GlobalData.smoothScrollInterval = 0;
                    GlobalData.strLocalVersion = "false";
                    GlobalData.iContestId = 207;
                    GlobalData.iIniSeedRandomDelay = 120000;
                    GlobalData.isHerbertFromSite = false;
                }

                try
                {

                    GlobalData.strLocalVersion = System.Configuration.ConfigurationSettings.AppSettings["LocalVersion"].ToString();
                    baseURL = (string)AppDomain.CurrentDomain.GetData("APPBASE");

                    
                    /*Live URL*/
                    //baseURL = "http://www.wildnoodle.com/";
                    /*Staging URL*/
                    baseURL = "http://staging.wildnoodle.com/";
                    //baseURL = "http://localhost/";
#if(DEBUG)
                    //baseURL = "http://nikhilk/HService_OLD/";
#endif
                    //GlobalData.URL = baseURL + "HService2.0/HDataService.asmx";
                    GlobalData.URL = baseURL + "HDataService.asmx";

                }
                catch
                {
                    /*Live URL*/
                    //GlobalData.URL = "http://www.wildnoodle.com/HDataService.asmx";
                    /*Staging URL*/
                    GlobalData.URL = "http://staging.wildnoodle.com/HDataService.asmx";

                }
                if (GlobalData.strLocalVersion.ToLower() == "true")
                {
                    GlobalData.URL = System.Configuration.ConfigurationSettings.AppSettings["WebServiceURL"].ToString();
                }
                //hardcode GUID for warmup round.
                //for warm up disable login.

#if(DESIGNER)
				
//				GlobalData.GUID = "7274D7B8-EF1B-4E3E-87DD-539105039F51";
//				GlobalData.HerbertMode = HMode.Designer;
				
#endif
                string[] args = WebCommandLineHelper.GetCommandLineArgs(argsFromMain);
                //MessageBox.Show("args:"+args.Length, "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);                
                if (args.Length > 0)
                {
                    for (int j = 0; j < args.Length; j++)
                    {
                        string[] pair = args[j].Split('&');

                        for (int i = 0; i < pair.Length; i++)
                        {
                            string[] val = pair[i].Split('=');

                            switch (val[0].ToLower())
                            {
                                //remore redundand items and check for case dependency
                                case "sdi":
                                    GlobalData.GUID = val[1].ToString();
                                    GlobalData.iShowSwtichContest = 0;
#if(DESIGNER)
                                GlobalData.HerbertMode = HMode.Designer;
								
#endif
# if(CONTEST)
                                    GlobalData.HerbertMode = HMode.Contest;
#endif
                                    break;
#if(DESIGNER)
                            case "lid" :
                                try
                                {	
                                    /*==============================================================================
                                    *  Modified By : Vivek Balagangadharan
                                    *  Description : iLevelId is a comma separated list of levels.
                                    *  Modified On : 10-Apr-2006
                                    *  Special Comments : iLevelId was an int type initially
                                    * ==============================================================================*/
                                    GlobalData.iLevelId = val[1].ToString();
                                }
                                catch
                                {
                                    GlobalData.iLevelId = "-1";
                                }
                                GlobalData.HerbertMode = HMode.Designer;
                                //isSingleLevelDesigner = true;
                                break;
#if(PATTERN_GENERATER)
                            case "pid":
                                try
                                {
                                    GlobalData.iPatternId = val[1].ToString();
                                    GlobalData.iPatternId = GlobalData.iPatternId.Replace(",", "'',''");
                                    GlobalData.iPatternId = "''" + GlobalData.iPatternId + "''";
                                }
                                catch
                                {
                                    GlobalData.iPatternId = "-1";
                                }
                                break;
#endif
#endif
                            }
                            val = null;
                        }
                    }
                }
#if(PATTERN_GENERATER)
                if (GlobalData.iPatternId != "-1" || GlobalData.iLevelId != "-1")
                {
                    if (!File.Exists("Pattern.pat"))
                    {
                        // creating the log file in the specified path, one log file will be created for a day and all entries will be appended to it
                        FileStream f1 = File.Create("Pattern.pat");
                        f1.Close();
                        FileStream stream = new FileStream("Pattern.pat", FileMode.Open, FileAccess.ReadWrite, FileShare.Read);
                        using (StreamWriter s1 = new StreamWriter(stream))
                        {
                            if (GlobalData.iPatternId != "-1")
                            {
                                s1.Write("pid=" + GlobalData.iPatternId);
                            }
                            else if (GlobalData.iLevelId != "-1")
                            {
                                s1.Write("lid=" + GlobalData.iLevelId);
                            }
                            s1.Close();
                        }
                        stream.Close();
                    }
                    else
                    {
                        //File.Delete("Pattern.pat");                    
                        FileStream f1 = File.Create("Pattern.pat");
                        f1.Close();
                        FileStream stream = new FileStream("Pattern.pat", FileMode.Open, FileAccess.ReadWrite, FileShare.Read);
                        using (StreamWriter s1 = new StreamWriter(stream))
                        {
                            if (GlobalData.iPatternId != "-1")
                            {
                                s1.Write("pid=" + GlobalData.iPatternId);
                            }
                            else if (GlobalData.iLevelId != "-1")
                            {
                                s1.Write("lid=" + GlobalData.iLevelId);
                            }
                            s1.Close();
                        }


                    }
                }
#endif

#if(CONTEST || DESIGNER)
#if (EXCEPTION)
                try
                {
#endif
#if(PATTERN_GENERATER)
                     System.Diagnostics.Process p;
                    if (OtherInstanceExists(out p))
                    {
                        //Switching to a running instance of the application... 
                        IWshRuntimeLibrary.WshShellClass shell =
                           new IWshRuntimeLibrary.WshShellClass();
                        object p1 = (object)p.Id;
                        object p2 = (object)null;
                        shell.AppActivate(ref p1, ref p2);
                    }
                    else
                    {
#endif
                    while (true)
                    {
                        DialogResult dr = DialogResult.No;
#if(CONTEST||DESIGNER)
                        if (!GlobalData.IsShowContestList)//for switch contest.
                        {
#endif
                            Login l = new Login();
                            dr = l.ShowDialog();
#if(CONTEST||DESIGNER)
                        }
                        else
                        {
                            GlobalData.IsShowContestList = false;
                            Login l = new Login();

                            l.ShowConetestSeltionWindow();

                            if (!GlobalData.IsLoadFromFile)
                                dr = l.ShowDialog();
                            else
                            {
                                dr = DialogResult.Yes;
                            }
                        }
#endif
                        if (dr == DialogResult.Yes)
                        {
#endif
                            Application.Run(new HerbertMain());
#if(CONTEST || DESIGNER )
                        }
                        else
                        {
                            Application.Exit();
                        }
#if(PATTERN_GENERATER)
                            if (!GlobalData.IsreloadApplication)
                                break;
                            else
                                GlobalData.IsreloadApplication = false;
#endif

                        if (!GlobalData.IsShowContestList)
                        {
                            break;
                        }
#if(PATTERN_GENERATER)
                            else
                                GlobalData.IsShowContestList = false;
#endif

                    }
#if(PATTERN_GENERATER)
                    }
#endif


#if (EXCEPTION)
                }
                catch (Exception exp)
                {
                    //Insufficient disk space to run the application.
#if(PROBE)
                    //ProbeID:010
                    MessageBox.Show("ProbeID: 010" + "\n Msg: " + exp.Message + "\n Trace: " + exp.StackTrace + "\n Inner Msg: " + exp.InnerException, "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                    //Console.WriteLine(exp.Message + ", Main, 11");
                }
#endif
#endif
            }
            catch (Exception exp)
            {
                MessageBox.Show("H0001: Herbert can not be run directly from a Run/Save dialog box unless your security settings have been correctly configured. Please configure your security settings as specified at http://www.wildnoodle.com/help." + exp.Message, "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }

        }
        static bool OtherInstanceExists(out Process proc)
        {
            Process[] p = Process.GetProcessesByName(
               Process.GetCurrentProcess().ProcessName);
            proc = null;
            if (p.Length > 0)
            {
                //first check this is not the current process 
                if (p.Length == 1)
                {
                    if (p[0].Id == Process.GetCurrentProcess().Id)
                    {
                        return false;
                    }
                    else
                    {
                        proc = p[0];
                        return true;
                    }
                }
                else
                {
                    foreach (Process pr in p)
                    {
                        if (pr.Id != Process.GetCurrentProcess().Id)
                        {
                            proc = pr;
                        }
                    }
                    return true;
                }
            }
            else
            {
                return false;
            }
        }
        #endregion

        #region Initialization

        public HerbertMain()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();
#if(DESIGNER)
            //Added By rajesh 17/05/07
            this.cmbxLevelType.DataSource = arrLevelType;
#endif
            //
            // TODO: Add any constructor code after InitializeComponent call
            //
            HInitialize();
            mi = new MethodInvoker(setImage);

        }


        private void HInitialize()
        {
            arrHrbtImage = new Image[3];
            getImages();
            BoardHeight = HerbertBoard.Width = (HConstants.GRIDDOTSPERLINE * HConstants.DOTSPACE) + HConstants.DOTSPACE;
            BoardWidth = HerbertBoard.Height = HerbertBoard.Width;
            //this.herbertPicBox = new System.Windows.Forms.PictureBox();
            this.herbertPicBox = new MyPicBox();
            //this.SuspendLayout();			
            this.herbertPicBox.Location = new System.Drawing.Point(BoardWidth / 2 + (HOFFSET - 2 - HConstants.DOTSPACE) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (HOFFSET - 2 - HConstants.DOTSPACE) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
            //this.herbertPicBox.SizeMode = System.Windows.Forms.PictureBoxSizeMode.AutoSize;
            this.herbertPicBox.Size = new Size(14, 14);
            this.herbertPicBox.BackColor = Color.Transparent;
            this.herbertPicBox.Image = arrHrbtImage[herbertState];
            imgForPicBox = arrHrbtImage[herbertState];
            this.herbertPicBox.Paint += new System.Windows.Forms.PaintEventHandler(this.herbertPicBox_Paint);
            this.HerbertBoard.Controls.Add(this.herbertPicBox);

            //this.ResumeLayout(false);

            /*calucate and set all position variables.*/
            //logic is written in the try catch block just above for why DOTSPACE is used here.

            //Commented by Vivek for saving the run state
            //preDestPosX = prePosX = destPosX = curPosX = BoardWidth/2+HOFFSET-HConstants.DOTSPACE;
            //preDestPosY = prePosY = destPosY = curPosY = BoardHeight/2+HOFFSET-HConstants.DOTSPACE;
            //InitialOrResetHrbt = new Point(curPosX,curPosY);

            InitialOrResetHrbt = new Point(BoardWidth / 2 + HOFFSET - HConstants.DOTSPACE, BoardHeight / 2 + HOFFSET - HConstants.DOTSPACE);


            //set a initial value of speed.
            SpeedBar.Value = herbtSpeed;
            //future changes, optimise design if needed, Vijay
            currentLevelId = currentLevelIndex;

            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                LevelChangeBar.Enabled = false;//rename scroll bar.
#if(CONTEST)
                btRestore.Enabled = false;
                mnuSeperator2Edit.Enabled = false;
                mnuRestoreBest.Enabled = false;
#endif
            }
            else
                startdate = DateTime.Now;

            //Commented by Vivek for saving the run state
            //blnHReset = true;
            IniOrResetRunMenuLoad();
            /*calculate the start time of herbert.*/

            /*initilize the context menu*/
            //			MenuItem[] menuItems = new MenuItem[]{
            //													 this.mnuCMUndo,
            //													 this.menuItem5,
            //													 this.mnuCMCut,
            //													 this.mnuCMCopy,
            //													 this.mnuCMPaste,
            //													 this.mnuCMDelete};
            //			cM = new ContextMenu(menuItems);			
            //display design menu.
            //GlobalData.IsDesigner = 1;
        }


        #endregion

        #region Windows Form Designer generated code
        //this.txtLevelPoints = new System.Windows.Forms.TextBox();
        //this.lblLevelPoints = new System.Windows.Forms.Label();
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(HerbertMain));
            this.txtCodeEditor = new System.Windows.Forms.TextBox();
            this.hTooltip = new System.Windows.Forms.ToolTip(this.components);
            this.LevelChangeBar = new System.Windows.Forms.VScrollBar();
            this.SpeedBar = new System.Windows.Forms.HScrollBar();
            this.btPath = new System.Windows.Forms.Button();
            this.btTrace = new System.Windows.Forms.Button();
            this.btStep = new System.Windows.Forms.Button();
            this.btGoPause = new System.Windows.Forms.Button();
            this.btStop = new System.Windows.Forms.Button();
            this.btPaste = new System.Windows.Forms.Button();
            this.btCut = new System.Windows.Forms.Button();
            this.btCopy = new System.Windows.Forms.Button();
            this.btRight = new System.Windows.Forms.Button();
            this.btStraight = new System.Windows.Forms.Button();
            this.btLeft = new System.Windows.Forms.Button();
            this.btRestore = new System.Windows.Forms.Button();
            this.btnPrevUnsolved = new System.Windows.Forms.Button();
            this.btnNextUnsolved = new System.Windows.Forms.Button();
            this.mnuMainFile = new System.Windows.Forms.MenuItem();
            this.mnuUploadSolutions = new System.Windows.Forms.MenuItem();
            this.menuSwitchContest = new System.Windows.Forms.MenuItem();
            this.mnuExit = new System.Windows.Forms.MenuItem();
            this.mnuMainEdit = new System.Windows.Forms.MenuItem();
            this.mnuTxtUndo = new System.Windows.Forms.MenuItem();
            this.mnuSeparator1Edit = new System.Windows.Forms.MenuItem();
            this.mnuTxtCut = new System.Windows.Forms.MenuItem();
            this.mnuTxtCopy = new System.Windows.Forms.MenuItem();
            this.mnuTxtPaste = new System.Windows.Forms.MenuItem();
            this.mnuTxtClear = new System.Windows.Forms.MenuItem();
            this.mnuSeperator2Edit = new System.Windows.Forms.MenuItem();
            this.mnuRestoreBest = new System.Windows.Forms.MenuItem();
            this.HerbertMenu = new System.Windows.Forms.MainMenu(this.components);
            this.mnuMainOptions = new System.Windows.Forms.MenuItem();
            this.mnuTrace = new System.Windows.Forms.MenuItem();
            this.mnuPath = new System.Windows.Forms.MenuItem();
            this.mnuToolBar = new System.Windows.Forms.MenuItem();
            this.mnuSmoothScroll = new System.Windows.Forms.MenuItem();
            this.mnuTimer = new System.Windows.Forms.MenuItem();
            this.mnuMainRun = new System.Windows.Forms.MenuItem();
            this.mnuStepHrbt = new System.Windows.Forms.MenuItem();
            this.mnuGoHrbt = new System.Windows.Forms.MenuItem();
            this.mnuResumeHrtb = new System.Windows.Forms.MenuItem();
            this.mnuSeparatorRun = new System.Windows.Forms.MenuItem();
            this.mnuHaltHrbt = new System.Windows.Forms.MenuItem();
            this.mnuResetHerbt = new System.Windows.Forms.MenuItem();
            this.mnuMainDesign = new System.Windows.Forms.MenuItem();
            this.mnuMainHelp = new System.Windows.Forms.MenuItem();
            this.mnuAboutHerbert = new System.Windows.Forms.MenuItem();
            this.lblLineTracing = new System.Windows.Forms.Label();
            this.PanalTxtCodeEdit = new System.Windows.Forms.Panel();
            this.lblMsgBox = new System.Windows.Forms.Label();
            this.lblLevelsTxt = new System.Windows.Forms.Label();
            this.lblScoreTxt = new System.Windows.Forms.Label();
            this.lblTotalScore = new System.Windows.Forms.Label();
            this.picBFastHrbt = new System.Windows.Forms.PictureBox();
            this.picBSlowHrbt = new System.Windows.Forms.PictureBox();
            this.lblTotalLevels = new System.Windows.Forms.Label();
            this.lblTraceFirst = new System.Windows.Forms.Label();
            this.lblBlack = new System.Windows.Forms.Label();
            this.lblTraceSecond = new System.Windows.Forms.Label();
            this.lbl2 = new System.Windows.Forms.Label();
            this.lblLT = new System.Windows.Forms.Label();
            this.pbHrbtStanding = new System.Windows.Forms.PictureBox();
            this.pbHrbtLeftLeg = new System.Windows.Forms.PictureBox();
            this.pbHrbtRightLeg = new System.Windows.Forms.PictureBox();
            this.Herbert45 = new System.Windows.Forms.PictureBox();
            this.Herbert_45 = new System.Windows.Forms.PictureBox();
            this.StandingEyeClosed = new System.Windows.Forms.PictureBox();
            this.lblSpeedTxt = new System.Windows.Forms.Label();
            this.LevelTimer = new System.Windows.Forms.Timer(this.components);
            this.pnlContainer = new System.Windows.Forms.Panel();
            this.lblTimeLeft = new System.Windows.Forms.Label();
            this.lblTimer = new System.Windows.Forms.Label();
            this.HerbertBoard = new Designer.cHerbertBoard();
            this.pnlMain = new Designer.cHerbertBoard();
            this.lblTxtBytes = new System.Windows.Forms.Label();
            this.lblMaxChars = new System.Windows.Forms.Label();
            this.lblLevelSolved = new System.Windows.Forms.Label();
            this.lblLevelTxt = new System.Windows.Forms.Label();
            this.lblScorePerDot = new System.Windows.Forms.Label();
            this.lblScoreCurrent = new System.Windows.Forms.Label();
            this.lblPointTxt = new System.Windows.Forms.Label();
            this.lblLevelNo = new System.Windows.Forms.Label();
            this.lblBytesUsed = new System.Windows.Forms.Label();
            this.pnlToolBar = new System.Windows.Forms.Panel();
            this.StandingEyeClosedZOOMIN = new System.Windows.Forms.PictureBox();
            this.Herbert_45ZOOMIN = new System.Windows.Forms.PictureBox();
            this.Herbert45ZOOMIN = new System.Windows.Forms.PictureBox();
            this.pbHrbtRightLegZOOMIN = new System.Windows.Forms.PictureBox();
            this.pbHrbtLeftLegZOOMIN = new System.Windows.Forms.PictureBox();
            this.pbHrbtStandingZOOMIN = new System.Windows.Forms.PictureBox();
            this.lblClosing = new System.Windows.Forms.Label();
            this.lblLoading = new System.Windows.Forms.Label();
            this.lbl3 = new System.Windows.Forms.Label();
            this.pbRun = new System.Windows.Forms.PictureBox();
            this.pbPause = new System.Windows.Forms.PictureBox();
            ((System.ComponentModel.ISupportInitialize)(this.picBFastHrbt)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.picBSlowHrbt)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtStanding)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtLeftLeg)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtRightLeg)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert45)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert_45)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.StandingEyeClosed)).BeginInit();
            this.pnlContainer.SuspendLayout();
            this.pnlMain.SuspendLayout();
            this.pnlToolBar.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.StandingEyeClosedZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert_45ZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert45ZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtRightLegZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtLeftLegZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtStandingZOOMIN)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbRun)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbPause)).BeginInit();
            this.SuspendLayout();
            // 
            // txtCodeEditor
            // 
            this.txtCodeEditor.BackColor = System.Drawing.Color.White;
            this.txtCodeEditor.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.txtCodeEditor.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.txtCodeEditor.Location = new System.Drawing.Point(11, 29);
            this.txtCodeEditor.MaxLength = 999;
            this.txtCodeEditor.Multiline = true;
            this.txtCodeEditor.Name = "txtCodeEditor";
            this.txtCodeEditor.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.txtCodeEditor.ScrollBars = System.Windows.Forms.ScrollBars.Horizontal;
            this.txtCodeEditor.Size = new System.Drawing.Size(246, 181);
            this.txtCodeEditor.TabIndex = 0;
            this.txtCodeEditor.WordWrap = false;
            this.txtCodeEditor.TextChanged += new System.EventHandler(this.txtCodeEditor_TextChanged);
            this.txtCodeEditor.KeyDown += new System.Windows.Forms.KeyEventHandler(this.txtCodeEditor_KeyDown);
            this.txtCodeEditor.KeyUp += new System.Windows.Forms.KeyEventHandler(this.txtCodeEditor_KeyUp);
            this.txtCodeEditor.MouseDown += new System.Windows.Forms.MouseEventHandler(this.txtCodeEditor_MouseDown);
            this.txtCodeEditor.KeyPress += new System.Windows.Forms.KeyPressEventHandler(this.txtCodeEditor_KeyPress);
            // 
            // hTooltip
            // 
            this.hTooltip.AutoPopDelay = 2000;
            this.hTooltip.InitialDelay = 500;
            this.hTooltip.ReshowDelay = 100;
            // 
            // LevelChangeBar
            // 
            this.LevelChangeBar.Location = new System.Drawing.Point(481, 4);
            this.LevelChangeBar.Maximum = 110;
            this.LevelChangeBar.Name = "LevelChangeBar";
            this.LevelChangeBar.Size = new System.Drawing.Size(18, 240);
            this.LevelChangeBar.SmallChange = 10;
            this.LevelChangeBar.TabIndex = 25;
            this.hTooltip.SetToolTip(this.LevelChangeBar, "Level Bar, Scroll to change level");
            this.LevelChangeBar.ValueChanged += new System.EventHandler(this.LevelChange_ValueChanged);
            this.LevelChangeBar.Scroll += new System.Windows.Forms.ScrollEventHandler(this.LevelChangeBar_Scroll);
            // 
            // SpeedBar
            // 
            this.SpeedBar.LargeChange = 1;
            this.SpeedBar.Location = new System.Drawing.Point(236, 249);
            this.SpeedBar.Name = "SpeedBar";
            this.SpeedBar.Size = new System.Drawing.Size(180, 16);
            this.SpeedBar.TabIndex = 26;
            this.hTooltip.SetToolTip(this.SpeedBar, "Speed Bar, Scroll to change speed");
            this.SpeedBar.Value = 100;
            this.SpeedBar.ValueChanged += new System.EventHandler(this.SpeedBar_ValueChanged);
            // 
            // btPath
            // 
            this.btPath.BackColor = System.Drawing.Color.White;
            this.btPath.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.btPath.Image = ((System.Drawing.Image)(resources.GetObject("btPath.Image")));
            this.btPath.Location = new System.Drawing.Point(314, 2);
            this.btPath.Name = "btPath";
            this.btPath.Size = new System.Drawing.Size(26, 26);
            this.btPath.TabIndex = 76;
            this.hTooltip.SetToolTip(this.btPath, "Path");
            this.btPath.UseVisualStyleBackColor = false;
            this.btPath.MouseDown += new System.Windows.Forms.MouseEventHandler(this.btPath_MouseDown);
            // 
            // btTrace
            // 
            this.btTrace.BackColor = System.Drawing.Color.White;
            this.btTrace.Image = ((System.Drawing.Image)(resources.GetObject("btTrace.Image")));
            this.btTrace.Location = new System.Drawing.Point(287, 2);
            this.btTrace.Name = "btTrace";
            this.btTrace.Size = new System.Drawing.Size(26, 26);
            this.btTrace.TabIndex = 75;
            this.hTooltip.SetToolTip(this.btTrace, "Trace");
            this.btTrace.UseVisualStyleBackColor = false;
            this.btTrace.MouseDown += new System.Windows.Forms.MouseEventHandler(this.btTrace_MouseDown);
            // 
            // btStep
            // 
            this.btStep.BackColor = System.Drawing.Color.White;
            this.btStep.Image = ((System.Drawing.Image)(resources.GetObject("btStep.Image")));
            this.btStep.Location = new System.Drawing.Point(255, 2);
            this.btStep.Name = "btStep";
            this.btStep.Size = new System.Drawing.Size(26, 26);
            this.btStep.TabIndex = 74;
            this.hTooltip.SetToolTip(this.btStep, "Step");
            this.btStep.UseVisualStyleBackColor = false;
            this.btStep.Click += new System.EventHandler(this.btStep_Click);
            // 
            // btGoPause
            // 
            this.btGoPause.BackColor = System.Drawing.Color.White;
            this.btGoPause.Image = ((System.Drawing.Image)(resources.GetObject("btGoPause.Image")));
            this.btGoPause.Location = new System.Drawing.Point(228, 2);
            this.btGoPause.Name = "btGoPause";
            this.btGoPause.Size = new System.Drawing.Size(26, 26);
            this.btGoPause.TabIndex = 73;
            this.hTooltip.SetToolTip(this.btGoPause, "Go");
            this.btGoPause.UseVisualStyleBackColor = false;
            this.btGoPause.Click += new System.EventHandler(this.btGoPause_Click);
            // 
            // btStop
            // 
            this.btStop.BackColor = System.Drawing.Color.White;
            this.btStop.Image = ((System.Drawing.Image)(resources.GetObject("btStop.Image")));
            this.btStop.Location = new System.Drawing.Point(201, 2);
            this.btStop.Name = "btStop";
            this.btStop.Size = new System.Drawing.Size(26, 26);
            this.btStop.TabIndex = 72;
            this.hTooltip.SetToolTip(this.btStop, "Stop");
            this.btStop.UseVisualStyleBackColor = false;
            this.btStop.Click += new System.EventHandler(this.btStop_Click);
            // 
            // btPaste
            // 
            this.btPaste.BackColor = System.Drawing.Color.White;
            this.btPaste.Image = ((System.Drawing.Image)(resources.GetObject("btPaste.Image")));
            this.btPaste.Location = new System.Drawing.Point(142, 2);
            this.btPaste.Name = "btPaste";
            this.btPaste.Size = new System.Drawing.Size(26, 26);
            this.btPaste.TabIndex = 70;
            this.hTooltip.SetToolTip(this.btPaste, "Paste");
            this.btPaste.UseVisualStyleBackColor = false;
            this.btPaste.Click += new System.EventHandler(this.btPaste_Click);
            // 
            // btCut
            // 
            this.btCut.BackColor = System.Drawing.Color.White;
            this.btCut.Image = ((System.Drawing.Image)(resources.GetObject("btCut.Image")));
            this.btCut.Location = new System.Drawing.Point(115, 2);
            this.btCut.Name = "btCut";
            this.btCut.Size = new System.Drawing.Size(26, 26);
            this.btCut.TabIndex = 69;
            this.hTooltip.SetToolTip(this.btCut, "Cut");
            this.btCut.UseVisualStyleBackColor = false;
            this.btCut.Click += new System.EventHandler(this.btCut_Click);
            // 
            // btCopy
            // 
            this.btCopy.BackColor = System.Drawing.Color.White;
            this.btCopy.Image = ((System.Drawing.Image)(resources.GetObject("btCopy.Image")));
            this.btCopy.Location = new System.Drawing.Point(88, 2);
            this.btCopy.Name = "btCopy";
            this.btCopy.Size = new System.Drawing.Size(26, 26);
            this.btCopy.TabIndex = 68;
            this.hTooltip.SetToolTip(this.btCopy, "Copy");
            this.btCopy.UseVisualStyleBackColor = false;
            this.btCopy.Click += new System.EventHandler(this.btCopy_Click);
            // 
            // btRight
            // 
            this.btRight.BackColor = System.Drawing.Color.White;
            this.btRight.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.btRight.Image = ((System.Drawing.Image)(resources.GetObject("btRight.Image")));
            this.btRight.Location = new System.Drawing.Point(56, 2);
            this.btRight.Name = "btRight";
            this.btRight.Size = new System.Drawing.Size(26, 26);
            this.btRight.TabIndex = 67;
            this.hTooltip.SetToolTip(this.btRight, "Right");
            this.btRight.UseVisualStyleBackColor = false;
            this.btRight.Click += new System.EventHandler(this.btRight_Click);
            // 
            // btStraight
            // 
            this.btStraight.BackColor = System.Drawing.Color.White;
            this.btStraight.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.btStraight.Image = ((System.Drawing.Image)(resources.GetObject("btStraight.Image")));
            this.btStraight.Location = new System.Drawing.Point(29, 2);
            this.btStraight.Name = "btStraight";
            this.btStraight.Size = new System.Drawing.Size(26, 26);
            this.btStraight.TabIndex = 66;
            this.btStraight.TextAlign = System.Drawing.ContentAlignment.BottomCenter;
            this.hTooltip.SetToolTip(this.btStraight, "Straight");
            this.btStraight.UseVisualStyleBackColor = false;
            this.btStraight.Click += new System.EventHandler(this.btStraight_Click);
            // 
            // btLeft
            // 
            this.btLeft.BackColor = System.Drawing.Color.White;
            this.btLeft.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.btLeft.Image = ((System.Drawing.Image)(resources.GetObject("btLeft.Image")));
            this.btLeft.Location = new System.Drawing.Point(3, 2);
            this.btLeft.Name = "btLeft";
            this.btLeft.Size = new System.Drawing.Size(26, 26);
            this.btLeft.TabIndex = 65;
            this.hTooltip.SetToolTip(this.btLeft, "Left");
            this.btLeft.UseVisualStyleBackColor = false;
            this.btLeft.Click += new System.EventHandler(this.btLeft_Click);
            // 
            // btRestore
            // 
            this.btRestore.BackColor = System.Drawing.Color.White;
            this.btRestore.Image = ((System.Drawing.Image)(resources.GetObject("btRestore.Image")));
            this.btRestore.Location = new System.Drawing.Point(169, 2);
            this.btRestore.Name = "btRestore";
            this.btRestore.Size = new System.Drawing.Size(26, 26);
            this.btRestore.TabIndex = 77;
            this.hTooltip.SetToolTip(this.btRestore, "Restore Best Solution");
            this.btRestore.UseVisualStyleBackColor = false;
            this.btRestore.Click += new System.EventHandler(this.btRestore_Click);
            // 
            // btnPrevUnsolved
            // 
            this.btnPrevUnsolved.BackColor = System.Drawing.Color.White;
            this.btnPrevUnsolved.Image = ((System.Drawing.Image)(resources.GetObject("btnPrevUnsolved.Image")));
            this.btnPrevUnsolved.Location = new System.Drawing.Point(346, 2);
            this.btnPrevUnsolved.Name = "btnPrevUnsolved";
            this.btnPrevUnsolved.Size = new System.Drawing.Size(26, 26);
            this.btnPrevUnsolved.TabIndex = 78;
            this.hTooltip.SetToolTip(this.btnPrevUnsolved, "Previous Unsolved Level");
            this.btnPrevUnsolved.UseVisualStyleBackColor = false;
            this.btnPrevUnsolved.Click += new System.EventHandler(this.btnPrevUnsolved_Click);
            // 
            // btnNextUnsolved
            // 
            this.btnNextUnsolved.BackColor = System.Drawing.Color.White;
            this.btnNextUnsolved.Image = ((System.Drawing.Image)(resources.GetObject("btnNextUnsolved.Image")));
            this.btnNextUnsolved.Location = new System.Drawing.Point(373, 2);
            this.btnNextUnsolved.Name = "btnNextUnsolved";
            this.btnNextUnsolved.Size = new System.Drawing.Size(26, 26);
            this.btnNextUnsolved.TabIndex = 79;
            this.hTooltip.SetToolTip(this.btnNextUnsolved, "Next Unsolved Level");
            this.btnNextUnsolved.UseVisualStyleBackColor = false;
            this.btnNextUnsolved.Click += new System.EventHandler(this.btnNextUnsolved_Click);
            // 
            // mnuMainFile
            // 
            this.mnuMainFile.Enabled = false;
            this.mnuMainFile.Index = 0;
            this.mnuMainFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuUploadSolutions,
            this.menuSwitchContest,
            this.mnuExit});
            this.mnuMainFile.Text = "&File";
            // 
            // mnuUploadSolutions
            // 
            this.mnuUploadSolutions.Index = 0;
            this.mnuUploadSolutions.Text = "&Upload Solutions";
            this.mnuUploadSolutions.Click += new System.EventHandler(this.mnuUploadSolutions_Click);
            // 
            // menuSwitchContest
            // 
            this.menuSwitchContest.Index = 1;
            this.menuSwitchContest.Text = "S&witch Contest";
            this.menuSwitchContest.Click += new System.EventHandler(this.menuSwitchContest_Click);
            // 
            // mnuExit
            // 
            this.mnuExit.Index = 2;
            this.mnuExit.Text = "E&xit";
            this.mnuExit.Click += new System.EventHandler(this.ExitMenu_Click);
            // 
            // mnuMainEdit
            // 
            this.mnuMainEdit.Enabled = false;
            this.mnuMainEdit.Index = 1;
            this.mnuMainEdit.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuTxtUndo,
            this.mnuSeparator1Edit,
            this.mnuTxtCut,
            this.mnuTxtCopy,
            this.mnuTxtPaste,
            this.mnuTxtClear,
            this.mnuSeperator2Edit,
            this.mnuRestoreBest});
            this.mnuMainEdit.Text = "&Edit";
            // 
            // mnuTxtUndo
            // 
            this.mnuTxtUndo.Index = 0;
            this.mnuTxtUndo.Shortcut = System.Windows.Forms.Shortcut.CtrlZ;
            this.mnuTxtUndo.Text = "&Undo";
            this.mnuTxtUndo.Click += new System.EventHandler(this.TxtUndo_Click);
            // 
            // mnuSeparator1Edit
            // 
            this.mnuSeparator1Edit.Index = 1;
            this.mnuSeparator1Edit.Text = "-";
            // 
            // mnuTxtCut
            // 
            this.mnuTxtCut.Index = 2;
            this.mnuTxtCut.Shortcut = System.Windows.Forms.Shortcut.CtrlX;
            this.mnuTxtCut.Text = "Cu&t";
            this.mnuTxtCut.Click += new System.EventHandler(this.TxtCut_Click);
            // 
            // mnuTxtCopy
            // 
            this.mnuTxtCopy.Index = 3;
            this.mnuTxtCopy.Shortcut = System.Windows.Forms.Shortcut.CtrlC;
            this.mnuTxtCopy.Text = "&Copy";
            this.mnuTxtCopy.Click += new System.EventHandler(this.TxtCopy_Click);
            // 
            // mnuTxtPaste
            // 
            this.mnuTxtPaste.Index = 4;
            this.mnuTxtPaste.Shortcut = System.Windows.Forms.Shortcut.CtrlV;
            this.mnuTxtPaste.Text = "&Paste";
            this.mnuTxtPaste.Click += new System.EventHandler(this.TxtPaste_Click);
            // 
            // mnuTxtClear
            // 
            this.mnuTxtClear.Index = 5;
            this.mnuTxtClear.Shortcut = System.Windows.Forms.Shortcut.CtrlD;
            this.mnuTxtClear.Text = "&Delete";
            this.mnuTxtClear.Click += new System.EventHandler(this.TxtClear_Click);
            // 
            // mnuSeperator2Edit
            // 
            this.mnuSeperator2Edit.Index = 6;
            this.mnuSeperator2Edit.Text = "-";
            // 
            // mnuRestoreBest
            // 
            this.mnuRestoreBest.Index = 7;
            this.mnuRestoreBest.Shortcut = System.Windows.Forms.Shortcut.CtrlB;
            this.mnuRestoreBest.Text = "Restore &Best Solution";
            this.mnuRestoreBest.Click += new System.EventHandler(this.btRestore_Click);
            // 
            // HerbertMenu
            // 
            this.HerbertMenu.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuMainFile,
            this.mnuMainEdit,
            this.mnuMainOptions,
            this.mnuMainRun,
            this.mnuMainDesign,
            this.mnuMainHelp});
            // 
            // mnuMainOptions
            // 
            this.mnuMainOptions.Enabled = false;
            this.mnuMainOptions.Index = 2;
            this.mnuMainOptions.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuTrace,
            this.mnuPath,
            this.mnuToolBar,
            this.mnuSmoothScroll,
            this.mnuTimer});
            this.mnuMainOptions.Text = "&Options";
            // 
            // mnuTrace
            // 
            this.mnuTrace.Index = 0;
            this.mnuTrace.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftT;
            this.mnuTrace.Text = "&Trace";
            this.mnuTrace.Click += new System.EventHandler(this.TraceMenu_Click);
            // 
            // mnuPath
            // 
            this.mnuPath.Checked = true;
            this.mnuPath.Index = 1;
            this.mnuPath.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftP;
            this.mnuPath.Text = "&Path";
            this.mnuPath.Click += new System.EventHandler(this.PathMenu_Click);
            // 
            // mnuToolBar
            // 
            this.mnuToolBar.Checked = true;
            this.mnuToolBar.Index = 2;
            this.mnuToolBar.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftB;
            this.mnuToolBar.Text = "Tool&bar";
            this.mnuToolBar.Click += new System.EventHandler(this.mnuToolBar_Click);
            // 
            // mnuSmoothScroll
            // 
            this.mnuSmoothScroll.Checked = true;
            this.mnuSmoothScroll.Index = 3;
            this.mnuSmoothScroll.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftS;
            this.mnuSmoothScroll.Text = "&Smooth Scroll";
            this.mnuSmoothScroll.Click += new System.EventHandler(this.mnuSmoothScroll_Click);
            // 
            // mnuTimer
            // 
            this.mnuTimer.Checked = true;
            this.mnuTimer.Index = 4;
            this.mnuTimer.Shortcut = System.Windows.Forms.Shortcut.CtrlShiftC;
            this.mnuTimer.Text = "Timer";
            this.mnuTimer.Click += new System.EventHandler(this.mnuTimer_Click);
            // 
            // mnuMainRun
            // 
            this.mnuMainRun.Enabled = false;
            this.mnuMainRun.Index = 3;
            this.mnuMainRun.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuStepHrbt,
            this.mnuGoHrbt,
            this.mnuResumeHrtb,
            this.mnuSeparatorRun,
            this.mnuHaltHrbt,
            this.mnuResetHerbt});
            this.mnuMainRun.Text = "&Run";
            // 
            // mnuStepHrbt
            // 
            this.mnuStepHrbt.Index = 0;
            this.mnuStepHrbt.Shortcut = System.Windows.Forms.Shortcut.CtrlS;
            this.mnuStepHrbt.Text = "&Step";
            this.mnuStepHrbt.Click += new System.EventHandler(this.StepHrbt_Click);
            // 
            // mnuGoHrbt
            // 
            this.mnuGoHrbt.Index = 1;
            this.mnuGoHrbt.Shortcut = System.Windows.Forms.Shortcut.CtrlG;
            this.mnuGoHrbt.Text = "&Go";
            this.mnuGoHrbt.Click += new System.EventHandler(this.RunHerbtMenu_Click);
            // 
            // mnuResumeHrtb
            // 
            this.mnuResumeHrtb.Index = 2;
            this.mnuResumeHrtb.Shortcut = System.Windows.Forms.Shortcut.CtrlR;
            this.mnuResumeHrtb.Text = "&Resume";
            this.mnuResumeHrtb.Click += new System.EventHandler(this.ResumeHrtb_Click);
            // 
            // mnuSeparatorRun
            // 
            this.mnuSeparatorRun.Index = 3;
            this.mnuSeparatorRun.Text = "-";
            // 
            // mnuHaltHrbt
            // 
            this.mnuHaltHrbt.Index = 4;
            this.mnuHaltHrbt.Shortcut = System.Windows.Forms.Shortcut.CtrlL;
            this.mnuHaltHrbt.Text = "Ha&lt";
            this.mnuHaltHrbt.Click += new System.EventHandler(this.HaltHrbt_Click);
            // 
            // mnuResetHerbt
            // 
            this.mnuResetHerbt.Index = 5;
            this.mnuResetHerbt.Shortcut = System.Windows.Forms.Shortcut.CtrlT;
            this.mnuResetHerbt.Text = "Rese&t";
            this.mnuResetHerbt.Click += new System.EventHandler(this.ResetHerbtMenu_Click);
            // 
            // mnuMainDesign
            // 
            this.mnuMainDesign.Index = 4;
            this.mnuMainDesign.Text = "";
            // 
            // mnuMainHelp
            // 
            this.mnuMainHelp.Enabled = false;
            this.mnuMainHelp.Index = 5;
            this.mnuMainHelp.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.mnuAboutHerbert});
            this.mnuMainHelp.Text = "&Help";
            // 
            // mnuAboutHerbert
            // 
            this.mnuAboutHerbert.Index = 0;
            this.mnuAboutHerbert.Text = "&About Herbert";
            this.mnuAboutHerbert.Click += new System.EventHandler(this.mnuAboutHerbert_Click);
            // 
            // lblLineTracing
            // 
            this.lblLineTracing.AccessibleRole = System.Windows.Forms.AccessibleRole.Animation;
            this.lblLineTracing.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblLineTracing.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.lblLineTracing.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLineTracing.Location = new System.Drawing.Point(10, 211);
            this.lblLineTracing.Name = "lblLineTracing";
            this.lblLineTracing.Size = new System.Drawing.Size(248, 26);
            this.lblLineTracing.TabIndex = 23;
            // 
            // PanalTxtCodeEdit
            // 
            this.PanalTxtCodeEdit.AccessibleRole = System.Windows.Forms.AccessibleRole.Animation;
            this.PanalTxtCodeEdit.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.PanalTxtCodeEdit.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.PanalTxtCodeEdit.Location = new System.Drawing.Point(10, 28);
            this.PanalTxtCodeEdit.Name = "PanalTxtCodeEdit";
            this.PanalTxtCodeEdit.Size = new System.Drawing.Size(248, 184);
            this.PanalTxtCodeEdit.TabIndex = 24;
            this.PanalTxtCodeEdit.Paint += new System.Windows.Forms.PaintEventHandler(this.PanalTxtCodeEdit_Paint);
            this.PanalTxtCodeEdit.Click += new System.EventHandler(this.PanalTxtCodeEdit_Click);
            this.PanalTxtCodeEdit.MouseDown += new System.Windows.Forms.MouseEventHandler(this.PanalTxtCodeEdit_MouseDown);
            // 
            // lblMsgBox
            // 
            this.lblMsgBox.AccessibleRole = System.Windows.Forms.AccessibleRole.Animation;
            this.lblMsgBox.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblMsgBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.lblMsgBox.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblMsgBox.Location = new System.Drawing.Point(236, 268);
            this.lblMsgBox.Name = "lblMsgBox";
            this.lblMsgBox.Size = new System.Drawing.Size(316, 23);
            this.lblMsgBox.TabIndex = 27;
            this.lblMsgBox.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // lblLevelsTxt
            // 
            this.lblLevelsTxt.AutoSize = true;
            this.lblLevelsTxt.BackColor = System.Drawing.Color.Transparent;
            this.lblLevelsTxt.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLevelsTxt.Location = new System.Drawing.Point(463, 249);
            this.lblLevelsTxt.Name = "lblLevelsTxt";
            this.lblLevelsTxt.Size = new System.Drawing.Size(43, 13);
            this.lblLevelsTxt.TabIndex = 29;
            this.lblLevelsTxt.Text = "Levels";
            // 
            // lblScoreTxt
            // 
            this.lblScoreTxt.AutoSize = true;
            this.lblScoreTxt.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblScoreTxt.Location = new System.Drawing.Point(1, 249);
            this.lblScoreTxt.Name = "lblScoreTxt";
            this.lblScoreTxt.Size = new System.Drawing.Size(45, 13);
            this.lblScoreTxt.TabIndex = 30;
            this.lblScoreTxt.Text = "Score:";
            // 
            // lblTotalScore
            // 
            this.lblTotalScore.AutoSize = true;
            this.lblTotalScore.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTotalScore.Location = new System.Drawing.Point(40, 249);
            this.lblTotalScore.Name = "lblTotalScore";
            this.lblTotalScore.Size = new System.Drawing.Size(31, 13);
            this.lblTotalScore.TabIndex = 31;
            this.lblTotalScore.Text = "0/0";
            // 
            // picBFastHrbt
            // 
            this.picBFastHrbt.BackColor = System.Drawing.Color.Transparent;
            this.picBFastHrbt.Image = ((System.Drawing.Image)(resources.GetObject("picBFastHrbt.Image")));
            this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
            this.picBFastHrbt.Name = "picBFastHrbt";
            this.picBFastHrbt.Size = new System.Drawing.Size(12, 16);
            this.picBFastHrbt.TabIndex = 32;
            this.picBFastHrbt.TabStop = false;
            // 
            // picBSlowHrbt
            // 
            this.picBSlowHrbt.Image = ((System.Drawing.Image)(resources.GetObject("picBSlowHrbt.Image")));
            this.picBSlowHrbt.Location = new System.Drawing.Point(223, 251);
            this.picBSlowHrbt.Name = "picBSlowHrbt";
            this.picBSlowHrbt.Size = new System.Drawing.Size(12, 10);
            this.picBSlowHrbt.TabIndex = 33;
            this.picBSlowHrbt.TabStop = false;
            // 
            // lblTotalLevels
            // 
            this.lblTotalLevels.AutoSize = true;
            this.lblTotalLevels.BackColor = System.Drawing.Color.Transparent;
            this.lblTotalLevels.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTotalLevels.Location = new System.Drawing.Point(437, 249);
            this.lblTotalLevels.Name = "lblTotalLevels";
            this.lblTotalLevels.Size = new System.Drawing.Size(31, 13);
            this.lblTotalLevels.TabIndex = 37;
            this.lblTotalLevels.Text = "999";
            // 
            // lblTraceFirst
            // 
            this.lblTraceFirst.AutoSize = true;
            this.lblTraceFirst.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTraceFirst.Location = new System.Drawing.Point(11, 214);
            this.lblTraceFirst.Name = "lblTraceFirst";
            this.lblTraceFirst.Size = new System.Drawing.Size(0, 13);
            this.lblTraceFirst.TabIndex = 38;
            // 
            // lblBlack
            // 
            this.lblBlack.AutoSize = true;
            this.lblBlack.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.lblBlack.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblBlack.Location = new System.Drawing.Point(112, 214);
            this.lblBlack.Name = "lblBlack";
            this.lblBlack.Size = new System.Drawing.Size(13, 15);
            this.lblBlack.TabIndex = 39;
            this.lblBlack.Text = " ";
            // 
            // lblTraceSecond
            // 
            this.lblTraceSecond.AutoSize = true;
            this.lblTraceSecond.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTraceSecond.Location = new System.Drawing.Point(240, 214);
            this.lblTraceSecond.Name = "lblTraceSecond";
            this.lblTraceSecond.Size = new System.Drawing.Size(0, 13);
            this.lblTraceSecond.TabIndex = 40;
            // 
            // lbl2
            // 
            this.lbl2.AutoSize = true;
            this.lbl2.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lbl2.ForeColor = System.Drawing.SystemColors.ActiveBorder;
            this.lbl2.Location = new System.Drawing.Point(0, 1700);
            this.lbl2.Name = "lbl2";
            this.lbl2.Size = new System.Drawing.Size(0, 13);
            this.lbl2.TabIndex = 41;
            // 
            // lblLT
            // 
            this.lblLT.AutoSize = true;
            this.lblLT.BackColor = System.Drawing.SystemColors.Control;
            this.lblLT.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLT.ForeColor = System.Drawing.SystemColors.Control;
            this.lblLT.Location = new System.Drawing.Point(24, 1700);
            this.lblLT.Name = "lblLT";
            this.lblLT.Size = new System.Drawing.Size(0, 13);
            this.lblLT.TabIndex = 42;
            // 
            // pbHrbtStanding
            // 
            this.pbHrbtStanding.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtStanding.Image")));
            this.pbHrbtStanding.Location = new System.Drawing.Point(392, 456);
            this.pbHrbtStanding.Name = "pbHrbtStanding";
            this.pbHrbtStanding.Size = new System.Drawing.Size(11, 11);
            this.pbHrbtStanding.TabIndex = 44;
            this.pbHrbtStanding.TabStop = false;
            this.pbHrbtStanding.Visible = false;
            // 
            // pbHrbtLeftLeg
            // 
            this.pbHrbtLeftLeg.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtLeftLeg.Image")));
            this.pbHrbtLeftLeg.Location = new System.Drawing.Point(440, 408);
            this.pbHrbtLeftLeg.Name = "pbHrbtLeftLeg";
            this.pbHrbtLeftLeg.Size = new System.Drawing.Size(11, 11);
            this.pbHrbtLeftLeg.TabIndex = 45;
            this.pbHrbtLeftLeg.TabStop = false;
            this.pbHrbtLeftLeg.Visible = false;
            // 
            // pbHrbtRightLeg
            // 
            this.pbHrbtRightLeg.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtRightLeg.Image")));
            this.pbHrbtRightLeg.Location = new System.Drawing.Point(640, 440);
            this.pbHrbtRightLeg.Name = "pbHrbtRightLeg";
            this.pbHrbtRightLeg.Size = new System.Drawing.Size(11, 11);
            this.pbHrbtRightLeg.TabIndex = 46;
            this.pbHrbtRightLeg.TabStop = false;
            this.pbHrbtRightLeg.Visible = false;
            // 
            // Herbert45
            // 
            this.Herbert45.Image = ((System.Drawing.Image)(resources.GetObject("Herbert45.Image")));
            this.Herbert45.Location = new System.Drawing.Point(480, 424);
            this.Herbert45.Name = "Herbert45";
            this.Herbert45.Size = new System.Drawing.Size(14, 12);
            this.Herbert45.TabIndex = 47;
            this.Herbert45.TabStop = false;
            this.Herbert45.Visible = false;
            // 
            // Herbert_45
            // 
            this.Herbert_45.Image = ((System.Drawing.Image)(resources.GetObject("Herbert_45.Image")));
            this.Herbert_45.Location = new System.Drawing.Point(560, 480);
            this.Herbert_45.Name = "Herbert_45";
            this.Herbert_45.Size = new System.Drawing.Size(14, 13);
            this.Herbert_45.TabIndex = 48;
            this.Herbert_45.TabStop = false;
            this.Herbert_45.Visible = false;
            // 
            // StandingEyeClosed
            // 
            this.StandingEyeClosed.Image = ((System.Drawing.Image)(resources.GetObject("StandingEyeClosed.Image")));
            this.StandingEyeClosed.Location = new System.Drawing.Point(616, 472);
            this.StandingEyeClosed.Name = "StandingEyeClosed";
            this.StandingEyeClosed.Size = new System.Drawing.Size(11, 11);
            this.StandingEyeClosed.TabIndex = 49;
            this.StandingEyeClosed.TabStop = false;
            this.StandingEyeClosed.Visible = false;
            // 
            // lblSpeedTxt
            // 
            this.lblSpeedTxt.AutoSize = true;
            this.lblSpeedTxt.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblSpeedTxt.Location = new System.Drawing.Point(176, 249);
            this.lblSpeedTxt.Name = "lblSpeedTxt";
            this.lblSpeedTxt.Size = new System.Drawing.Size(48, 13);
            this.lblSpeedTxt.TabIndex = 50;
            this.lblSpeedTxt.Text = "Speed:";
            // 
            // LevelTimer
            // 
            this.LevelTimer.Interval = 1000;
            this.LevelTimer.Tick += new System.EventHandler(this.LevelTimer_Tick);
            // 
            // pnlContainer
            // 
            this.pnlContainer.BackColor = System.Drawing.Color.White;
            this.pnlContainer.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.pnlContainer.Controls.Add(this.lblTimeLeft);
            this.pnlContainer.Controls.Add(this.lblTimer);
            this.pnlContainer.Controls.Add(this.lblTotalScore);
            this.pnlContainer.Controls.Add(this.lblTotalLevels);
            this.pnlContainer.Controls.Add(this.lblScoreTxt);
            this.pnlContainer.Controls.Add(this.lblMsgBox);
            this.pnlContainer.Controls.Add(this.lblSpeedTxt);
            this.pnlContainer.Controls.Add(this.lblLevelsTxt);
            this.pnlContainer.Controls.Add(this.lblTraceSecond);
            this.pnlContainer.Controls.Add(this.lblBlack);
            this.pnlContainer.Controls.Add(this.lblTraceFirst);
            this.pnlContainer.Controls.Add(this.picBSlowHrbt);
            this.pnlContainer.Controls.Add(this.SpeedBar);
            this.pnlContainer.Controls.Add(this.LevelChangeBar);
            this.pnlContainer.Controls.Add(this.lblLineTracing);
            this.pnlContainer.Controls.Add(this.HerbertBoard);
            this.pnlContainer.Controls.Add(this.txtCodeEditor);
            this.pnlContainer.Controls.Add(this.PanalTxtCodeEdit);
            this.pnlContainer.Controls.Add(this.pnlMain);
            this.pnlContainer.Controls.Add(this.picBFastHrbt);
            this.pnlContainer.Location = new System.Drawing.Point(0, 31);
            this.pnlContainer.Name = "pnlContainer";
            this.pnlContainer.Size = new System.Drawing.Size(505, 296);
            this.pnlContainer.TabIndex = 60;
            this.pnlContainer.Paint += new System.Windows.Forms.PaintEventHandler(this.pnlContainer_Paint);
            // 
            // lblTimeLeft
            // 
            this.lblTimeLeft.AutoSize = true;
            this.lblTimeLeft.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTimeLeft.Location = new System.Drawing.Point(363, 273);
            this.lblTimeLeft.Name = "lblTimeLeft";
            this.lblTimeLeft.Size = new System.Drawing.Size(86, 13);
            this.lblTimeLeft.TabIndex = 52;
            this.lblTimeLeft.Text = "0d 0h 0m 0s";
            // 
            // lblTimer
            // 
            this.lblTimer.AutoSize = true;
            this.lblTimer.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.lblTimer.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTimer.Location = new System.Drawing.Point(328, 273);
            this.lblTimer.Name = "lblTimer";
            this.lblTimer.Size = new System.Drawing.Size(40, 13);
            this.lblTimer.TabIndex = 51;
            this.lblTimer.Text = "Time:";
            // 
            // HerbertBoard
            // 
            this.HerbertBoard.BackColor = System.Drawing.Color.White;
            this.HerbertBoard.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.HerbertBoard.Location = new System.Drawing.Point(260, 28);
            this.HerbertBoard.Name = "HerbertBoard";
            this.HerbertBoard.Size = new System.Drawing.Size(208, 208);
            this.HerbertBoard.TabIndex = 20;
            this.HerbertBoard.Paint += new System.Windows.Forms.PaintEventHandler(this.HerbertBoard_Paint);
            this.HerbertBoard.MouseDown += new System.Windows.Forms.MouseEventHandler(this.HerbertBoard_MouseDown);
            // 
            // pnlMain
            // 
            this.pnlMain.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.pnlMain.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.pnlMain.Controls.Add(this.lblTxtBytes);
            this.pnlMain.Controls.Add(this.lblMaxChars);
            this.pnlMain.Controls.Add(this.lblLevelSolved);
            this.pnlMain.Controls.Add(this.lblLevelTxt);
            this.pnlMain.Controls.Add(this.lblScorePerDot);
            this.pnlMain.Controls.Add(this.lblScoreCurrent);
            this.pnlMain.Controls.Add(this.lblPointTxt);
            this.pnlMain.Controls.Add(this.lblLevelNo);
            this.pnlMain.Controls.Add(this.lblBytesUsed);
            this.pnlMain.Location = new System.Drawing.Point(7, 7);
            this.pnlMain.Name = "pnlMain";
            this.pnlMain.Size = new System.Drawing.Size(464, 233);
            this.pnlMain.TabIndex = 28;
            this.pnlMain.Paint += new System.Windows.Forms.PaintEventHandler(this.pnlMain_Paint);
            // 
            // lblTxtBytes
            // 
            this.lblTxtBytes.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblTxtBytes.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblTxtBytes.Location = new System.Drawing.Point(203, 5);
            this.lblTxtBytes.Name = "lblTxtBytes";
            this.lblTxtBytes.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.lblTxtBytes.Size = new System.Drawing.Size(42, 17);
            this.lblTxtBytes.TabIndex = 14;
            this.lblTxtBytes.Text = "Bytes:";
            // 
            // lblMaxChars
            // 
            this.lblMaxChars.AutoSize = true;
            this.lblMaxChars.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblMaxChars.Location = new System.Drawing.Point(272, 5);
            this.lblMaxChars.Name = "lblMaxChars";
            this.lblMaxChars.Size = new System.Drawing.Size(51, 13);
            this.lblMaxChars.TabIndex = 11;
            this.lblMaxChars.Text = "(Max 0)";
            // 
            // lblLevelSolved
            // 
            this.lblLevelSolved.AutoSize = true;
            this.lblLevelSolved.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLevelSolved.Location = new System.Drawing.Point(396, 5);
            this.lblLevelSolved.Name = "lblLevelSolved";
            this.lblLevelSolved.Size = new System.Drawing.Size(69, 13);
            this.lblLevelSolved.TabIndex = 13;
            this.lblLevelSolved.Text = "(Unsolved)";
            // 
            // lblLevelTxt
            // 
            this.lblLevelTxt.AutoSize = true;
            this.lblLevelTxt.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLevelTxt.Location = new System.Drawing.Point(334, 5);
            this.lblLevelTxt.Name = "lblLevelTxt";
            this.lblLevelTxt.Size = new System.Drawing.Size(37, 13);
            this.lblLevelTxt.TabIndex = 12;
            this.lblLevelTxt.Text = "Level";
            // 
            // lblScorePerDot
            // 
            this.lblScorePerDot.AutoSize = true;
            this.lblScorePerDot.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblScorePerDot.Location = new System.Drawing.Point(130, 5);
            this.lblScorePerDot.Name = "lblScorePerDot";
            this.lblScorePerDot.Size = new System.Drawing.Size(51, 13);
            this.lblScorePerDot.TabIndex = 10;
            this.lblScorePerDot.Text = "(0 now)";
            // 
            // lblScoreCurrent
            // 
            this.lblScoreCurrent.AutoSize = true;
            this.lblScoreCurrent.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblScoreCurrent.Location = new System.Drawing.Point(41, 5);
            this.lblScoreCurrent.Name = "lblScoreCurrent";
            this.lblScoreCurrent.Size = new System.Drawing.Size(31, 13);
            this.lblScoreCurrent.TabIndex = 9;
            this.lblScoreCurrent.Text = "0/0";
            // 
            // lblPointTxt
            // 
            this.lblPointTxt.AutoSize = true;
            this.lblPointTxt.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblPointTxt.Location = new System.Drawing.Point(1, 5);
            this.lblPointTxt.Name = "lblPointTxt";
            this.lblPointTxt.Size = new System.Drawing.Size(46, 13);
            this.lblPointTxt.TabIndex = 0;
            this.lblPointTxt.Text = "Points:";
            // 
            // lblLevelNo
            // 
            this.lblLevelNo.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLevelNo.Location = new System.Drawing.Point(368, 5);
            this.lblLevelNo.Name = "lblLevelNo";
            this.lblLevelNo.Size = new System.Drawing.Size(30, 17);
            this.lblLevelNo.TabIndex = 1;
            this.lblLevelNo.Text = "0";
            // 
            // lblBytesUsed
            // 
            this.lblBytesUsed.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblBytesUsed.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblBytesUsed.Location = new System.Drawing.Point(243, 5);
            this.lblBytesUsed.Name = "lblBytesUsed";
            this.lblBytesUsed.RightToLeft = System.Windows.Forms.RightToLeft.No;
            this.lblBytesUsed.Size = new System.Drawing.Size(32, 17);
            this.lblBytesUsed.TabIndex = 8;
            this.lblBytesUsed.Text = "0";
            // 
            // pnlToolBar
            // 
            this.pnlToolBar.BackColor = System.Drawing.SystemColors.Control;
            this.pnlToolBar.Controls.Add(this.btRestore);
            this.pnlToolBar.Controls.Add(this.btnNextUnsolved);
            this.pnlToolBar.Controls.Add(this.btnPrevUnsolved);
            this.pnlToolBar.Controls.Add(this.btPath);
            this.pnlToolBar.Controls.Add(this.btTrace);
            this.pnlToolBar.Controls.Add(this.btStep);
            this.pnlToolBar.Controls.Add(this.btGoPause);
            this.pnlToolBar.Controls.Add(this.btStop);
            this.pnlToolBar.Controls.Add(this.btPaste);
            this.pnlToolBar.Controls.Add(this.btCut);
            this.pnlToolBar.Controls.Add(this.btCopy);
            this.pnlToolBar.Controls.Add(this.btRight);
            this.pnlToolBar.Controls.Add(this.btStraight);
            this.pnlToolBar.Controls.Add(this.btLeft);
            this.pnlToolBar.Enabled = false;
            this.pnlToolBar.Location = new System.Drawing.Point(0, 0);
            this.pnlToolBar.Name = "pnlToolBar";
            this.pnlToolBar.Size = new System.Drawing.Size(407, 30);
            this.pnlToolBar.TabIndex = 61;
            this.pnlToolBar.Visible = false;
            // 
            // StandingEyeClosedZOOMIN
            // 
            this.StandingEyeClosedZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("StandingEyeClosedZOOMIN.Image")));
            this.StandingEyeClosedZOOMIN.Location = new System.Drawing.Point(328, 464);
            this.StandingEyeClosedZOOMIN.Name = "StandingEyeClosedZOOMIN";
            this.StandingEyeClosedZOOMIN.Size = new System.Drawing.Size(24, 24);
            this.StandingEyeClosedZOOMIN.TabIndex = 67;
            this.StandingEyeClosedZOOMIN.TabStop = false;
            this.StandingEyeClosedZOOMIN.Visible = false;
            // 
            // Herbert_45ZOOMIN
            // 
            this.Herbert_45ZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("Herbert_45ZOOMIN.Image")));
            this.Herbert_45ZOOMIN.Location = new System.Drawing.Point(272, 472);
            this.Herbert_45ZOOMIN.Name = "Herbert_45ZOOMIN";
            this.Herbert_45ZOOMIN.Size = new System.Drawing.Size(26, 24);
            this.Herbert_45ZOOMIN.TabIndex = 66;
            this.Herbert_45ZOOMIN.TabStop = false;
            this.Herbert_45ZOOMIN.Visible = false;
            // 
            // Herbert45ZOOMIN
            // 
            this.Herbert45ZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("Herbert45ZOOMIN.Image")));
            this.Herbert45ZOOMIN.Location = new System.Drawing.Point(192, 416);
            this.Herbert45ZOOMIN.Name = "Herbert45ZOOMIN";
            this.Herbert45ZOOMIN.Size = new System.Drawing.Size(32, 32);
            this.Herbert45ZOOMIN.TabIndex = 65;
            this.Herbert45ZOOMIN.TabStop = false;
            this.Herbert45ZOOMIN.Visible = false;
            // 
            // pbHrbtRightLegZOOMIN
            // 
            this.pbHrbtRightLegZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtRightLegZOOMIN.Image")));
            this.pbHrbtRightLegZOOMIN.Location = new System.Drawing.Point(352, 432);
            this.pbHrbtRightLegZOOMIN.Name = "pbHrbtRightLegZOOMIN";
            this.pbHrbtRightLegZOOMIN.Size = new System.Drawing.Size(32, 32);
            this.pbHrbtRightLegZOOMIN.TabIndex = 64;
            this.pbHrbtRightLegZOOMIN.TabStop = false;
            this.pbHrbtRightLegZOOMIN.Visible = false;
            // 
            // pbHrbtLeftLegZOOMIN
            // 
            this.pbHrbtLeftLegZOOMIN.Dock = System.Windows.Forms.DockStyle.Right;
            this.pbHrbtLeftLegZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtLeftLegZOOMIN.Image")));
            this.pbHrbtLeftLegZOOMIN.Location = new System.Drawing.Point(482, 0);
            this.pbHrbtLeftLegZOOMIN.Name = "pbHrbtLeftLegZOOMIN";
            this.pbHrbtLeftLegZOOMIN.Size = new System.Drawing.Size(22, 340);
            this.pbHrbtLeftLegZOOMIN.TabIndex = 63;
            this.pbHrbtLeftLegZOOMIN.TabStop = false;
            this.pbHrbtLeftLegZOOMIN.Visible = false;
            // 
            // pbHrbtStandingZOOMIN
            // 
            this.pbHrbtStandingZOOMIN.Image = ((System.Drawing.Image)(resources.GetObject("pbHrbtStandingZOOMIN.Image")));
            this.pbHrbtStandingZOOMIN.Location = new System.Drawing.Point(104, 448);
            this.pbHrbtStandingZOOMIN.Name = "pbHrbtStandingZOOMIN";
            this.pbHrbtStandingZOOMIN.Size = new System.Drawing.Size(24, 24);
            this.pbHrbtStandingZOOMIN.TabIndex = 62;
            this.pbHrbtStandingZOOMIN.TabStop = false;
            this.pbHrbtStandingZOOMIN.Visible = false;
            // 
            // lblClosing
            // 
            this.lblClosing.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblClosing.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.lblClosing.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblClosing.Location = new System.Drawing.Point(188, 208);
            this.lblClosing.Name = "lblClosing";
            this.lblClosing.Size = new System.Drawing.Size(132, 23);
            this.lblClosing.TabIndex = 68;
            this.lblClosing.Text = "Uploading solutions...";
            this.lblClosing.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            this.lblClosing.Visible = false;
            // 
            // lblLoading
            // 
            this.lblLoading.BackColor = System.Drawing.SystemColors.ControlLightLight;
            this.lblLoading.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.lblLoading.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lblLoading.Location = new System.Drawing.Point(191, 88);
            this.lblLoading.Name = "lblLoading";
            this.lblLoading.Size = new System.Drawing.Size(122, 20);
            this.lblLoading.TabIndex = 69;
            this.lblLoading.Text = "Loading data...";
            this.lblLoading.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
            this.lblLoading.Visible = false;
            // 
            // lbl3
            // 
            this.lbl3.AutoSize = true;
            this.lbl3.Font = new System.Drawing.Font("Verdana", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.lbl3.ForeColor = System.Drawing.SystemColors.ActiveBorder;
            this.lbl3.Location = new System.Drawing.Point(0, 1700);
            this.lbl3.Name = "lbl3";
            this.lbl3.Size = new System.Drawing.Size(0, 13);
            this.lbl3.TabIndex = 70;
            this.lbl3.Visible = false;
            // 
            // pbRun
            // 
            this.pbRun.Image = ((System.Drawing.Image)(resources.GetObject("pbRun.Image")));
            this.pbRun.Location = new System.Drawing.Point(424, 0);
            this.pbRun.Name = "pbRun";
            this.pbRun.Size = new System.Drawing.Size(25, 25);
            this.pbRun.TabIndex = 71;
            this.pbRun.TabStop = false;
            this.pbRun.Visible = false;
            // 
            // pbPause
            // 
            this.pbPause.Image = ((System.Drawing.Image)(resources.GetObject("pbPause.Image")));
            this.pbPause.Location = new System.Drawing.Point(448, 0);
            this.pbPause.Name = "pbPause";
            this.pbPause.Size = new System.Drawing.Size(25, 25);
            this.pbPause.TabIndex = 72;
            this.pbPause.TabStop = false;
            this.pbPause.Visible = false;
            // 
            // HerbertMain
            // 
            this.ClientSize = new System.Drawing.Size(504, 340);
            this.Controls.Add(this.lblClosing);
            this.Controls.Add(this.pbPause);
            this.Controls.Add(this.pbRun);
            this.Controls.Add(this.lblLoading);
            this.Controls.Add(this.pnlContainer);
            this.Controls.Add(this.StandingEyeClosedZOOMIN);
            this.Controls.Add(this.Herbert_45ZOOMIN);
            this.Controls.Add(this.Herbert45ZOOMIN);
            this.Controls.Add(this.pbHrbtRightLegZOOMIN);
            this.Controls.Add(this.pbHrbtLeftLegZOOMIN);
            this.Controls.Add(this.pbHrbtStandingZOOMIN);
            this.Controls.Add(this.pnlToolBar);
            this.Controls.Add(this.StandingEyeClosed);
            this.Controls.Add(this.Herbert_45);
            this.Controls.Add(this.Herbert45);
            this.Controls.Add(this.pbHrbtRightLeg);
            this.Controls.Add(this.pbHrbtLeftLeg);
            this.Controls.Add(this.pbHrbtStanding);
            this.Controls.Add(this.lblLT);
            this.Controls.Add(this.lbl2);
            this.Controls.Add(this.lbl3);
            this.Cursor = System.Windows.Forms.Cursors.Default;
            this.HelpButton = true;
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.Menu = this.HerbertMenu;
            this.Name = "HerbertMain";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Herbert ";
            this.Load += new System.EventHandler(this.HerbertMain_Load);
            this.Paint += new System.Windows.Forms.PaintEventHandler(this.HerbertMain_Paint);
            this.Closing += new System.ComponentModel.CancelEventHandler(this.HerbertMain_Closing);
            this.Resize += new System.EventHandler(this.HerbertMain_Resize);
            ((System.ComponentModel.ISupportInitialize)(this.picBFastHrbt)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.picBSlowHrbt)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtStanding)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtLeftLeg)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtRightLeg)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert45)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert_45)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.StandingEyeClosed)).EndInit();
            this.pnlContainer.ResumeLayout(false);
            this.pnlContainer.PerformLayout();
            this.pnlMain.ResumeLayout(false);
            this.pnlMain.PerformLayout();
            this.pnlToolBar.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.StandingEyeClosedZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert_45ZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.Herbert45ZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtRightLegZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtLeftLegZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbHrbtStandingZOOMIN)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbRun)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.pbPause)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }
        #endregion

        #region Properties
        /// <summary>
        /// property that set the command or herbert to command variable.
        /// and takes care of destination change
        /// it also takes care of rotation of herbert.
        /// </summary>
        public string Command
        {
            set
            {
#if (EXCEPTION)
                try
                {
#endif
                    //<10/03/05>
                    //					if(!progClosing)
                    //					{
                    //</10/03/05>
                    command = value;
                    ////Console.WriteLine(command);
                    //						if(!(command == "S" || command == "L" || command == "R" || command =="\n"))
                    //						{
                    //							DispMessage("Syntax Error");
                    //							//Vijay, check for return;
                    //						}
                    //checking if program is closed or end of program is reached
                    //then thread should not sleep.
                    if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                        Thread.Sleep(herbtSpeed);

                    if (command == "S")
                    {
#if(DESIGNER)
                        arrLevels[currentLevelIndex].NumHerbertActions++;
                        if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                            arrLevels[currentLevelIndex].NumHerbertActionsPersistent = arrLevels[currentLevelIndex].NumHerbertActions;
#endif
                        //this prePos$ is assigned the value of curPos$ so the when 
                        //herbert is halted it can be moved to the small dot just crossed
                        //by herbert.

                        arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].curPosX;
                        arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].curPosY;
                        arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].destPosX;
                        arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].destPosY;
                        ////Console.WriteLine("3 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);



                        if (arrLevels[currentLevelIndex].curPosX == arrLevels[currentLevelIndex].destPosX && arrLevels[currentLevelIndex].curPosY == arrLevels[currentLevelIndex].destPosY)
                            switch (arrLevels[currentLevelIndex].CurDir)
                            {
                                case 0:
                                    arrLevels[currentLevelIndex].destPosY -= HConstants.DOTSPACE;
                                    break;
                                case 1:
                                    arrLevels[currentLevelIndex].destPosX += HConstants.DOTSPACE;
                                    break;
                                case 2:
                                    arrLevels[currentLevelIndex].destPosY += HConstants.DOTSPACE;
                                    break;
                                case 3:
                                    arrLevels[currentLevelIndex].destPosX -= HConstants.DOTSPACE;
                                    break;
                            }
#if(CONTEST)
                        if (mnuPath.Checked && currentLevelIndex != 0)
                            arrLevels[currentLevelIndex].fSavePath(currentLevelIndex);
#endif
#if(PATTERN_GENERATER||DESIGNER)
                        //if(GlobalData.iPatternId!="-1")
                        arrLevels[currentLevelIndex].fSavePath(currentLevelIndex);
#endif
                        ////Console.WriteLine("4 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);
                    }
                    else if (command == "R")
                    {
#if(DESIGNER)
                        arrLevels[currentLevelIndex].NumHerbertActions++;
                        if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                            arrLevels[currentLevelIndex].NumHerbertActionsPersistent = arrLevels[currentLevelIndex].NumHerbertActions;
#endif
                        //blnRorLExecuting = true;
                        //herbertPicBox.Invalidate();
                        //this prePos$ is assigned the value of curPos$ so the when 
                        //herbert is halted it can be moved to the small dot just crossed
                        //by herbert.
                        ////Console.WriteLine("R1 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);
                        arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].curPosX;
                        arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].curPosY;
                        arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].destPosX;
                        arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].destPosY;
                        //						curPosX = prePosX;
                        //						curPosY = prePosY;
                        //rotating images by 90 degree.
                        //							if(!progClosing)
                        //							{	

                        //Added by Sujith/Vivek on 06/28/2005 for issue id: 1426
                        arrLevels[currentLevelIndex].PreDir = arrLevels[currentLevelIndex].CurDir;

                        arrLevels[currentLevelIndex].CurDir++;
                        if (arrLevels[currentLevelIndex].CurDir == 4)
                            arrLevels[currentLevelIndex].CurDir = 0;
                        try
                        {
                            //lock(arrHrbtImage[0])
                            {
                                arrHrbtImage[0].RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(arrHrbtImage[1])
                            {
                                arrHrbtImage[1].RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(arrHrbtImage[2])
                            {
                                arrHrbtImage[2].RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(img_45)
                            {
                                img_45.RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(img45)
                            {
                                img45.RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(imgEyeClose)
                            {
                                imgEyeClose.RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }


                        //HrbtHaltDir = CurDir;
                        //							}

                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        //check if herbert picture box has completed its rendering
                        //this block rotates herbert 45 degree and sleeps thread for some time.
                        if (hrbtRedrawn && !arrLevels[currentLevelIndex].stepByStep)
                        {
                            // set hrbtRedrawn to false so that currently executing 
                            //thread can't change the location of herbert picture box.
                            hrbtRedrawn = false;
#if (EXCEPTION)
                            try
                            {
#endif
                                //									if(!progClosing)
                                //									{
                                //lock(this.herbertPicBox)
                                {
#if (OLDCODE)
											this.herbertPicBox.Image = img_45;
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                    //lock(img_45)
                                    {


#if INVOKER
                                        if (herbtSpeed != 0)
                                            if (this.herbertPicBox.InvokeRequired)
                                            {
                                                if (herbtSpeed == 0)
                                                    lock (imgForPicBox)
                                                    {
                                                        imgForPicBox = img_45;
                                                    }
                                                else
                                                    imgForPicBox = img_45;
                                                this.herbertPicBox.Invoke(mi);
                                                /////Console.WriteLine("Invoking....");
                                            }
                                            else
                                            {
#endif
                                                this.herbertPicBox.Image = img_45;
                                                herbertPicBox.Invalidate();
#if INVOKER
                                            }

#endif
                                    }
                                    //Application.DoEvents();
#endif
                                }
                                //									}

                                //change the location of herbert picture box and 3 is used 
                                //because we can't specify the center point of a picture box
                                //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                // and (curPosX, curPosY) is center point where this picture 
                                //box should be displayed. rather is using standard error of 
                                //2 3 is used because is 45 degree and -45 degree images are 
                                //bigger than normal herbert images.
#if (EXCEPTION)
                                try
                                {
#endif
                                    //lock(this.herbertPicBox)
                                    {
                                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                        {
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 3 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 3 * GlobalData.ZoomInZoomOut - 1 + 2));
                                        }
                                        else
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 3), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 3));
                                        //herbertPicBox.Refresh();	
#if (OLDCODE)
											herbertPicBox.Invalidate();
#endif
                                    }

#if (EXCEPTION)
                                }
                                catch
                                {
                                    ////Console.WriteLine(e.Message + ", Command, 10");
                                }
#endif
                                //this code is introduced here because path was not drawing properly on turns.
                                if (PathOn)
                                {
                                    //check if herbert board has completed its rendering
                                    if (hrbtBoardRedrawn)//&& herbtSpeed>3)
                                    {
                                        arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                                        hrbtBoardRedrawn = false;
                                    }
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(e.Message + ", Command, 11");
                            }
#endif
                        }
                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        //if(!progClosing && !EndofProg)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        //check if herbert picture box has completed its rendering
                        //this code displays normal herbert 90 degree roteate so that it can 
                        //again come to normal position but 90 degree rotated.
                        if (hrbtRedrawn)
                        {
                            // set hrbtRedrawn to false so that currently executing 
                            //thread can't change the location of herbert picture box.
                            hrbtRedrawn = false;
#if (EXCEPTION)
                            try
                            {
#endif
                                //lock(this.herbertPicBox)
                                {
#if (OLDCODE)
										this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                    //lock(arrHrbtImage[stateArray[herbertState]])
                                    {
#if INVOKER

                                        if (this.herbertPicBox.InvokeRequired)
                                        {
                                            if (herbtSpeed == 0)
                                                lock (imgForPicBox)
                                                {
                                                    imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                                }
                                            else
                                                imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                            this.herbertPicBox.Invoke(mi);
                                            /////Console.WriteLine("Invoking....");
                                        }
                                        else
                                        {
#endif

                                            this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
                                            herbertPicBox.Invalidate();
#if INVOKER
                                        }

                                        //this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];

#endif
                                    }

                                    //Application.DoEvents();
#endif
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(exp1.Message + ", Command, 20");
                            }
                            try
                            {
#endif
                                //change the location of herbert picture box and 2 is used 
                                //because we can't specify the center point of a picture box
                                //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                // and (curPosX, curPosY) is center point where this picture 
                                //box should be displayed.
                                //lock(this.herbertPicBox)
                                {
                                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                        if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                                        {
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                                        }
                                        else
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                                    else
                                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                                    //herbertPicBox.Refresh();
#if (OLDCODE)
											herbertPicBox.Invalidate();
#endif
                                }

#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(e.Message + ", Command, 21");
                            }
#endif
                        }
                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        //if(!progClosing && !EndofProg)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        ////Console.WriteLine("R2 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);
                        //blnRorLExecuting = false;
                        sNeedChar = true;
                    }
                    else if (command == "L")
                    {
#if(DESIGNER)
                        arrLevels[currentLevelIndex].NumHerbertActions++;
                        if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                            arrLevels[currentLevelIndex].NumHerbertActionsPersistent = arrLevels[currentLevelIndex].NumHerbertActions;
#endif
                        //blnRorLExecuting = true;
                        //herbertPicBox.Invalidate();
                        //this prePos$ is assigned the value of curPos$ so the when 
                        //herbert is halted it can be moved to the small dot just crossed
                        //by herbert.							
                        //							prePosX = curPosX;
                        //							prePosY = curPosY;
                        //						curPosX = prePosX;
                        arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].curPosX;
                        arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].curPosY;
                        arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].destPosX;
                        arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].destPosY;
                        //						curPosY = prePosY;
                        //rotating images by 90 degree.		
                        //							if(!progClosing)
                        //							{		

                        //Added by Sujith/Vivek on 06/28/2005 for issue id: 1426
                        arrLevels[currentLevelIndex].PreDir = arrLevels[currentLevelIndex].CurDir;

                        arrLevels[currentLevelIndex].CurDir--;
                        if (arrLevels[currentLevelIndex].CurDir == -1)
                            arrLevels[currentLevelIndex].CurDir = 3;
                        try
                        {
                            //lock(arrHrbtImage[0])
                            {
                                arrHrbtImage[0].RotateFlip(RotateFlipType.Rotate270FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(arrHrbtImage[1])
                            {
                                arrHrbtImage[1].RotateFlip(RotateFlipType.Rotate270FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(arrHrbtImage[2])
                            {
                                arrHrbtImage[2].RotateFlip(RotateFlipType.Rotate270FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(imgEyeClose)
                            {
                                imgEyeClose.RotateFlip(RotateFlipType.Rotate270FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(img45)
                            {
                                img45.RotateFlip(RotateFlipType.Rotate270FlipNone);
                            }
                        }
                        catch
                        {
                        }
                        try
                        {
                            //lock(img_45)
                            {
                                img_45.RotateFlip(RotateFlipType.Rotate90FlipNone);
                            }
                        }
                        catch
                        {
                        }


                        //							}
                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        //if(!progClosing && !EndofProg)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        //Debug(herbertState.ToString());
                        //check if herbert picture box has completed its rendering
                        //this block rotates herbert 45 degree and sleeps thread for some time.
                        if (hrbtRedrawn && !arrLevels[currentLevelIndex].stepByStep)
                        {
                            //set hrbtRedrawn to false so that currently executing 
                            //thread can't change the location of herbert picture box.
                            hrbtRedrawn = false;
#if (EXCEPTION)
                            try
                            {
#endif
                                //									if(!progClosing)
                                //									{
                                //lock(this.herbertPicBox)
                                {
#if (OLDCODE)
										this.herbertPicBox.Image = img45;
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                    //lock(img45)
                                    {
#if (INVOKER)

                                        if (herbtSpeed != 0)
                                            if (this.herbertPicBox.InvokeRequired)
                                            {
                                                if (herbtSpeed == 0)
                                                    lock (imgForPicBox)
                                                    {
                                                        imgForPicBox = img45;
                                                    }
                                                else
                                                    imgForPicBox = img45;
                                                this.herbertPicBox.Invoke(mi);
                                                /////Console.WriteLine("Invoking....");
                                            }
                                            else
                                            {
#endif

                                                this.herbertPicBox.Image = img45;
                                                herbertPicBox.Invalidate();
#if (INVOKER)
                                            }

                                        //this.herbertPicBox.Image = img45;

#endif
                                    }
                                    //herbertPicBox.Invalidate();
                                    //Application.DoEvents();
#endif
                                }
                                //									}
                                //change the location of herbert picture box and 3 is used 
                                //because we can't specify the center point of a picture box
                                //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                // and (curPosX, curPosY) is center point where this picture 
                                //box should be displayed. rather is using standard error of 
                                //2 3 is used because is 45 degree and -45 degree images are 
                                //bigger than normal herbert images.
#if (EXCEPTION)
                                try
                                {
#endif
                                    //lock(this.herbertPicBox)
                                    {
                                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 3 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 3 * GlobalData.ZoomInZoomOut - 1 + 2));
                                        else
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 3 * GlobalData.ZoomInZoomOut), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 3));
                                        //herbertPicBox.Refresh();
#if (OLDCODE)
											herbertPicBox.Invalidate();
#endif
                                    }

                                    //herbertPicBox.Invalidate();
#if (EXCEPTION)
                                }
                                catch
                                {
                                    ////Console.WriteLine(exp1.Message + ", Command, 30");
                                }
#endif
                                //this code is introduced here because path was not drawing properly on turns.
                                if (PathOn)
                                {
                                    //check if herbert board has completed its rendering
                                    if (hrbtBoardRedrawn)// && herbtSpeed>3)
                                    {
                                        arrLevels[currentLevelIndex].drawPath((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut), (arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut));
                                        hrbtBoardRedrawn = false;
                                    }
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(e.Message + ", Command, 31");
                            }
#endif
                        }
                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        //if(!progClosing && !EndofProg)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        //ExecLbl.Text = new string(acCurrentLine);
                        //check if herbert picture box has completed its rendering
                        //this code displays normal herbert 270 degree roteate so that it can 
                        //again come to normal position but 270 degree rotated.
                        if (hrbtRedrawn)
                        {
                            // set hrbtRedrawn to false so that currently executing 
                            //thread can't change the location of herbert picture box.
                            hrbtRedrawn = false;
#if (EXCEPTION)
                            try
                            {
#endif
                                //lock(this.herbertPicBox)
                                {
#if (OLDCODE)
										this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                    //lock(arrHrbtImage[stateArray[herbertState]])
                                    {
#if (INVOKER)

                                        if (this.herbertPicBox.InvokeRequired)
                                        {
                                            if (herbtSpeed == 0)
                                                lock (imgForPicBox)
                                                {
                                                    imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                                }
                                            else
                                                imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                            this.herbertPicBox.Invoke(mi);
                                            /////Console.WriteLine("Invoking....");
                                        }
                                        else
                                        {
#endif
                                            this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
                                            herbertPicBox.Invalidate();
#if (INVOKER)
                                        }

                                        //this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];

#endif
                                    }
                                    //herbertPicBox.Invalidate();
                                    //Application.DoEvents();
#endif
                                }
                                //change the location of herbert picture box and 2 is used 
                                //because we can't specify the center point of a picture box
                                //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                // and (curPosX, curPosY) is center point where this picture 
                                //box should be displayed.
                                //lock(this.herbertPicBox)
                                {
                                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                        if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                                        {
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                                        }
                                        else
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                                    else
                                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                                    //herbertPicBox.Refresh();	
#if (OLDCODE)
											herbertPicBox.Invalidate();
#endif
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(e.Message + ", Command, 41");
                            }
#endif
                        }
                        //checking if program is closed or end of program is reached
                        //then thread should not sleep.
                        //if(!progClosing && !EndofProg)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        //blnRorLExecuting = false;
                        sNeedChar = true;
                    }
                    //}
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(fe.Message + ", Command, 51");
                }
#endif
            }
            get
            {
                return command;
            }
        }


        /// <summary>
        /// this property takes care of incremeanting and decrementing 
        /// herbert current position.
        /// </summary>
        public int setCurPos
        {
            set
            {
#if (EXCEPTION)
                try
                {
#endif

                    arrLevels[currentLevelIndex].CurDir = value;

                    // this changes the curPos$ by 2 every time.
                    switch (arrLevels[currentLevelIndex].CurDir)
                    {
                        //Up dir
                        case 0:
                            arrLevels[currentLevelIndex].curPosY -= 2;
                            break;
                        //Right dir
                        case 1:
                            arrLevels[currentLevelIndex].curPosX += 2;
                            break;
                        //Down Dir
                        case 2:
                            arrLevels[currentLevelIndex].curPosY += 2;
                            break;
                        //Left Dir
                        case 3:
                            arrLevels[currentLevelIndex].curPosX -= 2;
                            break;
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(fe.Message + ", setCurPos, 11");
                }
#endif
            }
        }


        #endregion

        #region Structures
        /// <summary>
        /// this structure contains information about the 
        /// programs each line like function name, number of 
        /// parameter, and starting point of this function defination.
        /// an array is created of this structure and 0th element is 
        /// used for storing the execution line in the code written in
        /// the code editor.
        /// </summary>
        /*struct AtLineInfoStruct	
        {
            public int		iStart;
            public char		cFunc; 
            public short	sNumParms; 
            public short	sFlags; 
            public char[,]	paramNames;
            //public AtLineInfoStruct(){}
            public int		iEndIndexLT;
            public int		iStartIndexLT;
            public int[]	frameCharNo;
        }*/

        /// <summary>
        /// this structure contains information about
        /// the currenlty executing line.
        /// </summary>
        //		struct tHStateStruct
        //		{
        //			public int 		iPC; /* Program counter */
        //			public int		iLine; /* Current executable line */
        //			public char		cCurrentOp; /* Current operator to be executed */
        //			public char		cRunState;
        //			public short	sFlags;			
        //		}

        /// <summary>
        /// this contains information of which is the currently executing 
        /// char.
        /// </summary>
        //		struct	tCurLineStruct	
        //		{
        //			public int iLineNum;
        //			public int iFirstCmd;
        //			public int iLength;
        //		} 

        #endregion

        #region Methods
#if(FT)
		private void ZoomInZoomOut()
		{
			//this.SuspendLayout();
			if(GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
			{	
				if(!progClosing)
				{
					killThread();
				}
				Font LargeBoldFont = new Font("Verdana", 10, FontStyle.Bold);
				Font LargeRegularFont = new Font("Verdana", 10, FontStyle.Regular);
				this.pnlContainer.Location = new System.Drawing.Point(this.Width/2-400, pnlContainer.Location.Y);
				this.pnlContainer.Width = 800;
				this.pnlContainer.Height = 520;
				herbertPicBox.Size = new Size(26,26);
				this.pnlMain.Size = new System.Drawing.Size(755, 441);
				
				lblPointTxt.Font = LargeRegularFont;
				this.lblPointTxt.Location = new System.Drawing.Point(1, 3);
				
				lblScoreCurrent.Font = LargeBoldFont;
				this.lblScoreCurrent.Location = new System.Drawing.Point(54, 3);

				this.lblScorePerDot.Font = LargeRegularFont;
				this.lblScorePerDot.Location = new System.Drawing.Point(116, 3);

				this.LevelChangeBar.Location = new System.Drawing.Point(772, 4);
				this.LevelChangeBar.Size = new System.Drawing.Size(18, 448);
				
				this.PanalTxtCodeEdit.Size = new System.Drawing.Size(329, 390);
				
				this.txtCodeEditor.Size = new System.Drawing.Size(327, 388);

				this.lblLineTracing.Location = new System.Drawing.Point(10, 417);			
				this.lblLineTracing.Size = new System.Drawing.Size(329, 27);

				this.HerbertBoard.Location = new System.Drawing.Point(342, 28);
				this.HerbertBoard.Size = new System.Drawing.Size(416, 416);

				this.SpeedBar.Location = new System.Drawing.Point(172, 456);
				this.SpeedBar.Size = new System.Drawing.Size(508, 16);
				
				this.lblMsgBox.Location = new System.Drawing.Point(5, 480);
				this.lblMsgBox.Size = new System.Drawing.Size(760, 23);
				this.lblMsgBox.Font = LargeRegularFont;
												
				this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
				this.picBFastHrbt.Size = new System.Drawing.Size(12, 16);

				this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);
				this.picBSlowHrbt.Size = new System.Drawing.Size(12, 10);

				this.lblTraceFirst.Location = new System.Drawing.Point(11, 420);
				this.lblTraceFirst.Size = new System.Drawing.Size(0, 17);

				this.lblBlack.Location = new System.Drawing.Point(112, 420);
				this.lblBlack.Size = new System.Drawing.Size(0, 20);

				this.lblTraceSecond.Location = new System.Drawing.Point(240, 420);
				this.lblTraceSecond.Size = new System.Drawing.Size(0, 17);

				this.TxtLevelPoints.Location = new System.Drawing.Point(27, 268);
				this.TxtLevelPoints.Font = LargeRegularFont;

				this.lblLevelPoints.Location = new System.Drawing.Point(5, 269);
				this.lblLevelPoints.Size = new System.Drawing.Size(22, 17);

				this.lblDifficultyMsg.Location = new System.Drawing.Point(8, 296);
				this.lblDifficultyMsg.Size = new System.Drawing.Size(112, 23);


				this.cbDifficultyBucket.Location = new System.Drawing.Point(120, 296);
				this.cbDifficultyBucket.Size = new System.Drawing.Size(48, 21);

				this.lblScoreTxt.Location = new System.Drawing.Point(1, 456);
				this.lblScoreTxt.Font = LargeRegularFont;

				this.lblTotalScore.Location = new System.Drawing.Point(50, 456);
				this.lblTotalScore.Font = LargeBoldFont;

				this.lblSpeedTxt.Location = new System.Drawing.Point(104, 456);
				this.lblSpeedTxt.Font = LargeRegularFont;

				this.picBSlowHrbt.Location = new System.Drawing.Point(159, 458);

				this.picBFastHrbt.Location = new System.Drawing.Point(681, 457);

				this.lblTotalLevels.Location = new System.Drawing.Point(720, 456);
				this.lblTotalLevels.Font = LargeBoldFont;

				this.lblLevelsTxt.Location = new System.Drawing.Point(750, 456);
				this.lblLevelsTxt.Font = LargeRegularFont;

				this.lblLevelSolved.Location = new System.Drawing.Point(676, 3);
				this.lblLevelSolved.Font = LargeRegularFont;

				this.lblLevelNo.Location = new System.Drawing.Point(643, 3);
				this.lblLevelNo.Font = LargeBoldFont;

				this.lblLevelTxt.Location = new System.Drawing.Point(600, 3);
				this.lblLevelTxt.Font = LargeRegularFont;
				
				this.lblMaxChars.Location = new System.Drawing.Point(400, 3);
				this.lblMaxChars.Font = LargeRegularFont;

				this.lblBytesUsed.Location = new System.Drawing.Point(361, 3);
				this.lblBytesUsed.Font = LargeBoldFont;

				BoardHeight = HerbertBoard.Width;
				BoardWidth = HerbertBoard.Height;
				
				resetHerbert();
			}
			else
			{		
				if(!progClosing)
				{
					killThread();
				}
				Font SmallBlodFont = new Font("Verdana", 8, FontStyle.Bold);
				Font SmallRegularFont = new Font("Verdana", 8, FontStyle.Regular);
#if(TOOLBAR)
				this.pnlContainer.Location = new System.Drawing.Point(0,pnlContainer.Location.Y);
#else
				this.pnlContainer.Location = new System.Drawing.Point(0,0);
#endif
				this.pnlContainer.Width = 505;
				this.pnlContainer.Height = 296;
				herbertPicBox.Size = new Size(14,14);
				this.pnlMain.Size = new System.Drawing.Size(464, 233);

				lblPointTxt.Font = SmallRegularFont;
				this.lblPointTxt.Location = new System.Drawing.Point(1, 5);

				lblScoreCurrent.Font = SmallBlodFont;
				this.lblScoreCurrent.Location = new System.Drawing.Point(43, 5);

				this.lblScorePerDot.Font = SmallRegularFont;
				this.lblScorePerDot.Location = new System.Drawing.Point(96, 5);

				this.LevelChangeBar.Location = new System.Drawing.Point(481, 4);
				this.LevelChangeBar.Size = new System.Drawing.Size(18, 244);

				this.PanalTxtCodeEdit.Size = new System.Drawing.Size(248, 184);

				this.txtCodeEditor.Size = new System.Drawing.Size(246, 181);

				this.lblLineTracing.Location = new System.Drawing.Point(10, 211);			
				this.lblLineTracing.Size = new System.Drawing.Size(248, 26);

				this.HerbertBoard.Location = new System.Drawing.Point(260, 28);
				this.HerbertBoard.Size = new System.Drawing.Size(208, 208);

				this.SpeedBar.Location = new System.Drawing.Point(152, 249);
				this.SpeedBar.Size = new System.Drawing.Size(264, 16);
	
				this.lblMsgBox.Location = new System.Drawing.Point(5, 268);
				this.lblMsgBox.Size = new System.Drawing.Size(460, 23);
				this.lblMsgBox.Font = SmallRegularFont;

				this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
				this.picBFastHrbt.Size = new System.Drawing.Size(12, 16);

				this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);
				this.picBSlowHrbt.Size = new System.Drawing.Size(12, 10);

				this.lblTraceFirst.Location = new System.Drawing.Point(11, 214);
				this.lblTraceFirst.Size = new System.Drawing.Size(0, 17);

				this.lblBlack.Location = new System.Drawing.Point(112, 214);
				this.lblBlack.Size = new System.Drawing.Size(0, 20);

				this.lblTraceSecond.Location = new System.Drawing.Point(240, 214);
				this.lblTraceSecond.Size = new System.Drawing.Size(0, 17);

				this.TxtLevelPoints.Location = new System.Drawing.Point(27, 268);
				this.TxtLevelPoints.Font = SmallRegularFont;

				this.lblLevelPoints.Location = new System.Drawing.Point(5, 269);
				this.lblLevelPoints.Size = new System.Drawing.Size(22, 17);

				this.lblDifficultyMsg.Location = new System.Drawing.Point(8, 296);
				this.lblDifficultyMsg.Size = new System.Drawing.Size(112, 23);


				this.cbDifficultyBucket.Location = new System.Drawing.Point(120, 296);
				this.cbDifficultyBucket.Size = new System.Drawing.Size(48, 21);

				this.lblScoreTxt.Location = new System.Drawing.Point(1, 249);
				this.lblScoreTxt.Font = SmallRegularFont;

				this.lblTotalScore.Location = new System.Drawing.Point(40, 249);
				this.lblTotalScore.Font = SmallBlodFont;

				this.lblSpeedTxt.Location = new System.Drawing.Point(94, 249);
				this.lblSpeedTxt.Font = SmallRegularFont;

				this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);

				this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);

				this.lblTotalLevels.Location = new System.Drawing.Point(437, 249);
				this.lblTotalLevels.Font = SmallBlodFont;

				this.lblLevelsTxt.Location = new System.Drawing.Point(463, 249);
				this.lblLevelsTxt.Font = SmallRegularFont;

				this.lblLevelSolved.Location = new System.Drawing.Point(396, 5);
				this.lblLevelSolved.Font = SmallRegularFont;

				this.lblLevelNo.Location = new System.Drawing.Point(368, 5);
				this.lblLevelNo.Font = SmallBlodFont;

				this.lblLevelTxt.Location = new System.Drawing.Point(332, 5);
				this.lblLevelTxt.Font = SmallRegularFont;

				this.lblMaxChars.Location = new System.Drawing.Point(214, 5);
				this.lblMaxChars.Font = SmallRegularFont;

				this.lblBytesUsed.Location = new System.Drawing.Point(175, 5);
				this.lblBytesUsed.Font = SmallBlodFont;

				BoardHeight = HerbertBoard.Width;
				BoardWidth = HerbertBoard.Height;

				//this.CenterToScreen();
				resetHerbert();
			}
			//this.ResumeLayout(true);
		}

#endif
#if(MS10MAR||FT)

        public string T_Decode(string s)
        {

            return Encoding.ASCII.GetString(Convert.FromBase64String(s.ToString()));
        }

        /// <summary>
        /// De-Compress data in dataset.
        /// </summary>
        /// <param name="dsNew">Decompressed dataset.</param>
        /// <param name="dsOld">compressed dataset.</param>
        /// <returns>Decompressed dataset.</returns>
#if(COMPRESSION)
        internal DataSet DMPLEX(DataSet dsOld)
        {
            DateTimeFormatInfo dfi1 = new DateTimeFormatInfo();
            CultureInfo ci = new CultureInfo("en-us");
            dfi1.MonthDayPattern = "mm/dd/yy";
            dfi1.DateSeparator = "/";
            ci.DateTimeFormat = dfi1;
            DataSet dsNew = new DataSet();
            try
            {
                dsNew = GlobalData.dsAllHData.Clone();
                /*==============================================================================
                *  Added By: Vivek Balagangadharan
                *  Description: To fix the issue of IC07 users getting errors while parsing datetimes with it-IT locale.
                *  Added On: 16-Dec-2006
                * ==============================================================================*/
                dsNew.Locale = ci;
                /*End of block */
                for (int i = 0; i < dsOld.Tables.Count; i++)
                {
                    //int j = 0;
                    if (i == 2)
                    {
                        foreach (DataRow dr in dsOld.Tables[i].Rows)
                        {
                            string iLevelId = dr["lid"].ToString();
                            string iLevelNo = dr["lno"].ToString();
                            string sAllW = dr["w"].ToString();
                            string sAllG = dr["g"].ToString();
                            string[] strButtons = sAllW.Split(('#'));

                            foreach (string str in strButtons)
                            {
                                if (str != "")
                                {
                                    int buttonX = int.Parse(str) / 25;
                                    int buttonY = int.Parse(str) % 25;
                                    DataRow r = dsNew.Tables[i].NewRow();
                                    r["LevelId"] = iLevelId;
                                    r["LevelNo"] = iLevelNo;
                                    r["ButtonX"] = buttonX.ToString();
                                    r["ButtonY"] = buttonY.ToString();
                                    r["Grey"] = "0";
                                    dsNew.Tables[i].Rows.Add(r);
                                }

                            }
                            strButtons = sAllG.Split(('#'));
                            foreach (string str in strButtons)
                            {
                                if (str != "")
                                {
                                    int buttonX = int.Parse(str) / 25;
                                    int buttonY = int.Parse(str) % 25;
                                    DataRow r = dsNew.Tables[i].NewRow();
                                    r["LevelId"] = iLevelId;
                                    r["LevelNo"] = iLevelNo;
                                    r["ButtonX"] = buttonX.ToString();
                                    r["ButtonY"] = buttonY.ToString();
                                    r["Grey"] = "1";
                                    dsNew.Tables[i].Rows.Add(r);
                                }

                            }

                        }

                    }
                    else if (i == 3)
                    {//For Wall
                        foreach (DataRow dr in dsOld.Tables[i].Rows)
                        {
                            string iLevelId = dr["lid"].ToString();
                            string iLevelNo = dr["lno"].ToString();
                            string sAllW = dr["w"].ToString();
                            string[] strButtons = sAllW.Split(('$'));

                            foreach (string str in strButtons)
                            {
                                if (str != "")
                                {
                                    string[] str1 = str.Split(('#'));
                                    int startX = int.Parse(str1[0].ToString()) / 25;
                                    int startY = int.Parse(str1[0].ToString()) % 25;
                                    int endX = int.Parse(str1[1].ToString()) / 25;
                                    int endY = int.Parse(str1[1].ToString()) % 25;

                                    DataRow r = dsNew.Tables[i].NewRow();
                                    r["LevelId"] = iLevelId;
                                    r["LevelNo"] = iLevelNo;
                                    r["startX"] = startX.ToString();
                                    r["startY"] = startY.ToString();
                                    r["endX"] = endX.ToString();
                                    r["endY"] = endY.ToString();
                                    dsNew.Tables[i].Rows.Add(r);
                                }

                            }
                        }

                    }
                    else
                    {
                        foreach (DataRow dr in dsOld.Tables[i].Rows)
                        {
                            // Split the multiplexed Data
                            object[] sa;
                            try
                            {
                                //j++;
                                sa = dr.ItemArray[0].ToString().Split(new char[] { '~' });
                                if (i == 5 || i == 0 || i == 6 || i == 4)
                                {
                                    for (int x = 0; x < sa.Length; x++)
                                    {
                                        sa[x] = T_Decode(sa[x].ToString());
                                        if (dsNew.Tables[i].Columns[x].DataType == typeof(DateTime))
                                        {
                                            //MessageBox.Show(sa[x].ToString());
                                            /*DateTime dt = DateTime.Parse(sa[x].ToString(), new CultureInfo("en-us"));
                                             //Removwed By rajesh to fix the datetime issue on xp machine with en-us settings Old Code
                                             */
                                            /*==============================================================================
                                             *  Edited By: Rajesh Chandratre
                                             *  Description: To fix the issue reported by the user for xp machine and en-us settings
                                             *  Edited On: 18-Dec-2006
                                             * ==============================================================================*/
                                            DateTimeFormatInfo dfi = new DateTimeFormatInfo();
                                            dfi.MonthDayPattern = "mm/dd/yy";
                                            DateTime dt = DateTime.Parse(sa[x].ToString(), dfi);
                                            /*End of block */
                                            //Added By Rajesh: 13/9/2006 to fix Issue:Client Issue(5074)
                                            dt = DateTime.ParseExact(dt.ToString(), CultureInfo.CurrentCulture.DateTimeFormat.GetAllDateTimePatterns(), CultureInfo.CurrentCulture, DateTimeStyles.AllowWhiteSpaces);
                                            /*==============================================================================
                                             *  Edited By: Vivek Balagangadharan
                                             *  Description: To fix the issue of IC07 users getting errors while parsing datetimes with it-IT locale.
                                             *  Edited On: 16-Dec-2006
                                             * ==============================================================================*/
                                            sa[x] = dt.ToString(ci);
                                            /*End of block */
                                        }
                                    }
                                }
                                dsNew.Tables[i].Rows.Add(sa);
                            }
                            catch (Exception exp)
                            {

                                sbErrorLog.Append("\nIn DMPLEX::" + exp.Message + "\n");
#if(DEBUG)
                                MessageBox.Show(exp.Message);
#endif
                            }
                            // assign the values to the correct columns
                            //					DataRow drNew = dsNew.Tables[i].NewRow();
                            //					for(int j=0;j<drNew.ItemArray.Length;j++)
                            //					{
                            //						// Might have to convert the types explicitly this is pre-emptive
                            //						//drNew.ItemArray[j]=Convert.ChangeType(sa[j],(drNew.ItemArray[j].GetType()));
                            //						drNew.ItemArray[j]=sa[j];						
                            //					}
                            //					dsNew.Tables[i].Rows.Add(
                        }
                    }

                    dsNew.Tables[i].AcceptChanges();
                }
            }
            catch (Exception exp)
            {
#if(DEBUG)
                MessageBox.Show(exp.Message);
#endif
            }
            return dsNew;
        }
#else        
		internal DataSet DMPLEX(DataSet dsOld)
		{
			DataSet dsNew = new DataSet();
			dsNew = GlobalData.dsAllHData.Clone();
			for(int i=0;i<dsOld.Tables.Count;i++)
			{
				//int j = 0;
				foreach(DataRow dr in dsOld.Tables[i].Rows)
				{
					// Split the multiplexed Data
					object[] sa;
					try
					{
						//j++;
						sa = dr.ItemArray[0].ToString().Split(new char[]{'~'});
						if(i == 5 || i == 0 || i == 6)
						{
							for(int x = 0; x < sa.Length; x++)
							{
								sa[x] = T_Decode(sa[x].ToString());
								if(dsNew.Tables[i].Columns[x].DataType == typeof(DateTime))
								{
									//MessageBox.Show(sa[x].ToString());
									DateTime dt = DateTime.Parse(sa[x].ToString(),new CultureInfo("en-us"));
									sa[x] = dt.ToString();
								}
								
							}
						}
						dsNew.Tables[i].Rows.Add(sa);						
					}
					catch(Exception exp)
					{
						MessageBox.Show(exp.Message);
					}
					// assign the values to the correct columns
//					DataRow drNew = dsNew.Tables[i].NewRow();
//					for(int j=0;j<drNew.ItemArray.Length;j++)
//					{
//						// Might have to convert the types explicitly this is pre-emptive
//						//drNew.ItemArray[j]=Convert.ChangeType(sa[j],(drNew.ItemArray[j].GetType()));
//						drNew.ItemArray[j]=sa[j];						
//					}
//					dsNew.Tables[i].Rows.Add(
				}
				
				dsNew.Tables[i].AcceptChanges();
			}
			return dsNew;
		}
#endif

        /// <summary>
        /// generates the lines out of textbox data.
        /// </summary>
        private void getTextData()
        {
            //txtCodeEditor.Text = txtCodeEditor.Text.Replace("\r","");
            //txtCodeEditor.Text = txtCodeEditor.Text.Trim();			
            txtTotalLength = txtCodeEditor.Text.Replace("\r", "").Length;
            txtTotalLines = txtCodeEditor.Lines.Length;
            txtLines = new string[txtTotalLines];
            txtLines = txtCodeEditor.Lines;
            for (int i = 0; i < txtTotalLines; i++)
            {
                txtLines[i] = txtLines[i].Replace("\r", "");
            }
        }


        /// <summary>
        /// trim the blank lines and returns at the end of program.
        /// </summary>
        private void TrimTextData()
        {
            string codeWritten = txtCodeEditor.Text;
            int codeLen = codeWritten.Length;
            int i = codeLen - 1;
            while (i > 0)
            {
                if (codeWritten[i] == '\n')
                {
                    codeWritten = codeWritten.Remove(i - 1, 2);
                    i--;
                }
                else
                {
                    break;
                }
                i--;
            }
            txtCodeEditor.Text = codeWritten;

        }

        /// <summary>
        /// Function to zoom in or zoom out Herbert exe when the window is resized.
        /// The size and location of the controls are set depending on whether the Herbert window is zoomed in or zoomed out.
        /// </summary>
        private void ZoomInZoomOut()
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
            else
            {
                EnableRestore();
            }
#endif
            killThread();

            deSelectError();
            //if(!(bool)progClosing)
            # region designer related code
# if (DESIGNER)
			// added by karthikeyan to optimize zoominzoomout on 26072005
			try
			{
				if(GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate) 
				{					
					//&& arrLevels[currentLevelIndex].IsLevelDisplayUpdated)
					//MessageBox.Show(this,"I'm inside hell");
					arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelId);
					//arrLevels[currentLevelIndex].IsLevelDisplayUpdated = false;
				}
			}
			catch
			{
				//MessageBox.Show(this,exp.Message);
				//				//Console.WriteLine(exp.Message);
			}
			if(GlobalData.HerbertMode == HMode.Designer)
			{
				mnuMainDesign.Enabled= true;
				//UncheckAllDH();
///added By Rajesh
///To Maintain Default White button enable
//				mnuWhitebttn.Enabled=true;
///end
			}
#endif
            # endregion
            #region GENERATE_PATTERN
#if(PATTERN_GENERATER)
            arrLevels[currentLevelIndex].isPatternEnabled = false;
            this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
            btShowPattern.FlatStyle = FlatStyle.Standard;
            mnuShowPattern.Checked = false;
            mnuShowPattern.Text = "Show Pattern";
            //try
            //{
            //    if (GlobalData.iPatternId != "-1")
            //        if (arrLevels[currentLevelIndex].IsValidPatternImage)
            //        {
            //            string strtracesign = "";
            //            if (currentLevelIndex != 0)
            //            {
            //                strtracesign = GlobalData.dsAllHData.Tables[7].Rows[currentLevelIndex - 1]["tracesignature"].ToString();
            //                strtracesign = Level.GetTrace(strtracesign);
            //            }
            //            arrLevels[currentLevelIndex].GenerateTraceImage(strtracesign, GlobalData.ZoomInZoomOut);
            //        }
            //}
            //catch { }
#endif
            #endregion
            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
            {
                this.pnlContainer.SuspendLayout();
                //this.SuspendLayout();
                Font LargeBoldFont = new Font("Verdana", 10, FontStyle.Bold);
                Font LargeRegularFont = new Font("Verdana", 10, FontStyle.Regular);
                //this.pnlContainer.Location = new System.Drawing.Point(this.Width/2-400, pnlContainer.Location.Y);
                //pnlContainer.Left = 45;
                this.pnlContainer.Left = this.Width / 2 - 400;
                this.pnlContainer.Top = pnlContainer.Location.Y;
                this.pnlContainer.Width = 800;
                this.pnlContainer.Height = 520;
                herbertPicBox.Width = 26;
                herbertPicBox.Height = 24;


                //this.pnlMain.Size = new System.Drawing.Size(755, 441);
                this.pnlMain.Width = 755;
                this.pnlMain.Height = 441;
                lblClosing.Left = pnlContainer.Left + pnlContainer.Width / 2 - lblClosing.Width / 2;
                lblClosing.Top = pnlContainer.Top + pnlContainer.Height / 2 - lblClosing.Height / 2;

                lblPointTxt.Font = LargeRegularFont;
                //this.lblPointTxt.Location = new System.Drawing.Point(1, 3);
                this.lblPointTxt.Left = 1;
                this.lblPointTxt.Top = 3;

                lblScoreCurrent.Font = LargeBoldFont;
                //this.lblScoreCurrent.Location = new System.Drawing.Point(54, 3);
                this.lblScoreCurrent.Left = 54;
                this.lblScoreCurrent.Top = 3;

                this.lblScorePerDot.Font = LargeRegularFont;
                //this.lblScorePerDot.Location = new System.Drawing.Point(116, 3);
                this.lblScorePerDot.Left = 166;
                this.lblScorePerDot.Top = 3;

                this.lblTxtBytes.Font = LargeRegularFont;
                this.lblTxtBytes.Left = 286;
                this.lblTxtBytes.Top = 3;
                this.lblTxtBytes.Width = 50;

                //this.LevelChangeBar.Location = new System.Drawing.Point(772, 4);
                this.LevelChangeBar.Left = 772;
                this.LevelChangeBar.Top = 4;
                //this.LevelChangeBar.Size = new System.Drawing.Size(18, 448);
                this.LevelChangeBar.Width = 18;
                this.LevelChangeBar.Height = 448;

                //this.PanalTxtCodeEdit.Size = new System.Drawing.Size(329, 390);
                this.PanalTxtCodeEdit.Width = 329;
                this.PanalTxtCodeEdit.Height = 390;
                EditorImg = new Bitmap(329, 390);

                //this.txtCodeEditor.Size = new System.Drawing.Size(327, 388);
                //				lock(txtCodeEditor)
                //				{
                this.txtCodeEditor.Width = 327;
                this.txtCodeEditor.Height = 388;
                //				}

                //this.lblLineTracing.Location = new System.Drawing.Point(10, 417);			
                this.lblLineTracing.Left = 10;
                this.lblLineTracing.Top = 417;
                //this.lblLineTracing.Size = new System.Drawing.Size(329, 27);
                this.lblLineTracing.Width = 329;
                this.lblLineTracing.Height = 27;

                //this.HerbertBoard.Location = new System.Drawing.Point(342, 28);
                this.HerbertBoard.Left = 342;
                this.HerbertBoard.Top = 28;
                //this.HerbertBoard.Size = new System.Drawing.Size(416, 416);
                this.HerbertBoard.Width = 416;
                this.HerbertBoard.Height = 416;

                //this.SpeedBar.Location = new System.Drawing.Point(172, 456);
                this.SpeedBar.Left = 270;
                this.SpeedBar.Top = 457;
                //			this.SpeedBar.Size = new System.Drawing.Size(508, 16);
                this.SpeedBar.Width = 408;
                this.SpeedBar.Height = 16;



                //this.lblMsgBox.Location = new System.Drawing.Point(5, 480);
# if(DESIGNER)
				if(GlobalData.HerbertMode == HMode.Designer)
				{
                    this.lblMsgBox.Left = 236;
                    this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width - 236;
				}
				else
				{
# endif
                lblMsgBox.Location = new Point(3, 268);
#if(CONTEST)
                //this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width;
#else
                this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width;
#endif
                this.lblMsgBox.Left = 3;
# if(DESIGNER)
				}
# endif
                this.lblMsgBox.Top = 480;
                this.lblMsgBox.Height = 30;
                this.lblMsgBox.Font = LargeRegularFont;
#if(CONTEST)
                if (GlobalData.HerbertMode == HMode.Tutorial || GlobalData.iTimerEnable == 0 || GlobalData.IsLoadFromFile == true || GlobalData.isTimerToggleVisible == false)
                    this.lblMsgBox.Width = 788;
                else
                    this.lblMsgBox.Width = 590;
#endif

                //this.lblMsgBox.Size = new System.Drawing.Size(757, 23);

                this.lblMsgBox.Height = 30;
                this.lblMsgBox.Font = LargeRegularFont;
#if(CONTEST)
                //added by NikhilK on 4/6/2007 for positioning of timer labels
                this.lblTimer.Font = LargeRegularFont;
                this.lblTimer.Left = 600;
                this.lblTimer.Top = 490;

                //added by NikhilK on 4/6/2007 for positioning of timer labels
                this.lblTimeLeft.Font = LargeBoldFont;
                this.lblTimeLeft.Left = 640;
                this.lblTimeLeft.Top = 490;
#endif

                //this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
                this.picBFastHrbt.Left = 417;
                this.picBFastHrbt.Top = 250;
                //this.picBFastHrbt.Size = new System.Drawing.Size(12, 16);
                this.picBFastHrbt.Width = 12;
                this.picBFastHrbt.Height = 16;


                //this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);
                this.picBSlowHrbt.Left = 223;
                this.picBSlowHrbt.Top = 251;
                //this.picBSlowHrbt.Size = new System.Drawing.Size(12, 10);
                this.picBSlowHrbt.Width = 12;
                this.picBSlowHrbt.Height = 10;

                //this.lblTraceFirst.Location = new System.Drawing.Point(11, 420);
                this.lblTraceFirst.Left = 11;
                this.lblTraceFirst.Top = 420;
                //this.lblTraceFirst.Size = new System.Drawing.Size(0, 17);
                this.lblTraceFirst.Width = 0;
                this.lblTraceFirst.Height = 17;

                //this.lblBlack.Location = new System.Drawing.Point(112, 420);
                this.lblBlack.Left = 112;
                this.lblBlack.Top = 420;
                //this.lblBlack.Size = new System.Drawing.Size(0, 20);
                this.lblBlack.Width = 0;
                this.lblBlack.Height = 20;

                //this.lblTraceSecond.Location = new System.Drawing.Point(240, 420);
                this.lblTraceSecond.Left = 240;
                this.lblTraceSecond.Top = 420;
                //this.lblTraceSecond.Size = new System.Drawing.Size(0, 17);
                this.lblTraceSecond.Width = 0;
                this.lblTraceSecond.Height = 17;
# if(DESIGNER)
                this.txtLevelPoints.Location = new System.Drawing.Point(47, 268);
                this.txtLevelPoints.Left = 47;
                this.txtLevelPoints.Top = 480;
                this.txtLevelPoints.Font = LargeRegularFont;

                this.lblLevelPoints.Location = new System.Drawing.Point(5, 269);
                this.lblLevelPoints.Left = 5;
                this.lblLevelPoints.Top = 480;
                this.lblLevelPoints.Size = new System.Drawing.Size(40, 24);
                this.lblLevelPoints.Width = 40;
                this.lblLevelPoints.Height = 24;
                this.lblLevelType.Location = new System.Drawing.Point(99, 484);
                this.cmbxLevelType.Height = 35;
                this.cmbxLevelType.Font = LargeRegularFont;
                this.cmbxLevelType.Location = new System.Drawing.Point(134, 480);
# endif
# if(CONTEST)
                //this.lblScoreTxt.Location = new System.Drawing.Point(1, 456);
                this.lblScoreTxt.Left = 1;
                this.lblScoreTxt.Top = 456;
                this.lblScoreTxt.Font = LargeRegularFont;

                //this.lblTotalScore.Location = new System.Drawing.Point(50, 456);
                this.lblTotalScore.Left = 50;
                this.lblTotalScore.Top = 456;
                this.lblTotalScore.Font = LargeBoldFont;
#endif
                //this.lblSpeedTxt.Location = new System.Drawing.Point(104, 456);
                this.lblSpeedTxt.Left = 203;
                this.lblSpeedTxt.Top = 456;
                this.lblSpeedTxt.Font = LargeRegularFont;

                //this.picBSlowHrbt.Location = new System.Drawing.Point(159, 458);
                this.picBSlowHrbt.Left = 257;
                this.picBSlowHrbt.Top = 459;

                //this.picBFastHrbt.Location = new System.Drawing.Point(681, 457);
                this.picBFastHrbt.Left = 681;
                this.picBFastHrbt.Top = 459;

                //this.lblLevelsTxt.Location = new System.Drawing.Point(750, 456);
                this.lblLevelsTxt.Left = 750;
                this.lblLevelsTxt.Top = 456;
                this.lblLevelsTxt.Font = LargeRegularFont;

                //this.lblTotalLevels.Location = new System.Drawing.Point(720, 456);
                lblTotalLevels.Left = lblLevelsTxt.Left - lblTotalLevels.Width - 6;
                this.lblTotalLevels.Top = 456;
                this.lblTotalLevels.Font = LargeBoldFont;

                //this.lblLevelSolved.Location = new System.Drawing.Point(676, 3);
                this.lblLevelSolved.Left = 676;
                this.lblLevelSolved.Top = 3;
                this.lblLevelSolved.Font = LargeRegularFont;

                //this.lblLevelNo.Location = new System.Drawing.Point(643, 3);
                this.lblLevelNo.Left = 643;
                this.lblLevelNo.Top = 3;
                this.lblLevelNo.Width = 35;
                this.lblLevelNo.Font = LargeBoldFont;

                //this.lblLevelTxt.Location = new System.Drawing.Point(600, 3);
                this.lblLevelTxt.Left = 600;
                this.lblLevelTxt.Top = 3;
                this.lblLevelTxt.Font = LargeRegularFont;

                //this.lblMaxChars.Location = new System.Drawing.Point(400, 3);
                this.lblMaxChars.Left = 380;
                this.lblMaxChars.Top = 3;
                this.lblMaxChars.Font = LargeRegularFont;

                //this.lblBytesUsed.Location = new System.Drawing.Point(340, 3);
                this.lblBytesUsed.Left = 340;
                this.lblBytesUsed.Top = 3;
                this.lblBytesUsed.Font = LargeBoldFont;
                this.lblBytesUsed.Width = 50;

                //this.lblLoading
                this.lblLoading.Left = this.Width / 2 - lblLoading.Width;
                this.lblLoading.Top = this.Height / 2 - lblLoading.Height;
                this.lblLoading.Font = LargeRegularFont;
#if(CONTEST)
                // by Nikhil Kardale on 24/5/2007 - for lblClosing label
                //this.lblClosing.Left = 200;
                //this.lblClosing.Top = this.Height / 2 - lblClosing.Height;
                this.lblClosing.Location = new System.Drawing.Point(174, 208);
                this.lblClosing.Size = new System.Drawing.Size(158, 23);
                this.lblClosing.Font = LargeRegularFont;

                // by Nikhil Kardale on 24/5/2007 - for text code editor
                this.txtCodeEditor.Font = LargeRegularFont;
#endif

                //				LargeBoldFont.Dispose();
                //				LargeRegularFont.Dispose();
                LargeRegularFont = null;
                LargeBoldFont = null;
                this.pnlContainer.ResumeLayout(false);
                //txtCodeEditor.Focus();
            }
            else
            {
                this.pnlContainer.SuspendLayout();
                Font SmallBlodFont = new Font("Verdana", 8, FontStyle.Bold);
                Font SmallRegularFont = new Font("Verdana", 8, FontStyle.Regular);
#if(TOOLBAR)
                this.pnlContainer.Location = new System.Drawing.Point(0, pnlContainer.Location.Y);
#else
				//this.pnlContainer.Location = new System.Drawing.Point(0,0);
				this.pnlContainer.Left = 0;
				this.pnlContainer.Top = 0;
#endif
                this.pnlContainer.Width = 505;
                this.pnlContainer.Height = 296;
                //herbertPicBox.Size = new Size(14,14);
                herbertPicBox.Width = 14;
                herbertPicBox.Height = 14;

                lblClosing.Left = pnlContainer.Left + pnlContainer.Width / 2 - lblClosing.Width / 2;
                lblClosing.Top = pnlContainer.Top + pnlContainer.Height / 2 - lblClosing.Height / 2;
                //this.pnlMain.Size = new System.Drawing.Size(464, 233);
                this.pnlMain.Width = 464;
                this.pnlMain.Height = 233;

                lblPointTxt.Font = SmallRegularFont;
                //this.lblPointTxt.Location = new System.Drawing.Point(1, 5);
                this.lblPointTxt.Left = 1;
                this.lblPointTxt.Top = 5;

                lblScoreCurrent.Font = SmallBlodFont;
                //this.lblScoreCurrent.Location = new System.Drawing.Point(43, 5);
                this.lblScoreCurrent.Left = 41;
                this.lblScoreCurrent.Top = 5;

                this.lblScorePerDot.Font = SmallRegularFont;
                //this.lblScorePerDot.Location = new System.Drawing.Point(96, 5);
                this.lblScorePerDot.Left = 130;
                this.lblScorePerDot.Top = 5;

                this.lblTxtBytes.Font = SmallRegularFont;
                this.lblTxtBytes.Left = 203;
                this.lblTxtBytes.Top = 5;
                this.lblTxtBytes.Width = 40;

                //this.LevelChangeBar.Location = new System.Drawing.Point(481, 4);
                this.LevelChangeBar.Left = 481;
                this.LevelChangeBar.Top = 4;
                //				this.LevelChangeBar.Size = new System.Drawing.Size(18, 244);
                this.LevelChangeBar.Width = 18;
                this.LevelChangeBar.Height = 240;


                //this.PanalTxtCodeEdit.Size = new System.Drawing.Size(248, 184);
                this.PanalTxtCodeEdit.Width = 248;
                this.PanalTxtCodeEdit.Height = 184;
                EditorImg = new Bitmap(248, 184);

                //this.txtCodeEditor.Size = new System.Drawing.Size(246, 181);

                this.txtCodeEditor.Width = 246;
                this.txtCodeEditor.Height = 181;

                //this.lblLineTracing.Location = new System.Drawing.Point(10, 211);			
                this.lblLineTracing.Left = 10;
                this.lblLineTracing.Top = 211;
                //this.lblLineTracing.Size = new System.Drawing.Size(248, 26);
                this.lblLineTracing.Width = 248;
                this.lblLineTracing.Height = 26;

                //this.HerbertBoard.Location = new System.Drawing.Point(260, 28);
                this.HerbertBoard.Left = 260;
                this.HerbertBoard.Top = 28;
                //this.HerbertBoard.Size = new System.Drawing.Size(208, 208);
                this.HerbertBoard.Width = 208;
                this.HerbertBoard.Height = 208;

                //this.SpeedBar.Location = new System.Drawing.Point(152, 249);
                this.SpeedBar.Left = 236;
                this.SpeedBar.Top = 249;
                //this.SpeedBar.Size = new System.Drawing.Size(264, 16);
                this.SpeedBar.Width = 180;
                this.SpeedBar.Height = 16;

                //this.lblMsgBox.Location = new System.Drawing.Point(5, 268);

# if(DESIGNER)
				if(GlobalData.HerbertMode == HMode.Designer)
				{
                    this.lblMsgBox.Left = 236;
                    this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width - 236;
				}
				else
				{
# endif
                this.lblMsgBox.Left = 3;
#if(CONTEST)
                if (GlobalData.HerbertMode == HMode.Tutorial || GlobalData.iTimerEnable == 0 || GlobalData.IsLoadFromFile == true || GlobalData.isTimerToggleVisible == false)
                    this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width;
                else
                    this.lblMsgBox.Width = 316;
#endif
# if(DESIGNER)
				}
# endif
                this.lblMsgBox.Top = 268;
                //this.lblMsgBox.Size = new System.Drawing.Size(466, 23);				
                this.lblMsgBox.Height = 23;
                this.lblMsgBox.Font = SmallRegularFont;
#if(CONTEST)
                //added by NikhilK on 4/6/2007 for positioning of timer labels
                this.lblTimer.Font = SmallRegularFont;
                this.lblTimer.Left = 328;
                this.lblTimer.Top = 273;

                //added by NikhilK on 4/6/2007 for positioning of timer labels
                this.lblTimeLeft.Font = SmallBlodFont;
                this.lblTimeLeft.Left = 363;
                this.lblTimeLeft.Top = 273;
#endif
                //this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
                this.picBFastHrbt.Left = 417;
                this.picBFastHrbt.Top = 250;
                //this.picBFastHrbt.Size = new System.Drawing.Size(12, 16);
                this.picBFastHrbt.Width = 12;
                this.picBFastHrbt.Height = 16;

                //this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);
                this.picBSlowHrbt.Left = 223;
                this.picBSlowHrbt.Top = 251;
                //this.picBSlowHrbt.Size = new System.Drawing.Size(12, 10);
                this.picBSlowHrbt.Width = 12;
                this.picBSlowHrbt.Height = 10;

                //this.lblTraceFirst.Location = new System.Drawing.Point(11, 214);
                this.lblTraceFirst.Left = 11;
                this.lblTraceFirst.Top = 214;
                //this.lblTraceFirst.Size = new System.Drawing.Size(0, 17);
                this.lblTraceFirst.Width = 0;
                this.lblTraceFirst.Height = 17;

                //this.lblBlack.Location = new System.Drawing.Point(112, 214);
                this.lblBlack.Left = 112;
                this.lblBlack.Top = 214;
                //this.lblBlack.Size = new System.Drawing.Size(0, 20);
                this.lblBlack.Width = 0;
                this.lblBlack.Height = 20;

                //this.lblTraceSecond.Location = new System.Drawing.Point(240, 214);
                this.lblTraceSecond.Left = 240;
                this.lblTraceSecond.Top = 214;
                //this.lblTraceSecond.Size = new System.Drawing.Size(0, 17);
                this.lblTraceSecond.Width = 0;
                this.lblTraceSecond.Height = 17;
# if(DESIGNER)
				this.txtLevelPoints.Location = new System.Drawing.Point(48, 270);
				this.txtLevelPoints.Left = 48;
				this.txtLevelPoints.Top = 270;
				this.txtLevelPoints.Font = SmallRegularFont;

				this.lblLevelPoints.Location = new System.Drawing.Point(5, 269);
				this.lblLevelPoints.Left = 5;
				this.lblLevelPoints.Top = 264;

				this.lblLevelPoints.Size = new System.Drawing.Size(40,24);
				this.lblLevelPoints.Width= 40; 
				this.lblLevelPoints.Height= 24;
# endif

# if(CONTEST)
                //this.lblScoreTxt.Location = new System.Drawing.Point(1, 249);
                this.lblScoreTxt.Left = 1;
                this.lblScoreTxt.Top = 249;
                this.lblScoreTxt.Font = SmallRegularFont;

                //this.lblTotalScore.Location = new System.Drawing.Point(40, 249);
                this.lblTotalScore.Left = 40;
                this.lblTotalScore.Top = 249;
                this.lblTotalScore.Font = SmallBlodFont;
#endif

                //this.lblSpeedTxt.Location = new System.Drawing.Point(94, 249);
                this.lblSpeedTxt.Left = 176;
                this.lblSpeedTxt.Top = 249;
                this.lblSpeedTxt.Font = SmallRegularFont;

                //this.picBSlowHrbt.Location = new System.Drawing.Point(139, 251);
                this.picBSlowHrbt.Left = 223;
                this.picBSlowHrbt.Top = 251;

                //this.picBFastHrbt.Location = new System.Drawing.Point(417, 250);
                this.picBFastHrbt.Left = 417;
                this.picBFastHrbt.Top = 250;

                //this.lblLevelsTxt.Location = new System.Drawing.Point(463, 249);
                this.lblLevelsTxt.Left = 463;
                this.lblLevelsTxt.Top = 249;
                this.lblLevelsTxt.Font = SmallRegularFont;

                //this.lblTotalLevels.Location = new System.Drawing.Point(437, 248);
                this.lblTotalLevels.Font = SmallBlodFont;
                this.lblTotalLevels.Invalidate();
                lblTotalLevels.Left = lblLevelsTxt.Left - lblTotalLevels.Width;
                this.lblTotalLevels.Top = 249;


                //this.lblLevelSolved.Location = new System.Drawing.Point(396, 5);
                this.lblLevelSolved.Left = 396;
                this.lblLevelSolved.Top = 5;
                this.lblLevelSolved.Font = SmallRegularFont;

                //this.lblLevelNo.Location = new System.Drawing.Point(368, 5);
                this.lblLevelNo.Left = 368;
                this.lblLevelNo.Top = 5;
                this.lblLevelNo.Width = 30;
                this.lblLevelNo.Font = SmallBlodFont;

                //this.lblLevelTxt.Location = new System.Drawing.Point(332, 5);
                this.lblLevelTxt.Left = 334;
                this.lblLevelTxt.Top = 5;
                this.lblLevelTxt.Font = SmallRegularFont;

                //this.lblMaxChars.Location = new System.Drawing.Point(214, 5);
                this.lblMaxChars.Left = 272;
                this.lblMaxChars.Top = 5;
                this.lblMaxChars.Font = SmallRegularFont;

                //this.lblLoading
                this.lblLoading.Left = 191;
                this.lblLoading.Top = 88;
                this.lblLoading.Font = SmallRegularFont;

                //this.lblBytesUsed.Location = new System.Drawing.Point(160, 5);
                this.lblBytesUsed.Left = 243;
                this.lblBytesUsed.Top = 5;
                this.lblBytesUsed.Font = SmallBlodFont;
                this.lblBytesUsed.Width = 32;
#if(DESIGNER)
                this.lblLevelType.Location = new System.Drawing.Point(99, 272);
                this.cmbxLevelType.Height = 21;
                this.cmbxLevelType.Font = SmallRegularFont;
                this.cmbxLevelType.Location = new System.Drawing.Point(134, 270);
#endif
#if(CONTEST)
                // by Nikhil Kardale on 24/5/2007 - for lblClosing label
                //this.lblClosing.Left = this.Width / 2 - lblClosing.Width;
                //this.lblClosing.Top = this.Height / 2 - lblClosing.Height;
                this.lblClosing.Location = new System.Drawing.Point(188, 208);
                this.lblClosing.Size = new System.Drawing.Size(132, 23);
                this.lblClosing.Font = SmallRegularFont;

                // by Nikhil Kardale on 24/5/2007 - for text code editor
                this.txtCodeEditor.Font = SmallRegularFont;
#endif

                SmallRegularFont = null;
                SmallBlodFont = null;
                this.pnlContainer.ResumeLayout(false);
            }

            BoardHeight = HerbertBoard.Width;
            BoardWidth = HerbertBoard.Height;


            resetHerbert();
            IniOrResetRunMenu();
            GC.Collect(); // check
            pnlContainer.Invalidate();
        }

#endif
        //Point[] pt = null;
        /// <summary>
        /// Loads the data for Herbert.
        ///  (Pavan's comments) This function gets the data for the supplied Guid.
        ///						It gets all the required data from webservice in dataset tables. 
        ///						Also initialises all the array's and variables from the dataset tables
        /// </summary>
        public void loadData()
        {
            //added By Rajesh 10/10/07 for localization
            DateTimeFormatInfo dfi1 = new DateTimeFormatInfo();
            CultureInfo ci1 = new CultureInfo("en-us");
            dfi1.MonthDayPattern = "mm/dd/yy";
            ci1.DateTimeFormat = dfi1;
            //dfi1.DateSeparator = "/";
            System.Threading.Thread.CurrentThread.CurrentCulture = ci1;
            int debugLineCounter = 0;
            //bool blnExp = false;
            try
            {
                //Monitor.Enter(objMonitorLevelChange);
                //Thread.Sleep(10000);
                int OpenLevel = 0;
                if (GlobalData.HerbertMode != HMode.Contest && GlobalData.HerbertMode != HMode.Designer)
                {
                    btnPrevUnsolved.Visible = false;
                    btnNextUnsolved.Visible = false;
                }

                if (GlobalData.HerbertMode != HMode.Tutorial)
                {
                    /*get the level data like number of levels 
                     * and time in minutes allowed to play game.
                     */



                    GlobalData.initlizeWS();

                    debugLineCounter++; //1


                    Object oper = EnableMyMenu(GlobalData.GUID);

                    debugLineCounter++; //2		


                    Object values = DisableMyMenu(plain, GlobalData.GUID, 1);
# if(DESIGNER)
				Object mode = DisableMyMenu("1",GlobalData.GUID,1);

				Object oLevelId = DisableMyMenu(GlobalData.iLevelId, GlobalData.GUID, 1);
# endif
# if(CONTEST)
                    Object mode = DisableMyMenu("0", GlobalData.GUID, 1);
# endif
                    int RetryCount = 0;

                    while (true)
                    {
                        DataSet dsCompressed = new DataSet();

                        try
                        {

#if(CONTEST)
#if (COMPRESSION)
#if(SESSIONMAGEMENT)
                            //string strSessionPath = Application.StartupPath + "\\Session1.xml";

                            if (GlobalData.IsLoadFromFile)
                            {
                                string strPath = EnableMyMenu(GlobalData.loginName).ToString();
                                strPath = strPath.Replace("\\", "k");
                                strPath = strPath.Replace("/", "l");
                                strPath = strPath.Replace(":", "m");
                                strPath = strPath.Replace("*", "n");
                                strPath = strPath.Replace("?", "o");
                                strPath = strPath.Replace("<", "p");
                                strPath = strPath.Replace(">", "q");
                                strPath = strPath.Replace("|", "r");
                                string strDirPath = GetDirecteryPath();
                                strPath = strDirPath + "\\" + strPath.Substring(10, 10) + ".sef";
                                if (File.Exists(strPath))
                                {
                                    try
                                    {
                                        GlobalData.dsAllHData = new DataSet();
                                        //GlobalData.dsAllHData.ReadXml(strSessionPath, XmlReadMode.ReadSchema);

                                        //Decryption code - added by Nikhil Kardale on 30/7/2007
                                        Designer.XMLEncryptor xmDecFile = new XMLEncryptor(GlobalData.loginName, GlobalData.password);
                                        GlobalData.dsAllHData = xmDecFile.ReadEncryptedXML(strPath);
                                        GlobalData.GUID = GlobalData.dsAllHData.Tables["tblUserSession"].Rows[0][0].ToString();
                                        //To Check the GUID validity.
                                        File.Delete(strPath);
                                        DeleteUserInfoFromMsterSesssionFile();
                                        int retryCount = 0;
                                        while (true)
                                        {

                                            try
                                            {
                                                GlobalData.initlizeWS();
                                                Object oGUID = HerbertMain.EnableMyMenu(GlobalData.GUID);
                                                int ret = GlobalData.HS.IsValidGUID(oGUID, null, null, null, null, false, false, false);
                                                if (ret == 0)
                                                {
                                                    //Invalid session so Go to contest selectio window.(bt_login(null,null)
                                                    throw (new Exception("Invalid Session"));
                                                    //GlobalData.IsShowContestList = true;
                                                    //GlobalData.GUID = "";
                                                    //GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                                    //this.Close();
                                                    return;
                                                }
                                                break;
                                            }
                                            catch (Exception exp)
                                            {
                                                if (exp.Message.IndexOf("Invalid Session") >= 0)
                                                {
                                                    throw (new Exception("Invalid Session"));
                                                }
                                                if (retryCount >= 3)
                                                {
                                                    break;
                                                }
                                                else
                                                    retryCount++;
                                            }
                                        }


                                    }
                                    catch (Exception exp)
                                    {
                                        if (exp.Message.IndexOf("Invalid Session") >= 0)
                                        {
                                            throw (new Exception("Invalid Session"));
                                        }
                                        else
                                            throw (new Exception("Session file corruption!"));
                                    }

                                }
                                else
                                {
                                    GlobalData.IsShowContestList = true;
                                    GlobalData.GUID = "";
                                    GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                    GlobalData.IsLoadFromFile = false;
                                    this.Close();

                                }




                            }
                            if (GlobalData.IsLoadFromFile == false)
                            {
#endif
                                iLoadtime = 0;
                                byte[][] b = GlobalData.HS.ParseData(values, oper, mode);
                                MemoryStream ms = new MemoryStream(b[0]);
                                dsCompressed.ReadXml(ms, System.Data.XmlReadMode.ReadSchema);
                                ms.Close();
                                ms = new MemoryStream(b[1]);
                                GlobalData.dsAllHData = new DataSet();
                                GlobalData.dsAllHData.ReadXmlSchema(ms);
                                ms.Close();
                                GlobalData.dsAllHData = DMPLEX(dsCompressed);
#if(SESSIONMAGEMENT)
                            }
#endif

#else
                            GlobalData.dsAllHData =  GlobalData.HS.ParseData(values,oper,mode);
#endif

#if(DLL)
							byte[][] b = GlobalData.DS.ParseData(values,oper,mode);											
							MemoryStream ms = new MemoryStream(b[0]);
							dsCompressed.ReadXml(ms, System.Data.XmlReadMode.ReadSchema);							
							ms.Close();
							ms = new MemoryStream(b[1]);
							GlobalData.dsAllHData = new DataSet();
							GlobalData.dsAllHData.ReadXmlSchema(ms);
							ms.Close();							
							GlobalData.dsAllHData = DMPLEX(dsCompressed);
							//GlobalData.dsAllHData =  GlobalData.DS.ParseData(values,oper,mode);	
#else
#if(DESIGNER)						
							byte[][] b = GlobalData.HS.ParseData(values,oper,mode);
							MemoryStream ms = new MemoryStream(b[0]);
							dsCompressed.ReadXml(ms, System.Data.XmlReadMode.ReadSchema);							
							ms.Close();
							ms = new MemoryStream(b[1]);
							GlobalData.dsAllHData = new DataSet();
							GlobalData.dsAllHData.ReadXmlSchema(ms);
							ms.Close();							
							GlobalData.dsAllHData = DMPLEX(dsCompressed);
			
							//GlobalData.dsAllHData =  GlobalData.HS.ParseData(values,oper,mode);
							debugLineCounter++; //3
#endif
#endif
#endif
# if(DESIGNER)
                            if (GlobalData.iPatternId != "-1")
                            {

                                Object iPid = DisableMyMenu(GlobalData.iPatternId, GlobalData.GUID, 1);
                                GlobalData.dsAllHData = GlobalData.HS.GetPattern(iPid, oper);
                            }
                            else
                            {
                                byte[][] b = GlobalData.HS.DParseData(values, oper, mode, oLevelId);
                                MemoryStream ms = new MemoryStream(b[0]);
                                dsCompressed.ReadXml(ms, System.Data.XmlReadMode.ReadSchema);
                                ms.Close();
                                ms = new MemoryStream(b[1]);
                                GlobalData.dsAllHData = new DataSet();
                                GlobalData.dsAllHData.ReadXmlSchema(ms);

                                ms.Close();

                                GlobalData.dsAllHData = DMPLEX(dsCompressed);
                            }
						//GlobalData.dsAllHData =  GlobalData.HS.DParseData(values,oper,mode,oLevelId);
# endif

                            if (GlobalData.IsLoadFromFile == false)
                            {
                                GlobalData.dsAllHData.Tables[0].TableName = "tblContestNUser";
                                debugLineCounter++; //4	
                                GlobalData.dsAllHData.Tables[1].TableName = "tblLevelInfoMST";
                                debugLineCounter++; //5	
                                GlobalData.dsAllHData.Tables[2].TableName = "tblLevelButtonsMST";
                                debugLineCounter++; //6	
                                GlobalData.dsAllHData.Tables[3].TableName = "tblLevelWallsMST";
                                debugLineCounter++; //7	
                                GlobalData.dsAllHData.Tables[4].TableName = "tblGameScore";
                                debugLineCounter++; //8	
                                GlobalData.dsAllHData.Tables[5].TableName = "tblGameLevelScore";
                                debugLineCounter++; //9	
                                if (GlobalData.dsAllHData.Tables.Count > 7)
                                    GlobalData.dsAllHData.Tables[6].TableName = "tblWarningTimeMsg";
                                debugLineCounter++; //10

                                DataColumn[] keys = new DataColumn[1];
                                keys[0] = GlobalData.dsAllHData.Tables[5].Columns[1];
                                GlobalData.dsAllHData.Tables[5].PrimaryKey = keys;
                                debugLineCounter++; //11
                            }
#if(CONTEST)
                            //By Rajesh
                            //To detect for the "0" levels in the contest
                            int noOfLevels = GlobalData.dsAllHData.Tables[1].Rows.Count;
                            if (noOfLevels == 0)
                            {
                                throw (new Exception("Zero levels!"));
                            }
                            //End
#endif
#if(RTDEBUG)
						strDebugLog+="###########Starting DataSet Dump in Herbert###############\n";
						for(int i = 0; i < 7; i++)
						{
							if(i != 1 && i != 2 && i != 3)
							{
								strDebugLog += "Table Name: " + GlobalData.dsAllHData.Tables[i].TableName.ToString()+"\n";
								for(int j = 0; j < GlobalData.dsAllHData.Tables[i].Rows.Count; j++)
								{
									for(int k = 0; k < GlobalData.dsAllHData.Tables[i].Columns.Count; k++)
									{
										strDebugLog +=GlobalData.dsAllHData.Tables[i].Rows[j][k].ToString() +", ";
									}
									strDebugLog += "\n";
								}
							}
						}

						strDebugLog+="###############DataSet Dump ended in Herbert##############\n";
# endif
                            break;
                        }
                        catch (Exception exp)
                        {
                            //for icprofiler
                            //MessageBox.Show(this,"Exception : " + exp.Message+ "\nStack Trace: " + exp.StackTrace + "\nInner Exception: " + exp.InnerException + "\nSource: " + exp.Source + "\nLine Counter:" + debugLineCounter.ToString());
                            if (exp.Message.IndexOf("HS1001") >= 0)
                            {
                                string message = exp.Message.Substring(exp.Message.IndexOf("HS1001"), exp.Message.IndexOf("HS1002") - exp.Message.IndexOf("HS1001"));
                                MessageBox.Show(this, message, "Login", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                dataLoaded = true;
                                this.Close();
                                return;
                            }
                            else
                                if (exp.Message.IndexOf("HS0008") > 0)
                                {
                                    blnIsValid = false;
                                    dataLoaded = true;
                                    this.Close();
                                    return;
                                }
                                else if (exp.Message.IndexOf("timed-out") > 0)
                                {
                                    RetryCount++;
                                    if (RetryCount == 3)
                                    {
                                        MessageBox.Show(this, "H0002: Unable to load data. Connection to the server timed-out. Please try launching after some time.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                        blnLoadError = true;

                                        try
                                        {
                                            sbErrorLog.Append("\n H0002: Connection to the server is timing out. ");
                                            LogErrors();
                                        }
                                        catch
                                        {
                                        }

                                        this.Close();
                                        return;
                                    }
                                }
                                else if (exp.Message.IndexOf("HS0009") > 0)
                                {
                                    RetryCount++;
                                    if (RetryCount == 3)
                                    {
                                        MessageBox.Show(this, "HS0009: This level is listed in a currently running contest. This level can not be modified.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                        blnLoadError = true;
                                        this.Close();
                                        return;
                                    }
                                }
                                else if (exp.Message.IndexOf("HS0059") > 0)
                                {
                                    RetryCount++;
                                    MessageBox.Show(this, "H0059: Contest is not yet started. Please try launching Herbert after the contest starts.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    blnLoadError = true;
                                    this.Close();
                                    return;

                                }
                                else if (exp.Message.IndexOf("HS0058") > 0)
                                {
                                    MessageBox.Show(this, "H0058: The site is undergoing maintenance. Please try again after the maintenance is over.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    blnLoadError = true;
                                    this.Close();
                                    return;
                                }
                                else if (exp.Message.IndexOf("underlying connection was closed") > 0)
                                {
                                    RetryCount++;
                                    if (RetryCount == 3)
                                    {
                                        MessageBox.Show(this, "H0003: Unable to load data. Connection failed. Please check your network connection.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                        blnLoadError = true;

                                        try
                                        {
                                            sbErrorLog.Append("\n H0003: Unable to load data. Connection failed. Please check your network connection.");
                                            LogErrors();
                                        }
                                        catch
                                        {
                                        }

                                        this.Close();
                                        return;
                                    }
                                }
#if(SESSIONMAGEMENT)
                                else if (exp.Message.IndexOf("Invalid Session") >= 0)
                                {
                                    GlobalData.IsShowContestList = true;
                                    DeleteUserInfoFromMsterSesssionFile();
                                    GlobalData.IsLoadFromFile = false;
                                    this.Close();
                                    GlobalData.GUID = "";
                                    GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                    blnLoadError = true;
                                    return;
                                }
                                else if (exp.Message.IndexOf("Session file corruption!") >= 0)
                                {
                                    MessageBox.Show(this, "H0014: Unable to load data. Session file get corrupted." + "\n", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    GlobalData.IsShowContestList = true;
                                    DeleteUserInfoFromMsterSesssionFile();
                                    this.Close();
                                    GlobalData.GUID = "";
                                    GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                    blnLoadError = true;
                                    GlobalData.IsLoadFromFile = false;
                                    this.Close();
                                    return;
                                }
#endif
                                else if (exp.Message.IndexOf("Zero levels!") >= 0)
                                {
                                    MessageBox.Show(this, "H0005: There are no levels in this contest. Please select different contest.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    blnLoadError = true;
                                    GlobalData.IsShowContestList = true;
                                    this.Close();
                                    return;
                                }
                                // added by Nikhil Kardale on 4/3/2008 for Employment Contest feature
                                else if (exp.Message.Contains("HS0060"))
                                {
                                    MessageBox.Show(this, "H0060: Unable to load data. \nYour turn for playing this contest may be over or multiple instances may have been launched.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                    this.Dispose();
                                    Application.Exit();
                                }
                                else
                                {
                                    MessageBox.Show(this, "H0004: Unable to load data. Could not launch application." + "\n" + exp.Message, "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    blnLoadError = true;
                                    try
                                    {
                                        sbErrorLog.Append("\n H0004: Exception Message: " + exp.Message);
                                        sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                        sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                        sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                        LogErrors();
                                    }
                                    catch
                                    {
                                    }
                                    this.Close();
                                    return;
                                }
                        }
                    }

#if(DLL)
				GlobalData.DS.Dispose();
				GlobalData.DS = null;
#else
                    GlobalData.HS.Dispose();
                    GlobalData.HS = null;
#endif
                    try
                    {

                        //Read User and Contest details
                        DataRow[] dr = GlobalData.dsAllHData.Tables["tblContestNUser"].Select();
                        debugLineCounter++; //12
                        try
                        {
                            // added by Nikhil Kardale on 19/03/2008 to fix issue id 10914
                            if (int.Parse(dr[0]["LimitContestEnabled"].ToString()) != 0)
                                GlobalData.isEmploymentContest = true;
                            else
                                GlobalData.isEmploymentContest = false;
                        }
                        catch
                        {
                            isErrorLogged = true;
                        }

                        try
                        {
                            isErrorLogged = ((int.Parse(dr[0]["isErrorLogged"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //13
                        }
                        catch
                        {
                            isErrorLogged = true;
                        }

                        try
                        {
                            isInternalErrorLogged = ((int.Parse(dr[0]["LogInternalErrors"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //13
                        }
                        catch
                        {
                            isInternalErrorLogged = true;
                        }

                        try
                        {
                            isUserErrorLogged = ((int.Parse(dr[0]["LogUserErrors"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //13
                        }
                        catch
                        {
                            isUserErrorLogged = true;
                        }

                        try
                        {
                            isLevelChangeLogged = ((int.Parse(dr[0]["LogLevelChanges"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //13
                        }
                        catch
                        {
                            isLevelChangeLogged = true;
                        }

                        try
                        {
                            isExceptionLogged = ((int.Parse(dr[0]["LogException"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //13
                        }
                        catch
                        {
                            isExceptionLogged = true;
                        }
                        try
                        {
                            isMismatchProbeOn = ((int.Parse(dr[0]["isMismatchProbeOn"].ToString()) == 1) ? true : false);
                            debugLineCounter++; //18
                        }
                        catch
                        {
                            isMismatchProbeOn = true;
                        }




#if(DESIGNER)
				if(GlobalData.HerbertMode == HMode.Designer)
				{
					Level.SetRoboPos(arrLevels[currentLevelIndex].curPosX/GlobalData.ZoomInZoomOut,arrLevels[currentLevelIndex].curPosY/GlobalData.ZoomInZoomOut);
					
					
					this.Height = 365;
					Level.LevelDesignData();

					this.herbertPicBox.MouseDown += new System.Windows.Forms.MouseEventHandler(this.herbertPicBox_MouseDown);
                    this.lblMsgBox.Left = 236;
                    this.lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width - 236; 
					lblScoreTxt.Visible = false;
					lblTotalScore.Visible = false;

					///Added   by Rajesh
					///comment to disable upload menu for Designer 
					///Date    6/4/2006 
					mnuUploadSolutions.Visible=false;
					///end
					
					/*==============================================================================
					 *  Added By: Vivek Balagangadharan
					 *  Description: To check the white button menu by default.
					 *  Added On: 17-Apr-2006
					 *  Special Comments: Brian: Design menu should have white button selected by default.
					 * ==============================================================================*/
					mnuWhitebttn.Checked = true;
					/*End */

				}
				//else
#endif
                        //try catch added By rajesh 30/10/06
                        try
                        {
                            TotalTimeInSecRemaining = GameInterval = int.Parse(dr[0]["TimeRemainingInSec"].ToString()) - iLoadtime;
                        }
                        catch
                        {
                            sbErrorLog.Append("LoadData: Invalid format for TimeRemainingInSec.");
                        }
                        //end

                        debugLineCounter++; //14
                        #region Silent Upload
                        GlobalData.dtCheck = DateTime.Now.AddSeconds(TotalTimeInSecRemaining);
                        #endregion
                        if (isExceptionLogged)
                        {
                            sbErrorLog.Append("\n Total time in Sec Remaining: " + TotalTimeInSecRemaining.ToString());
                        }
#if(RTDEBUG)
					strDebugLog += "StrDebugLog From Herbert exe " + "TotalTimeInSecRemaining= "+TotalTimeInSecRemaining.ToString() + "\n";
#endif

                        //MTimeInSecToStart = int.Parse(dr[0]["MTimeInSecToStart"].ToString());
                        //MTimeInSecRemainingToStart = MTimeInSecToStart;
                        //iMaintainWarn1 = int.Parse(dr[0]["pMaintainWarn1"].ToString());
                        //iMaintainWarn2 = int.Parse(dr[0]["pMaintainWarn2"].ToString());
                        //iMaintainWarn3 = int.Parse(dr[0]["pMaintainWarn3"].ToString());
                        debugLineCounter++; //15
#if(RTDEBUG)
					strDebugLog += "dbInstanceStartTime= "+dr[0]["InstanceStartTime"].ToString()+"\n";
#endif

                        DateTimeFormatInfo dfi = new DateTimeFormatInfo();
                        CultureInfo ci = new CultureInfo("en-us");
                        dfi.MonthDayPattern = "mm/dd/yy";
                        ci.DateTimeFormat = dfi;
                        startdate = InstanceStartTime = DateTime.Parse(dr[0]["InstanceStartTime"].ToString());


                        debugLineCounter++; //16

                        if (isExceptionLogged)
                        {
                            sbErrorLog.Append("\n InstanceStartTime: " + InstanceStartTime.ToString());
                        }
#if(RTDEBUG)
					strDebugLog += "InstanceStartTime= "+InstanceStartTime.ToString()+"\n";
#endif
                        GlobalData.herbertTitle = (string)dr[0]["HerbertTitle"];
#if(DESIGNER)
						GlobalData.herbertTitle="Herbert Designer";
#endif
                        debugLineCounter++; //17
                        iTimeForPollingBeforeMsg = int.Parse(dr[0]["PollingInterval"].ToString());
                        debugLineCounter++; //18
                        iMinTimeForPolling = int.Parse(dr[0]["MinTimeForPolling"].ToString());
                        debugLineCounter++; //19
                        mHBIntervalInMin = int.Parse(dr[0]["HBIntervalInMin"].ToString());
#if(CONTEST)
                        UpdateSilentSaveTime();
#endif
                        debugLineCounter++; //20
# if(CONTEST)

                        try
                        {
                            isBucketingEnabled = ((int.Parse(dr[0]["isBucketing"].ToString()) == 1) ? true : false);
                            GlobalData.reqdLevelSolvePercentage = int.Parse(dr[0]["reqdLevelSolvePercentage"].ToString());
                            GlobalData.numLevelsPerBucket = int.Parse(dr[0]["numLevelsPerBucket"].ToString());
                            if (GlobalData.numLevelsPerBucket == 0 || GlobalData.reqdLevelSolvePercentage == 0)
                            {
                                isBucketingEnabled = false;
                            }
                        }
                        catch
                        {
                            isBucketingEnabled = false;
                        }
#if(CONTEST)
                        //added by NikhilK on 5/6/2007 for enabling or disabing the timer functionality
                        try
                        {
                            GlobalData.iTimerEnable = int.Parse(dr[0]["IsTimerEnabled"].ToString());
                        }
                        catch
                        {
                            GlobalData.iTimerEnable = -1;
                        }
#endif
                        debugLineCounter++; //21
                        if (isExceptionLogged)
                        {
                            sbErrorLog.Append("\n Bucketing Enabled?: " + isBucketingEnabled.ToString());
                        }
#endif
                        //karthikeyan for checking time interval 26052005 
                        if (TotalTimeInSecRemaining < 0)
                        {
                            //GameTimer.Enabled = false;
                            TimeOver = true;
                            dataLoaded = true;
                            blnAfterTimeOver = true;
                            this.Close();
                            return;
                        }
                        else
                        {
                            GlobalData.ContestantId = int.Parse(dr[0]["ContestantId"].ToString());
                            debugLineCounter++; //22
                            Level.scoringLogic = int.Parse(dr[0]["NewScoringLogic"].ToString());
                            debugLineCounter++; //23
                            isSiteDefaultUserId = int.Parse(dr[0]["IsSiteDefaultUserId"].ToString());
                            debugLineCounter++; //24

                            if (isExceptionLogged)
                            {
                                sbErrorLog.Append("\n Contestant Id: " + GlobalData.ContestantId.ToString());
                            }
                            dr = GlobalData.dsAllHData.Tables["tblGameScore"].Select();
                            debugLineCounter++; //25

                            if (dr.Length != 0)
                            {
                                Level.totalScore = int.Parse(dr[0]["TotalScore"].ToString());
                                debugLineCounter++; //26

                                if (isExceptionLogged)
                                {
                                    sbErrorLog.Append("\n Total Score: " + Level.totalScore.ToString());
                                }

                                OpenLevel = int.Parse(dr[0]["OpenLevel"].ToString());
                                debugLineCounter++; //27

                                mnuPath.Checked = ((int.Parse(dr[0]["PathOnOff"].ToString()) == 1) ? true : false);
                                PathOn = mnuPath.Checked;
                                debugLineCounter++; //28

                                mnuSmoothScroll.Checked = bool.Parse(dr[0]["SmoothScrollOnOff"].ToString());
                                isSmoothScrollEnabled = mnuSmoothScroll.Checked;
                                debugLineCounter++; //29

                                if (PathOn)
                                    btPath.FlatStyle = FlatStyle.Flat;
                                else
                                    btPath.FlatStyle = FlatStyle.Standard;
                                debugLineCounter++; //30

                                mnuTrace.Checked = ((int.Parse(dr[0]["TraceOnOff"].ToString()) == 1) ? true : false);

                                //Added by rajesh
                                //Date 8/8/06
                                //Issue :3305, to restore toolBar state
                                if (GlobalData.HerbertMode != HMode.Tutorial && isSiteDefaultUserId == 0)
                                {
                                    mnuToolBar.Checked = ((int.Parse(dr[0]["ToolBarOnOff"].ToString()) == 1) ? false : true);
                                }
                                else
                                {
                                    mnuToolBar.Checked = false;
                                }
                                traceOn = mnuTrace.Checked;
                                debugLineCounter++; //31

                                if (traceOn)
                                    btTrace.FlatStyle = FlatStyle.Flat;
                                else
                                    btTrace.FlatStyle = FlatStyle.Standard;
                                debugLineCounter++; //32

                                //Vijay, check
                                ScoreId = int.Parse(dr[0]["ScoreId"].ToString());
                                debugLineCounter++; //33

                                //removed, vijay
                                TotalGameTimeInMinSpent = int.Parse(dr[0]["totTimeInMin"].ToString());
                                debugLineCounter++; //34
                            }
                            //Added By Rajesh
                            //For Guest User
                            //Date 11/09/06
                            if (isSiteDefaultUserId == 1)
                            {
                                mnuToolBar.Checked = false;
#if(CONTEST)
                                btRestore.Enabled = false;
                                mnuRestoreBest.Enabled = false;
                                mnuSeperator2Edit.Enabled = false;
#endif
                            }

                            try
                            {
                                MaintanenceData();
                            }
                            catch { }
                            debugLineCounter++; //35
                        }

                        dr = null;
                        // save images

                    }
                    catch (Exception exp)
                    {
                        MessageBox.Show(this, "H0015: Unable to load data. Could not launch application.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        blnLoadError = true;
                        if (isExceptionLogged)
                        {
                            try
                            {
                                sbErrorLog.Append("\n H0015: Exception Message: " + exp.Message);
                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException);
                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                LogErrors();
                            }
                            catch
                            {
                            }
                        }
                        this.Close();
                        return;
                    }
                }
                try
                {
                    if (GlobalData.HerbertMode != HMode.Designer)
                    {
                        mnuMainDesign.Visible = false;

                        //for non-guest users, menu for uploading solutions should be visible.
                        if (isSiteDefaultUserId == 0)
                            mnuUploadSolutions.Visible = true;
                        if (GlobalData.HerbertMode == HMode.Tutorial)
                        {
                            mnuUploadSolutions.Visible = false;
#if(CONTEST)
                            btRestore.Enabled = false;
                            mnuSeperator2Edit.Enabled = false;
                            mnuRestoreBest.Enabled = false;
#endif
                        }
                    }
                    debugLineCounter++; //36


                    //karthikeyan for checking time interval 26052005 
                    arrLevels = Level.BuildAllLevelData();
                    debugLineCounter++; //37
                    //pt = Level.getDotPointsDB(Level.GetLevelId(3), 1);
                    //lock (lblTotalLevels)
                    //{
                    lblTotalLevels.Text = (arrLevels.Length - 1).ToString();//rename. add  prefix lbl.
                    lblTotalLevels.Left = lblLevelsTxt.Left - lblTotalLevels.Width;
                    //}
                    lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
                    lblMaxChars.Text = "(Max " + arrLevels[currentLevelIndex].getMaxChar(currentLevelId).ToString() + ")";
                    lblLevelNo.Text = currentLevelIndex.ToString();

                    debugLineCounter++; //38

                    for (int i = 1; i < arrLevels.Length; i++)
                        iSumOfAllLevelPoints += Level.getLevelPoints(i);
                    debugLineCounter++; //39
#if(DESIGNER)
			arrLevels[0].HerbertX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X;
			arrLevels[0].HerbertY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y;
#endif

# if(CONTEST)
                    if (GlobalData.HerbertMode != HMode.Tutorial)
                    {
                        lblTotalScore.Text = Level.totalScore.ToString() + "/" + iSumOfAllLevelPoints.ToString();
                    }
                    debugLineCounter++; //40
#endif
                    //			}

                    if (GlobalData.HerbertMode != HMode.Tutorial)
                    {
                        // by Pavan to implemenet bucketing

                        if (isBucketingEnabled)
                        {
                            #region Bucketing By NikhilK
                            ///TotalSolvedLevels = 0;
                            //BucketingLevels = 1;:ToDO
                            BucketingLevels = GlobalData.reqdLevelSolvePercentage;
                            //:ToDO
                            //for (int i = 1; i < arrLevels.Length; i++)
                            //{
                            //    if (arrLevels[i].IsLevelFinishedPersistant)
                            //        TotalSolvedLevels++;
                            //}
                            //end
                            int curBucket = 0;
                            int curBucketSolvedLevels = 0;
                            for (int i = 1; i < arrLevels.Length; i++)
                            {
                                //ToDO
                                if (((i - 1) % GlobalData.numLevelsPerBucket) == 0)
                                {
                                    if (curBucketSolvedLevels >= GlobalData.reqdLevelSolvePercentage || curBucket == 0)
                                    {
                                        curBucket++;
                                        curBucketSolvedLevels = 0;
                                    }
                                    else
                                    {//New bucket, but no of level solved in the lest last levels<no req levls to be solved.
                                        break;
                                    }
                                }
                                //End
                                if (arrLevels[i].IsLevelFinishedPersistant)
                                {
                                    TotalSolvedLevels++;
                                    curBucketSolvedLevels++;//To count the no of Levels solved in the Current level.
                                }
                            }
                            int iCurUnsolvedBucket = curBucket;
                            // added by NikhilK on 25/10/2007
                            GlobalData.currentUnsolvedBucket = curBucket;
                            //OpenLevel = 3;
                            if (iCurUnsolvedBucket * GlobalData.numLevelsPerBucket + 1 <= arrLevels.Length)
                                LevelChangeBar.Maximum = (iCurUnsolvedBucket * GlobalData.numLevelsPerBucket + 1) * 10;
                            else
                                LevelChangeBar.Maximum = arrLevels.Length * 10;

                            ///end
                            #endregion
                        }
                        else
                        {
#if(CONTEST)
                            LevelChangeBar.Maximum = arrLevels.Length * 10;
#endif

                            /*==============================================================================
							 *  Added By : Vivek Balagangadharan
							 *  Description : Added to solve the issue of scrollbar not scrolling on level 0,
							 *				  with no other levels.
							 *  Added On : 18-Apr-2006
							 * ==============================================================================*/
# if(DESIGNER)
							if(arrLevels.Length == 1)
							{
								blnSkeepLevel = true;
								blnScrollMouseRelease = true;
								//LevelChangeBar.Value = 10;
								LevelChangeBar.Maximum = arrLevels.Length*10;
							}
							else
							{
								LevelChangeBar.Maximum = arrLevels.Length*10;
							}
#endif
                        }
                        //LevelChangeBar.Maximum = arrLevels.Length*10;
                        debugLineCounter++; //41
# if(DESIGNER)
				//add preprocessor
				//if(GlobalData.HerbertMode == HMode.Designer)
				//TxtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();
				txtLevelPoints.Enabled = true;
				
# endif
                    }
                    else
                    {
                        //Added By Rajesh
                        //Date: 11-09-06
                        //For tutorial
                        mnuToolBar.Checked = false;
#if(CONTEST)
                        btRestore.Enabled = false;
                        mnuSeperator2Edit.Enabled = false;
                        mnuRestoreBest.Enabled = false;
#endif
                    }
                    //			else
                    //				TxtLevelPoints.Text = "0";

                    //set variables to draw path if path is on.
                    arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                    arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
                    this.Text = GlobalData.herbertTitle;
                    debugLineCounter++; //42

                    if (GlobalData.HerbertMode != HMode.Tutorial)
                    {
                        //PicBAnimate.Visible = false;
                        //pnlLoad.Visible = false;
                        //startupfrm.Close();
                        //pbStartUp.Visible=false;
                        lblLoading.Visible = false;
#if(CONTEST)
                        if (isSiteDefaultUserId != 1 && GlobalData.HerbertMode == HMode.Contest)
                        {
                            btRestore.Enabled = true;
                            mnuSeperator2Edit.Enabled = true;
                            mnuRestoreBest.Enabled = true;
                        }
#endif

                        LevelChangeBar.Enabled = true;
                        txtCodeEditor.ReadOnly = false;
                        debugLineCounter++; //47

                        //				if(ScoreId != -1)
                        //					mnuUploadSolutions.Visible = true;

                        //				Thread tDataLoaded = new Thread(new ThreadStart(setDataLoaded));
                        //				tDataLoaded.Priority = ThreadPriority.Normal;
                        //				tDataLoaded.Start();

                        try
                        {

                            if (OpenLevel != 0 && GlobalData.HerbertMode != HMode.Designer)
                            {
                                blnSkeepLevel = true;
                                blnScrollMouseRelease = true;
                                LevelChangeBar.Value = OpenLevel * 10;
                            }
                            else if (OpenLevel == 0 && GlobalData.HerbertMode != HMode.Designer && arrLevels.Length > 0)
                            {
                                blnSkeepLevel = true;
                                blnScrollMouseRelease = true;
                                LevelChangeBar.Value = 10;
                            }
                            debugLineCounter++; //44

                            if (isExceptionLogged)
                            {
                                sbErrorLog.Append("\n On load, scrolled to level: " + OpenLevel.ToString());
                            }

                            /*==============================================================================
							 *  Modified By : Vivek Balagangadharan
							 *  Description : iLevelId is a comma separated list of levels. -1 is its default value.
							 *  Modified On : 10-Apr-2006
							 *  Special Comments : iLevelId was an int type initially
							 * ==============================================================================*/
                            if (GlobalData.HerbertMode == HMode.Designer && GlobalData.iLevelId != "-1")
                            {
                                blnSkeepLevel = true;
                                blnScrollMouseRelease = true;
                                LevelChangeBar.Value = 10;
                            }
                        }
                        catch
                        {
                            //blnExp = true;
                            //MessageBox.Show(this, exp.Message + " Line="+debugLineCounter.ToString(), "Herbert Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        }
                        finally
                        {
                            //							if(!blnExp)
                            //								Monitor.Exit(objMonitorLevelChange);
                        }

                        debugLineCounter++; //45
                    }
                    else
                    {
#if(CONTEST)
                        btRestore.Enabled = false;
                        mnuSeperator2Edit.Enabled = false;
                        mnuRestoreBest.Enabled = false;
#endif
                    }
                    DispMessage("Good Luck!");
                    mnuMainFile.Enabled = true;
                    mnuMainEdit.Enabled = true;
                    mnuMainOptions.Enabled = true;
                    mnuMainRun.Enabled = true;
                    //To disable for guest user.
                    if (isSiteDefaultUserId == 1)
                        mnuUploadSolutions.Visible = false;
#if(DESIGNER)
					mnuMainDesign.Enabled= true;
#endif
#if(CONTEST)
                    //mnuMainDesign.Visible = false;
#endif
                    mnuMainHelp.Enabled = true;

                    /*==============================================================================
                    *  Modified By : Vivek Balagangadharan
                    *  Description : Locking the toolbar panel to avoid "object in use elsewhere" error.
                    *  Modified On : 19-Apr-2006
                    * ==============================================================================*/
                    //lock(pnlToolBar)
                    //{
                    //    if(!pnlToolBar.Enabled)
                    //    {
                    //        pnlToolBar.Enabled = true;
                    //    }
                    //}
                    debugLineCounter++; //46

#if(DESIGNER)
			mnuMainDesign.Visible = true;
#endif
                    //this.MaximizeBox = false;

                    //			if(GlobalData.HerbertMode == HMode.Contest)
                    //			{
                    //				GameTimer.Enabled = true;
                    //				LevelTimer.Enabled = true;
                    //			}
                    //if(GlobalData.HerbertMode == HMode.Contest)


                    dataLoaded = true;
                    debugLineCounter++; //41

                    if (blnCloseInitiated)
                    {
                        this.Close();
                        return;
                    }
                }
                catch (Exception exp)
                {
                    MessageBox.Show(this, "H0016: Unable to load data. Could not launch application." + exp.Message + "\n" + exp.Source + "\n" + exp.StackTrace, "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    blnLoadError = true;
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n H0016: Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
                    this.Close();
                    return;
                }
                //Monitor.Exit(objMonitorLevelChange);               
            }
            catch (Exception exp)
            {

                //blnExp = true;
                //Changed By Rajesh :: 28/06/06
                //if (this.InvokeRequired)
                //{
                //    MessagBoxtCallback delMsgBox = new MessagBoxtCallback(DisplayMessage);
                //    this.Invoke(delMsgBox,new object[] {exp.Message + " Line=" + debugLineCounter.ToString(),"Herbert Error" });
                //}
                //else
                //{
                sbErrorLog.Append("\nIn LOADDATA:: Line=" + debugLineCounter.ToString() + exp.Message + "\n");

#if(DEBUG)
                //MessageBox.Show(this, exp.Message + " Line=" + debugLineCounter.ToString(), "Herbert Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
#endif
                // }
            }
            finally
            {
                //if(!blnExp)
                //Monitor.Exit(objMonitorLevelChange);
#if(CONTEST)
                //added by NikhilK on 5/6/2007 hide timer in Tutorial mode.
                if (GlobalData.HerbertMode == HMode.Tutorial || GlobalData.iTimerEnable == 0 || GlobalData.IsLoadFromFile == true)
                {
                    lblTimer.Visible = false;
                    lblTimeLeft.Visible = false;
                    // added by NikhilK on 29/10/2007 for toggling timer visibility
                    try
                    {
                        mnuTimer.Visible = false;
                        GlobalData.isTimerToggleVisible = false;
                        lblMsgBox.Width = 495;
                    }
                    catch { }
                    lblMsgBox.Width = 495;
                }
                // added by Nikhil Kardale on 4/7/2007 to make timer invisible while loading data (to fix issue no. 7803)
                else
                {
                    lblTimer.Visible = true;
                    lblTimeLeft.Visible = true;
                    // added by NikhilK on 29/10/2007 for toggling timer visibility
                    try
                    {
                        mnuTimer.Visible = true;
                        GlobalData.isTimerToggleVisible = true;
                        lblMsgBox.Width = 316;
                    }
                    catch { }
                    lblMsgBox.Width = 316;
                }
#endif
                this.HerbertBoard.Refresh();
                this.herbertPicBox.Refresh();
                this.Refresh();
                dataLoaded = true;
                //Added by rajesh
                //Date 8/8/06
                //Issue :3305, to restore toolBar state
                lock (pnlToolBar)
                {
                    mnuToolBar_Click(null, null);
                    if (!pnlToolBar.Enabled)
                    {
                        pnlToolBar.Enabled = true;
                    }

                }
            }
        }


#if(CONTEST)
        /// <summary>
        /// updates the silent save time.
        /// </summary>
        private void UpdateSilentSaveTime()
        {
            TotalTimeInSilentSaveSecRemaining = TotalTimeInSecRemaining - GetRandomDelay((iMinTimeForPolling + 5) * 60, (iTimeForPollingBeforeMsg + 5) * 60);
        }
#endif


        private void MaintanenceData()
        {
            //Changes for the Maintanence warning and pooling.
            DataRow[] dr = GlobalData.dsAllHData.Tables["tblWarningTimeMsg"].Select();
            iNumWarningMsg = dr.Length;
            if (dr.Length != 0)
            {
                iTimeRemainingForWarningX = new int[iNumWarningMsg];
                //iValidityOfWarningX = new int[iNumWarningMsg];
                strWarningMsgX = new string[iNumWarningMsg];
                isForceClose = new bool[iNumWarningMsg];
                blnToDoPooling = new bool[iNumWarningMsg];
                blnMsgShown = new bool[iNumWarningMsg];
                iPoolingRandTime = new int[iNumWarningMsg];
                getRandomNo(iTimeForPollingBeforeMsg);
                for (int i = 0; i < iNumWarningMsg; i++)
                {
                    iTimeRemainingForWarningX[i] = Int32.Parse(dr[i]["MsgDateTime"].ToString());
                    ////Console.WriteLine(i.ToString() + " iTimeRemainingForWarningX[i] " + iTimeRemainingForWarningX[i].ToString());
                    //iValidityOfWarningX[i] = (int)dr[i]["Validity"];
                    ////Console.WriteLine(i.ToString() + " iValidityOfWarningX[i] " + iValidityOfWarningX[i].ToString());
                    strWarningMsgX[i] = (string)dr[i]["WarningMsg"];
                    ////Console.WriteLine(i.ToString() + " strWarningMsgX[i] " + strWarningMsgX[i].ToString());
                    isForceClose[i] = bool.Parse(dr[i]["isForceClose"].ToString());
                    blnToDoPooling[i] = true;
                    blnMsgShown[i] = true;
                    iPoolingRandTime[i] = iTimeForPollingBeforeMsg - rd.Next(iTimeForPollingBeforeMsg - iMinTimeForPolling);
                    ////Console.WriteLine(i.ToString() + " iPoolingRandTime[i] " + iPoolingRandTime[i].ToString());
                }
            }
            dr = null;
        }


        /// <summary>
        /// Polls the database for maintenance data.
        /// </summary>
        private void PoolForMaintData()
        {
            ///TODO: Silent upload in polling function
            #region Silent Upload functionality

            //			if(GlobalData.dtCheck>DateTime.Parse("1/1/2006")&&GlobalData.dtCheck<DateTime.Parse("1/1/2010"))
            //			{
            //				TimeSpan ts = GlobalData.dtCheck.Subtract(DateTime.Now);
            //				if(ts.Minutes<30)
            //				{
            //					//SaveDataInDB(false);
            //					UploadSolutionsInDB(false);
            //				}
            //			}
            #endregion
            if (rd == null)
            {
                getRandomNo(iTimeForPollingBeforeMsg);
            }
            int x = iNumWarningMsg;
            int iRetryCount = 0;
            GlobalData.initlizeWS();
            if (GlobalData.GUID != null)
            {
                Object oper = EnableMyMenu(GlobalData.GUID);
                Object values = DisableMyMenu(plain, GlobalData.GUID, 1);
                while (true)
                {
                    try
                    {
                        //DataSet ds = GlobalData.HS.UpdateInfo(values, oper);
                        DataSet ds = null;

#if(DLL)
					ds = GlobalData.DS.UpdateInfo(values, oper);
#else
                        ds = GlobalData.HS.UpdateInfo(values, oper);
#endif

                        DataRow[] dr = ds.Tables[0].Select();
                        if (dr.Length != 0)
                        {
                            if (x != dr.Length)
                            {
                                iTimeRemainingForWarningX = new int[dr.Length];
                                //iValidityOfWarningX = new int[dr.Length];
                                strWarningMsgX = new string[dr.Length];
                                isForceClose = new bool[dr.Length];
                                blnToDoPooling = new bool[dr.Length];
                                blnMsgShown = new bool[dr.Length];
                                iPoolingRandTime = new int[dr.Length];
                            }
                            iNumWarningMsg = dr.Length;
                            for (int i = 0; i < iNumWarningMsg; i++)
                            {
                                //iValidityOfWarningX[i] = (int)dr[i]["Validity"];
                                strWarningMsgX[i] = (string)dr[i]["WarningMsg"];
                                isForceClose[i] = bool.Parse(dr[i]["isForceClose"].ToString());
                                //							if(Math.Abs(iTimeRemainingForWarningX[i] - (int)dr[i]["MsgDateTime"]) > 3)
                                if ((int)dr[i]["MsgDateTime"] > 180)
                                    blnToDoPooling[i] = true;
                                iTimeRemainingForWarningX[i] = (int)dr[i]["MsgDateTime"];

                                if (x != iNumWarningMsg)
                                {
                                    iPoolingRandTime[i] = iTimeForPollingBeforeMsg - rd.Next(iTimeForPollingBeforeMsg - iMinTimeForPolling);
                                    ////Console.WriteLine(i.ToString() + " iPoolingRandTime[i] " + iPoolingRandTime[i].ToString());
                                    blnMsgShown[i] = true;
                                }
                            }
                        }
                        dr = ds.Tables[1].Select();
                        //commented by vivek on 13th June
                        //TotalTimeInSecRemaining += Math.Abs(GameInterval - (int)dr[0]["TimeRemainingInSec"]);

                        TotalTimeInSecRemaining = (int)dr[0]["TimeRemainingInSec"];
                        GameInterval = (int)dr[0]["TimeRemainingInSec"];
                        blnTimeIntervalChanged = true;
                        iTimeForPollingBeforeMsg = (int)dr[0]["PollingInterval"];
                        iMinTimeForPolling = (int)dr[0]["MinTimeForPolling"];
                        mHBIntervalInMin = (int)dr[0]["HBIntervalInMin"];
#if(CONTEST)
                        UpdateSilentSaveTime();
#endif
                        //MTimeInSecRemainingToStart = (int) dr[0]["MTimeInSecToStart"];
                        dr = null;
                        break;
                    }
                    catch
                    {
                        if (iRetryCount == 3)
                        {
#if(ERRORLOG)
						try
						{
							GlobalData.initlizeWS(); //try initializing and log error
							//Object oper = EnableMyMenu(GlobalData.GUID);
							Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
							Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
							GlobalData.HS.DisplayInfo(IdContestant,oper,error );
						}
						catch{}
#endif
                            break;
                        }
                        else
                            iRetryCount++;
                    }
                }
                //GlobalData.HS = null;
#if(DLL)
			GlobalData.DS = null;			
#else
                GlobalData.HS = null;
#endif
                blnPooling = false;
            }
            ////Console.WriteLine( "Polling ended");

        }


        /// <summary>
        /// Gets the operating system information.
        /// </summary>
        /// <returns></returns>
        public static string GetOperationSystemInformation()
        {
            System.OperatingSystem m_os = System.Environment.OSVersion;
            string m_osName = "Unknown";
            switch (m_os.Platform)
            {
                case System.PlatformID.Win32Windows:
                    switch (m_os.Version.Minor)
                    {
                        case 0: m_osName = "Windows 95";
                            break;
                        case 10: m_osName = "Windows 98";
                            break;
                        case 90: m_osName = "Windows ME";
                            break;
                    }
                    break;
                case System.PlatformID.Win32NT:
                    switch (m_os.Version.Major)
                    {
                        case 3: m_osName = "Windows NT 3.51";
                            break;
                        case 4: m_osName = "Windows NT";
                            break;
                        case 5: if (m_os.Version.Minor == 0)
                                m_osName = "Windows 2000";
                            else if (m_os.Version.Minor == 1)
                                m_osName = "Windows XP";
                            else if (m_os.Version.Minor == 2)
                                m_osName = "Windows Server 2003";
                            break;
                        case 6: m_osName = "Longhorn";
                            break;
                    }
                    break;
            }
            return m_osName + "," + m_os.Version.ToString();
        }


        /// <summary>
        /// Get Images from pictureboxes
        /// </summary>
        private void getImages()
        {
#if (EXCEPTION)
            try
            {
#endif
                //get the images from pictureboxes available on the
                //board. this method is used because on NDT application
                //file access is difficult.
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                {
                    arrHrbtImage[0] = new Bitmap(pbHrbtStanding.Image);
                    //arrHrbtImage[0].Save("pbHrbtStanding_ZOOMOUT.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    arrHrbtImage[1] = new Bitmap(pbHrbtLeftLeg.Image);
                    //arrHrbtImage[1].Save("pbHrbtLeftLeg_ZOOMOUT.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    arrHrbtImage[2] = new Bitmap(pbHrbtRightLeg.Image);
                    //arrHrbtImage[2].Save("pbHrbtRightLeg_ZOOMOUT.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    img45 = new Bitmap(Herbert45.Image);
                    //img45.Save("Herbert45_ZOOMOUT.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    img_45 = new Bitmap(Herbert_45.Image);
                    //img_45.Save("Herbert_45_ZOOMOUT.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    imgEyeClose = new Bitmap(StandingEyeClosed.Image);
                    //imgEyeClose.Save("StandingEyeClosed.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);

                }
                else
                {
                    arrHrbtImage[0] = new Bitmap(pbHrbtStandingZOOMIN.Image);
                    //arrHrbtImage[0].Save("pbHrbtStandingZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    arrHrbtImage[1] = new Bitmap(pbHrbtLeftLegZOOMIN.Image);
                    //arrHrbtImage[1].Save("pbHrbtLeftLegZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    arrHrbtImage[2] = new Bitmap(pbHrbtRightLegZOOMIN.Image);
                    //arrHrbtImage[2].Save("pbHrbtRightLegZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    img45 = new Bitmap(Herbert45ZOOMIN.Image);
                    //img45.Save("Herbert45ZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    img_45 = new Bitmap(Herbert_45ZOOMIN.Image);
                    //img_45.Save("Herbert_45ZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                    imgEyeClose = new Bitmap(StandingEyeClosedZOOMIN.Image);
                    //imgEyeClose.Save("StandingEyeClosedZOOMIN.jpeg",System.Drawing.Imaging.ImageFormat.Jpeg);
                }

#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(e.Message + ", getImages, 11");
            }
#endif
        }


        /// <summary>
        /// (Pavan's comments) This function is used to encrypt the password. 
        ///						Gets plain text and returns the cipher text.
        ///						this is done to send data to webservice in the encrypted form. 
        /// </summary>
        /// <param name="Val"></param>
        /// <returns></returns>
        internal static Object EnableMyMenu(Object Val)
        {
            string passPhrase = "herbert";        // can be any string
            string saltValue = "s@1tV@l@e";        // can be any string
            string hashAlgorithm = "SHA1";             // can be "MD5"
            int passwordIterations = 10;                  // can be any number
            string initVector = "@1B2c3E4k5F6g7H8"; // must be 16 bytes
            int keySize = 192;                // can be 192 or 128
            byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
            byte[] plainTextBytes = Encoding.UTF8.GetBytes(Val.ToString());
            PasswordDeriveBytes password = new PasswordDeriveBytes(
                passPhrase,
                saltValueBytes,
                hashAlgorithm,
                passwordIterations);
            byte[] keyBytes = password.GetBytes(keySize / 8);
            RijndaelManaged symmetricKey = new RijndaelManaged();

            symmetricKey.Mode = CipherMode.CBC;

            ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                keyBytes,
                initVectorBytes);

            MemoryStream memoryStream = new MemoryStream();

            CryptoStream cryptoStream = new CryptoStream(memoryStream,
                encryptor,
                CryptoStreamMode.Write);

            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

            cryptoStream.FlushFinalBlock();

            byte[] cipherTextBytes = memoryStream.ToArray();

            memoryStream.Close();
            cryptoStream.Close();

            string cipherText = Convert.ToBase64String(cipherTextBytes);

            return cipherText;

        }


        /// <summary>
        /// (Pavan's comments) This function is used to dycrypt the password. 
        ///						Gets cipher text and returns the plain text.
        ///						this is done to dycrypt data received from webservice.
        /// </summary>
        /// <param name="plain"></param>
        /// <param name="GUID"></param>
        /// <param name="funcVal"></param>
        /// <returns></returns>
        private Object DisableMyMenu(Object plain, Object GUID, int funcVal)
        {
            //			string   passPhrase         = "herbert";        // can be any string
            //			string   saltValue          = "s@1tV@lue";        // can be any string
            //			string   hashAlgorithm      = "SHA1";             // can be "MD5"
            //			int      passwordIterations = 6;                  // can be any number
            //			string   initVector         = "@1B2c3D4e5F6g7H8"; // must be 16 bytes
            //			int      keySize            = 192;                // can be 192 or 128
            string passPhrase = GUID.ToString();        // can be any string
            string saltValue = "";
            string hashAlgorithm = "";
            string initVector = "@1B2c3D4e5F6g7H8"; // must be 16 bytes
            int keySize = 192;                // can be 192 or 128
            int passwordIterations = 0;
            if (funcVal == 1)
            {
                //string   saltValue          = "s@1tV@lue";        // can be any string
                saltValue = GUID.ToString() + "Function1";        // can be any string
                hashAlgorithm = "SHA1";             // can be "MD5"
                passwordIterations = 10;                  // can be any number
            }
            else if (funcVal == 2)
            {
                saltValue = GUID.ToString() + "Function2";        // can be any string
                hashAlgorithm = "MD5";             // can be "MD5"
                passwordIterations = 15;                  // can be any number
            }
            byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
            byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);
            byte[] plainTextBytes = Encoding.UTF8.GetBytes(plain.ToString());
            PasswordDeriveBytes password = new PasswordDeriveBytes(
                passPhrase,
                saltValueBytes,
                hashAlgorithm,
                passwordIterations);
            byte[] keyBytes = password.GetBytes(keySize / 8);
            RijndaelManaged symmetricKey = new RijndaelManaged();

            symmetricKey.Mode = CipherMode.CBC;

            ICryptoTransform encryptor = symmetricKey.CreateEncryptor(
                keyBytes,
                initVectorBytes);

            MemoryStream memoryStream = new MemoryStream();

            CryptoStream cryptoStream = new CryptoStream(memoryStream,
                encryptor,
                CryptoStreamMode.Write);

            cryptoStream.Write(plainTextBytes, 0, plainTextBytes.Length);

            cryptoStream.FlushFinalBlock();

            byte[] cipherTextBytes = memoryStream.ToArray();

            memoryStream.Close();
            cryptoStream.Close();

            string cipherText = Convert.ToBase64String(cipherTextBytes);

            return cipherText;


        }


        private Object Decrypt(Object cipherText, Object GUID, int funcVal)
        {
            string plainText = "";
            try
            {
                //string   passPhrase         = "herbert";        // can be any string
                string passPhrase = GUID.ToString();        // can be any string
                string saltValue = "";
                string hashAlgorithm = "";
                int passwordIterations = 0;
                if (funcVal == 1)
                {
                    //string   saltValue          = "s@1tV@lue";        // can be any string
                    saltValue = GUID.ToString() + "Function1";        // can be any string
                    hashAlgorithm = "SHA1";             // can be "MD5"
                    passwordIterations = 10;                  // can be any number
                }
                else if (funcVal == 2)
                {
                    saltValue = GUID.ToString() + "Function2";        // can be any string
                    hashAlgorithm = "MD5";             // can be "MD5"
                    passwordIterations = 15;                  // can be any number
                }
                string initVector = "@1B2c3D4e5F6g7H8"; // must be 16 bytes
                int keySize = 192;                // can be 192 or 128


                byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
                byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);


                byte[] cipherTextBytes = Convert.FromBase64String(cipherText.ToString());

                PasswordDeriveBytes password = new PasswordDeriveBytes(
                    passPhrase,
                    saltValueBytes,
                    hashAlgorithm,
                    passwordIterations);

                byte[] keyBytes = password.GetBytes(keySize / 8);

                RijndaelManaged symmetricKey = new RijndaelManaged();

                symmetricKey.Mode = CipherMode.CBC;

                ICryptoTransform decryptor = symmetricKey.CreateDecryptor(
                    keyBytes,
                    initVectorBytes);

                MemoryStream memoryStream = new MemoryStream(cipherTextBytes);

                CryptoStream cryptoStream = new CryptoStream(memoryStream,
                    decryptor,
                    CryptoStreamMode.Read);

                byte[] plainTextBytes = new byte[cipherTextBytes.Length];

                int decryptedByteCount = cryptoStream.Read(plainTextBytes,
                    0,
                    plainTextBytes.Length);

                memoryStream.Close();
                cryptoStream.Close();

                plainText = Encoding.UTF8.GetString(plainTextBytes,
                    0,
                    decryptedByteCount);

                return plainText;
            }
            catch (Exception exp)
            {
                //				strLog.Append();
                throw new Exception("H0013: " + exp.Message + "\ncipherText = " + cipherText.ToString() + ", GUID = " + GUID.ToString() + ", funcVal = " + funcVal.ToString() + ", Plain text = " + plainText + "\n");

            }
        }


        /// <summary>
        /// Decrypts the GUID.
        /// </summary>
        /// <param name="GUID">The GUID.</param>
        /// <returns></returns>
        private Object DecryptGUID(Object GUID)
        {
            try
            {
                string passPhrase = "herbert";        // can be any string
                string saltValue = "s@1tV@l@e";        // can be any string
                string hashAlgorithm = "SHA1";             // can be "MD5"
                int passwordIterations = 10;                  // can be any number
                string initVector = "@1B2c3E4k5F6g7H8"; // must be 16 bytes
                int keySize = 192;                // can be 192 or 128
                byte[] initVectorBytes = Encoding.ASCII.GetBytes(initVector);
                byte[] saltValueBytes = Encoding.ASCII.GetBytes(saltValue);


                byte[] cipherTextBytes = Convert.FromBase64String(GUID.ToString());

                PasswordDeriveBytes password = new PasswordDeriveBytes(
                    passPhrase,
                    saltValueBytes,
                    hashAlgorithm,
                    passwordIterations);

                byte[] keyBytes = password.GetBytes(keySize / 8);

                RijndaelManaged symmetricKey = new RijndaelManaged();

                symmetricKey.Mode = CipherMode.CBC;

                ICryptoTransform decryptor = symmetricKey.CreateDecryptor(
                    keyBytes,
                    initVectorBytes);

                MemoryStream memoryStream = new MemoryStream(cipherTextBytes);

                CryptoStream cryptoStream = new CryptoStream(memoryStream,
                    decryptor,
                    CryptoStreamMode.Read);

                byte[] plainTextBytes = new byte[cipherTextBytes.Length];

                int decryptedByteCount = cryptoStream.Read(plainTextBytes,
                    0,
                    plainTextBytes.Length);

                memoryStream.Close();
                cryptoStream.Close();

                string plainText = Encoding.UTF8.GetString(plainTextBytes,
                    0,
                    decryptedByteCount);

                return plainText;
            }
            catch
            {
                //				strLog.Append("GUID = " + GUID.ToString());
                throw new Exception("H0014: " + "\nGUID = " + GUID.ToString() + "\n");
            }
        }


        /// <summary>
        /// Rotates the images.
        /// </summary>
        private void RotateImages(int iCurDir)
        {
            switch (iCurDir)
            {
                case 0:
                    break;
                case 1:
                    try
                    {
                        //lock(arrHrbtImage[0])
                        {
                            arrHrbtImage[0].RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[1])
                        {
                            arrHrbtImage[1].RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[2])
                        {
                            arrHrbtImage[2].RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img_45)
                        {
                            img_45.RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img45)
                        {
                            img45.RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(imgEyeClose)
                        {
                            imgEyeClose.RotateFlip(RotateFlipType.Rotate90FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    break;
                case 2:
                    try
                    {
                        //lock(arrHrbtImage[0])
                        {
                            arrHrbtImage[0].RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[1])
                        {
                            arrHrbtImage[1].RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[2])
                        {
                            arrHrbtImage[2].RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img_45)
                        {
                            img_45.RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img45)
                        {
                            img45.RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(imgEyeClose)
                        {
                            imgEyeClose.RotateFlip(RotateFlipType.Rotate180FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    break;
                case 3:
                    try
                    {
                        //lock(arrHrbtImage[0])
                        {
                            arrHrbtImage[0].RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[1])
                        {
                            arrHrbtImage[1].RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(arrHrbtImage[2])
                        {
                            arrHrbtImage[2].RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img_45)
                        {
                            img_45.RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(img45)
                        {
                            img45.RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    try
                    {
                        //lock(imgEyeClose)
                        {
                            imgEyeClose.RotateFlip(RotateFlipType.Rotate270FlipNone);
                        }
                    }
                    catch
                    {
                    }
                    break;
            }
        }


        /// <summary>
        /// set the initial run menu.
        /// </summary>
        private void IniOrResetRunMenu()
        {

            mnuStepHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnStepState = true;
            mnuGoHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnGoState = true;
            mnuResumeHrtb.Enabled = false;
            arrLevels[currentLevelIndex].blnResumeState = false;
            mnuHaltHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnHaltState = false;
            mnuResetHerbt.Enabled = false;
            arrLevels[currentLevelIndex].blnResetState = false;
            arrLevels[currentLevelIndex].goPauseState = 0;

            btGoPause.Image = pbRun.Image;
            this.hTooltip.SetToolTip(this.btGoPause, "Go");
            btGoPause.Enabled = true;
            btStep.Enabled = true;
            //if(btStop.Enabled) // changes by Pavan to solve issue 3596 , this is to disable the Stop menu button at herbert loading
            btStop.Enabled = false;
        }


        /// <summary>
        /// this function is for initialising and setting menus while loading data.
        /// </summary>
        //Added by Vivek. During Herbert loading, the menu states are not set now. 
        private void IniOrResetRunMenuLoad()
        {
            mnuStepHrbt.Enabled = true;
            //arrLevels[currentLevelIndex].blnStepState = true;
            mnuGoHrbt.Enabled = true;
            //arrLevels[currentLevelIndex].blnGoState = true;
            mnuResumeHrtb.Enabled = false;
            //arrLevels[currentLevelIndex].blnResumeState = false;
            mnuHaltHrbt.Enabled = false;
            //arrLevels[currentLevelIndex].blnHaltState = false;
            mnuResetHerbt.Enabled = false;
            //arrLevels[currentLevelIndex].blnResetState = false;
            //arrLevels[currentLevelIndex].goPauseState = 0;
            btGoPause.Image = pbRun.Image;
            this.hTooltip.SetToolTip(this.btGoPause, "Go");
            btGoPause.Enabled = true;
            btStep.Enabled = true;
            btStop.Enabled = false;
        }


        /// <summary>
        /// Formats the date.
        /// </summary>
        /// <param name="values">The date value to be formatted.</param>
        /// <returns> Returns the formatted date string.</returns>
        private string formatDate(DateTime values)
        {
            return (values.Year.ToString() + "-" + values.Month.ToString("00") + "-" + values.Day.ToString("00") + " " + values.Hour.ToString("00") + ":" + values.Minute.ToString("00") + ":" + values.Second.ToString("00"));
        }

#if(CONTEST)
        /// <summary>
        /// This function is for saving the current state of all controls.
        /// It is used while uploading solutions.
        /// </summary>
        //Added by Vivek on 6/1/2005 to handle the case of Upload Solutions
        private void SaveControlStates()
        {
            //UploadSolutions menu
            //			ControlStatus[0] = mnuUploadSolutions.Enabled;

            //Exit menu
            ControlStatus[1] = mnuExit.Enabled;

            //Undo menu
            ControlStatus[2] = mnuTxtUndo.Enabled;

            //Cut text menu
            ControlStatus[3] = mnuTxtCut.Enabled;

            //Copy text menu
            ControlStatus[4] = mnuTxtCopy.Enabled;

            //Paste text menu
            ControlStatus[5] = mnuTxtPaste.Enabled;

            //Clear text menu
            ControlStatus[6] = mnuTxtClear.Enabled;

            //Trace menu
            ControlStatus[7] = mnuTrace.Enabled;

            //Path menu
            ControlStatus[8] = mnuPath.Enabled;

            //ToolBar menu
            ControlStatus[9] = mnuToolBar.Enabled;

            //Step menu
            ControlStatus[10] = mnuStepHrbt.Enabled;

            //Go menu
            ControlStatus[11] = mnuGoHrbt.Enabled;

            //Resume menu
            ControlStatus[12] = mnuResumeHrtb.Enabled;

            //Halt menu
            ControlStatus[13] = mnuHaltHrbt.Enabled;

            //Reset menu
            ControlStatus[14] = mnuResetHerbt.Enabled;

            //About menu
            ControlStatus[15] = mnuAboutHerbert.Enabled;

            //ToolBar button for left
            ControlStatus[16] = btLeft.Enabled;

            //ToolBar button for straight
            ControlStatus[17] = btStraight.Enabled;

            //ToolBar button for right
            ControlStatus[18] = btRight.Enabled;

            //ToolBar button for cut
            ControlStatus[19] = btCut.Enabled;

            //ToolBar button for copy
            ControlStatus[20] = btCopy.Enabled;

            //ToolBar button for paste
            ControlStatus[21] = btPaste.Enabled;

            //ToolBar button for stop
            ControlStatus[22] = btStop.Enabled;

            //ToolBar button for go/pause
            ControlStatus[23] = btGoPause.Enabled;

            ////ToolBar button for step
            ControlStatus[24] = btStep.Enabled;

            ////ToolBar button for trace
            ControlStatus[25] = btTrace.Enabled;

            ////ToolBar button for path
            ControlStatus[26] = btPath.Enabled;

        }


        /// <summary>
        /// this function is for getting and setting the state of all controls
        /// </summary>
        //Added by Vivek on 6/1/2005 to handle the case of Upload Solutions
        private void RetrieveControlStates()
        {
            //Exit menu
            mnuExit.Enabled = ControlStatus[1];

            //Undo menu
            mnuTxtUndo.Enabled = ControlStatus[2];

            //Cut text menu
            mnuTxtCut.Enabled = ControlStatus[3];

            //Copy text menu
            mnuTxtCopy.Enabled = ControlStatus[4];

            //Paste text menu
            mnuTxtPaste.Enabled = ControlStatus[5];

            //Clear text menu
            mnuTxtClear.Enabled = ControlStatus[6];

            //Trace menu
            mnuTrace.Enabled = ControlStatus[7];

            //Path menu
            mnuPath.Enabled = ControlStatus[8];

            //ToolBar menu
            mnuToolBar.Enabled = ControlStatus[9];

            //Step menu
            mnuStepHrbt.Enabled = ControlStatus[10];

            //Go menu
            mnuGoHrbt.Enabled = ControlStatus[11];

            //Resume menu
            mnuResumeHrtb.Enabled = ControlStatus[12];

            //Halt menu
            mnuHaltHrbt.Enabled = ControlStatus[13];

            //Reset menu
            mnuResetHerbt.Enabled = ControlStatus[14];

            //About menu
            mnuAboutHerbert.Enabled = ControlStatus[15];

            //ToolBar button for left
            btLeft.Enabled = ControlStatus[16];

            //ToolBar button for straight
            btStraight.Enabled = ControlStatus[17];

            //ToolBar button for right
            btRight.Enabled = ControlStatus[18];

            //ToolBar button for cut
            btCut.Enabled = ControlStatus[19];

            //ToolBar button for copy
            btCopy.Enabled = ControlStatus[20];

            //ToolBar button for paste
            btPaste.Enabled = ControlStatus[21];

            //ToolBar button for stop
            btStop.Enabled = ControlStatus[22];

            //ToolBar button for go/pause
            btGoPause.Enabled = ControlStatus[23];

            //ToolBar button for step
            btStep.Enabled = ControlStatus[24];

            //ToolBar button for trace
            btTrace.Enabled = ControlStatus[25];

            //ToolBar button for path
            btPath.Enabled = ControlStatus[26];

        }


        /// <summary>
        /// this function is for saving the state of all menus
        /// </summary>
        //Added by Vivek on 6/1/2005 to handle the case of Upload Solutions
        //these status were added to overcome the Menu Enabler software
        private void SaveMenuStatus()
        {
            //Go menu
            MenuStatus[0] = arrLevels[currentLevelIndex].blnGoState;

            //Halt menu
            MenuStatus[1] = arrLevels[currentLevelIndex].blnHaltState;

            //Reset menu
            MenuStatus[2] = arrLevels[currentLevelIndex].blnResetState;

            //Resume menu
            MenuStatus[3] = arrLevels[currentLevelIndex].blnResumeState;

            //Step menu
            MenuStatus[4] = arrLevels[currentLevelIndex].blnStepState;

        }


        /// <summary>
        /// this function is for getting and setting the state of all menus
        /// </summary>
        //Added by Vivek on 6/1/2005 to handle the case of Upload Solutions
        //these status were added to overcome the Menu Enabler software
        private void RetrieveMenuStatus()
        {
            //Go menu
            arrLevels[currentLevelIndex].blnGoState = MenuStatus[0];

            //Halt menu
            arrLevels[currentLevelIndex].blnHaltState = MenuStatus[1];

            //Reset menu
            arrLevels[currentLevelIndex].blnResetState = MenuStatus[2];

            //Resume menu
            arrLevels[currentLevelIndex].blnResumeState = MenuStatus[3];

            //Step menu
            arrLevels[currentLevelIndex].blnStepState = MenuStatus[4];


        }
#endif
        #region Interpreter Segregation
        private void TxtCodeEditorVisible(bool isVisble)
        {
            txtCodeEditor.Visible = isVisble;
        }
        private void CommandHandler(string strOP)
        {
            Command = strOP;
        }
        private void DisplayTraceHandler(int iTraceX, int iTraceWidth)
        {
            TraceX = iTraceX;
            TraceWidth = iTraceWidth;
            displayTrace();
        }
        private void InternalErrorHandler(int iErrorCode)
        {
            if (isInternalErrorLogged)
            {
                sbErrorLog.Append("\n Internal Error " + iErrorCode + "raised in Interpreter()");
            }
            InternalError(iErrorCode);
        }
        private void CheckSyntaxUpadteLevelData(ref BaseLevel objBaseLevel)
        {
            arrLevels[currentLevelIndex].acCurrentLine = objBaseLevel.acCurrentLine;
            arrLevels[currentLevelIndex].actualVirtualLineNum = objBaseLevel.actualVirtualLineNum;
            arrLevels[currentLevelIndex].atLineInfo = objBaseLevel.atLineInfo;
        }
        private void EvalCurLineMoveHerbert()
        {
#if (EXCEPTION)
            try
            {
#endif
                int delay = 0;
                bool closed = false;

                if (hrbtRedrawn && herbtSpeed > 10)
                {
                    // set hrbtRedrawn to false so that currently executing 
                    //thread can't change the location of herbert picture box.
                    hrbtRedrawn = false;
                    while (delay < herbtSpeed)
                    {
                        if (!closed)
                        //lock(this.herbertPicBox)
                        {
#if (OLDCODE)
					this.herbertPicBox.Image = imgEyeClose;
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}

#endif
                            //lock(imgEyeClose)
                            {
#if (INVOKER)
                                //this.herbertPicBox.Image = imgEyeClose;	
                                if (this.herbertPicBox.InvokeRequired)
                                {
                                    if (herbtSpeed == 0)
                                        lock (imgForPicBox)
                                        {
                                            imgForPicBox = imgEyeClose;
                                        }
                                    else
                                        imgForPicBox = imgEyeClose;
                                    this.herbertPicBox.Invoke(mi);
                                    ////Console.WriteLine("if block : invoker for closed");
                                }
                                else
                                {
#endif
                                    ////Console.WriteLine("else block : closed");
                                    this.herbertPicBox.Image = imgEyeClose;
                                    herbertPicBox.Invalidate();
#if (INVOKER)
                                }

                                //this.herbertPicBox.Image = imgEyeClose;

#endif
                            }
                            //herbertPicBox.Invalidate();
                            //Application.DoEvents();
#endif
                        }
                        else
                        //lock(this.herbertPicBox)
                        {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                            //lock(arrHrbtImage[0])
                            {
#if (INVOKER)
                                //this.herbertPicBox.Image = arrHrbtImage[0];	
                                if (this.herbertPicBox.InvokeRequired)
                                {
                                    if (herbtSpeed == 0)
                                        lock (imgForPicBox)
                                        {
                                            imgForPicBox = arrHrbtImage[0];
                                        }
                                    else
                                        imgForPicBox = arrHrbtImage[0];
                                    this.herbertPicBox.Invoke(mi);
                                    ////Console.WriteLine("if block : invoker for open");
                                }
                                else
                                {
#endif
                                    ////Console.WriteLine("else block : open");
                                    this.herbertPicBox.Image = arrHrbtImage[0];
                                    herbertPicBox.Invalidate();
#if (INVOKER)
                                }

                                //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                            }
                            //herbertPicBox.Invalidate();
                            //Application.DoEvents();
#endif
                        }
                        closed = !closed;
                        delay += herbtSpeed / 3 - 1;
                        if (herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed / 3);
                    }
                }
                //lock(this.herbertPicBox)
                {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                    //lock(arrHrbtImage[0])
                    {
#if (INVOKER)

                        if (this.herbertPicBox.InvokeRequired)
                        {
                            if (herbtSpeed == 0)
                                lock (imgForPicBox)
                                {
                                    imgForPicBox = arrHrbtImage[0];
                                }
                            else
                                imgForPicBox = arrHrbtImage[0];
                            this.herbertPicBox.Invoke(mi);
                            /////Console.WriteLine("Invoking....");
                        }
                        else
                        {
#endif
                            this.herbertPicBox.Image = arrHrbtImage[0];
                            herbertPicBox.Invalidate();
#if (INVOKER)
                        }

                        //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                    }
                    //herbertPicBox.Invalidate();
                    //Application.DoEvents();
#endif
                }
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(e.Message + ", EvalCurLine, 11");
            }
#endif
        }
        /// <summary>
        /// To call the Interpreter dll.
        /// </summary>
        HInterpreter objHinterpreter = null;
        private void CallInterpreter()
        {
            Designer.BaseLevel objBaseLevel = (Designer.BaseLevel)arrLevels[currentLevelIndex];
            objHinterpreter = new HInterpreter(ref objBaseLevel, progClosing, m_blnThreadStarted);
            objHinterpreter.raiseMoveHerbie += MoveHerbie;
            objHinterpreter.raiseCommand += CommandHandler;
            objHinterpreter.raiseDisplayTrace += DisplayTraceHandler;
            objHinterpreter.raiseDispMessage += DispMessage;
            objHinterpreter.raiseEditorTrace += EditorTrace;
            objHinterpreter.raiseInternalError += InternalErrorHandler;
            objHinterpreter.raiseKillThreadNoWait += killThreadNoWait;
            objHinterpreter.raiseSelectError += selectError;
            objHinterpreter.raiseTxtCodeEditorVisible += TxtCodeEditorVisible;
            objHinterpreter.raiseInterpretrEndOfProgram += InterpreterEndOfProgram;
            //objHinterpreter.txtLines = txtLines;
            objHinterpreter.raiseCheckSyntaxMenuUpdate += CheckSyntaxMenuUpdate;
            objHinterpreter.raiseInterpretHerbertPositionUpdate += InterpretHerbertPositionUpdate;
            objHinterpreter.SetTextData(txtTotalLength, txtTotalLines, txtLines);
            objHinterpreter.raiseGetTextForLTFrame += getTextForLTFrame;
            objHinterpreter.raiseCheckSyntaxUpadteLevelData += CheckSyntaxUpadteLevelData;
            objHinterpreter.raiseEvalCurLineMoveHerbert += EvalCurLineMoveHerbert;
            objHinterpreter.SetTraceOn(traceOn);
            objHinterpreter.SetHerbertSpeed(herbtSpeed);
            objHinterpreter.SetDisplayEdTraceOnce(displayEdTraceOnce);
            //objHinterpreter.SetTraceDisplayed(sTraceDisplayed);
            objHinterpreter.raiseSetdisplayEdTraceOnce += SetdisplayEdTraceOnce;
            objHinterpreter.raiseSetGoPauseState += SetGoPauseState;
            objHinterpreter.raiseEnableMenu += EnableMenu;
#if(DESIGNER)
            objHinterpreter.raiseUpdateMaxStackLength += InterpreterUpdateMaxStackLength;
            objHinterpreter.raiseUpdateNumProgramSteps += InterpreterUpdateNumProgramSteps;
#endif
        }
        private void SetdisplayEdTraceOnce(bool isSetdisplayEdTraceOnce)
        {
            displayEdTraceOnce = isSetdisplayEdTraceOnce;
        }
        private void SetGoPauseState()
        {
            mnuHaltHrbt.Enabled = false;
            this.hTooltip.SetToolTip(this.btGoPause, "Resume");
            btGoPause.Image = pbRun.Image;
            arrLevels[currentLevelIndex].goPauseState = 0;
        }

        /// <summary>
        /// This function is to handle the herbert position update in the interpret function()
        /// </summary>
        private void InterpretHerbertPositionUpdate()
        {
            lock (arrLevels[currentLevelIndex])
            {
                if (arrLevels[currentLevelIndex].blnIsWallHit && GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                {
                    //arrLevels[currentLevelIndex].ErasePath(curPosX, curPosY, preDestPosX, preDestPosY);
                    arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].preDestPosX;
                    arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].preDestPosY;
                    arrLevels[currentLevelIndex].blnIsWallHit = false;
                }
            }
        }
        #region For designer with modular interpreter
#if(DESIGNER)
        private void InterpreterUpdateMaxStackLength(int maxStackLength)
        {
            ///Rajesh
            ///To set maxstacklength
            ///Date 3/5/06
            if (((STACKSIZE) - maxStackLength) > arrLevels[currentLevelIndex].MaxStackLength)
            {
                arrLevels[currentLevelIndex].MaxStackLength = (STACKSIZE) - maxStackLength;
                if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                    arrLevels[currentLevelIndex].MaxStackLengthPersistent = arrLevels[currentLevelIndex].MaxStackLength;
            }
            ///end
        }
        private void InterpreterUpdateNumProgramSteps()
        {
            arrLevels[currentLevelIndex].NumProgramSteps++;
            if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                arrLevels[currentLevelIndex].NumProgramStepsPersistent = arrLevels[currentLevelIndex].NumProgramSteps;
        }
#endif
        #endregion
        private void CheckSyntaxMenuUpdate()
        {
            DisableMenu();
            mnuResetHerbt.Enabled = true;
            btStop.Enabled = true;
        }
        private void InterpreterEndOfProgram()
        {
            lblLineTracing.Text = "";
            TraceX = 0;
            TraceWidth = 0;
            //By:Rajesh
            //Date:8/8/06
            //To resolve issue: 3514
            //if(traceOn)
            displayTrace();
            //Debug(herbtSpeed.ToString());
            DispMessage("End of program reached");

            // Fix issue of Herbert stopping at 45 degrees.


            EnableMenu();
            mnuGoHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnGoState = false;
            mnuStepHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnStepState = false;
            mnuResumeHrtb.Enabled = false;
            arrLevels[currentLevelIndex].blnResumeState = false;
            mnuHaltHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnHaltState = false;
            mnuResetHerbt.Enabled = true;
            arrLevels[currentLevelIndex].blnResetState = true;
            btGoPause.Enabled = false;
            btStop.Enabled = true;
            btStep.Enabled = false;
#if(CONTEST)
            btRestore.Enabled = false;
#endif
            // commented by karthikeyan 25072005
            //						if(arrLevels[currentLevelIndex].IsLevelFinished)
            //							lblLevelSolved.Text = "(Solved!)";
            //						else
            //							lblLevelSolved.Text = "(Unsolved)";
            lock (txtCodeEditor)
            {
                txtCodeEditor.Visible = true;
            }
            getImages();
            RotateImages(arrLevels[currentLevelIndex].CurDir);
            this.herbertPicBox.Invalidate();
            //lock(arrHrbtImage[stateArray[0]])
            {
#if (INVOKER)

                if (this.herbertPicBox.InvokeRequired)
                {
                    try
                    {
                        if (herbtSpeed == 0)
                            //										lock(imgForPicBox)
                            //										{
                            imgForPicBox = arrHrbtImage[stateArray[0]];
                        //										}
                        else
                            imgForPicBox = arrHrbtImage[stateArray[0]];
                    }
                    catch
                    { }
                    //To fix the issue for EOD in turbo mode. 7482
                    this.herbertPicBox.Invoke(mi);
                    try
                    {
                        t.Abort();
                    }
                    catch
                    { }

                    /////Console.WriteLine("Invoking....");
                }
                else
                {
#endif
                    this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];
#if (INVOKER)
                }

                //this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];

#endif
            }

        }
        #endregion
        /// <summary>
        /// Function which starts a thread.
        /// </summary>
        private void startThread()
        {
            //			try
            //			{  

            //				t = null;	
            //				//start a new thread of function Interpret.
            //				t = new Thread(new ThreadStart(Interpret));
            //				t.Priority = ThreadPriority.Normal;
            //				t.Name = DateTime.Now.ToString();
            //				t.Start();
            killThread();
            // by Vivek for aborting the thread before starting a new one
            //to make sure that only on interpreter thread runs at a time
            try
            {
                t.Abort();
            }
            catch
            {
            }

            t = null;
            //start a new thread of function Interpret.
            lock (progClosing)
            {
                progClosing = false;
            }
#if(MODULAR_INTERPRETER)
            CallInterpreter();
            t = new Thread(new ThreadStart(objHinterpreter.Interpret));
#else
            t = new Thread(new ThreadStart(Interpret));
#endif


            //t.Priority = ThreadPriority.Highest;
            //suggest by vijay on 20060221
            //t.Priority = ThreadPriority.Lowest;
            t.Name = DateTime.Now.ToString();

#if(SPOOL)
				//Console.WriteLine(" ");
				//Console.WriteLine("########################");
				//Console.WriteLine("Main starting: " + t.Name);
#endif
            t.Start();
#if(SPOOL)
				//Console.WriteLine("Main waiting: " + t.Name);
#endif
            //ih++;
            //Commented by Vivek Balagangadharan
            // Description : Check if hang issue on level scroll is fixed by this or not.
            // Commented On : 10-Jan-2005 
            /*while(true)
            {
                lock(m_blnThreadStarted)
                {
                    if ((bool)m_blnThreadStarted) break;
                }
                ////Console.WriteLine("m_blnThreadStarted"+ih);
				
                //Commented by Vivek Balagangadharan
                // Description : Check if Application.DoEvents is required at this stage.
                // Commented On : 10-Aug-2005 and later merged on : 23-Aug-2005
                //Application.DoEvents();

                //Thread.Sleep(200);
            }*/
#if(SPOOL)
				//Console.WriteLine("Interpret started: " + t.Name);
#endif
        }


        //int ih = 0;
        /// <summary>
        /// function which aborts the thread.
        /// </summary>
        object oSMon = true; // For Mutual Exclusion on Level Complete
        private void killThread()
        {
            lock (progClosing)
            {
                ////Console.WriteLine(t.Name + " markeded eend.");
#if(SPOOL) 
				if(t!=null)
					//Console.WriteLine("Main killing Interpret: " + t.Name);
#endif
                if (!(bool)progClosing)
                    progClosing = true;

#if(MODULAR_INTERPRETER)
                if (objHinterpreter != null)
                {

                    objHinterpreter.SetProgClosing(ref progClosing);
                }
#endif
            }
            //if(Monitor.TryEnter(oSMon,500))//by Ani for solving an issue of level change when the congratulatory message appears
            //{
            //oSMon = false;
            if (t != null)
            {
                if (t.ThreadState != System.Threading.ThreadState.Stopped)
                {
#if(SPOOL) 
					//Console.WriteLine("Main waiting for Interpret to die: " + t.Name + ", ThreadState:" + t.ThreadState.ToString());
#endif
                    int i = 0;
                    while ((t.ThreadState & (System.Threading.ThreadState.Stopped | System.Threading.ThreadState.Unstarted)) == 0)
                    {
                        ////Console.WriteLine("before Application.DoEvents()"+ih);
                        //suggest by vijay on 20060221
                        //Thread.Sleep(100);

                        Application.DoEvents();
                        i++;
                        //Added By Rajesh To resolve wandering issue
                        //21/8/06
                        //Issue ID: 3490
                        //if(i > 90000) break;

                        /* commented by Vivek  to resolve wandering in occuring only in turbo mode
                        if(herbtSpeed == 0)
                        {
                            if(i > 1000 && (t.ThreadState != System.Threading.ThreadState.Aborted && t.ThreadState != System.Threading.ThreadState.Stopped && t.ThreadState != System.Threading.ThreadState.Unstarted))
                            {
                                try
                                {
                                    t.Abort();
                                }
                                catch
                                {
                                }
                                Thread.Sleep(100);
                                break;
                            }
                        }*/
                    }
                    //					blnTestKillThreadStarted = false;
#if(SPOOL) 
					//Console.WriteLine("Interpret dead: " + t.Name);
					//Console.WriteLine("####################");
					//Console.WriteLine(" ");
#endif
                }
            }//t block
            //oSMon = true;// by Pavan as the object is made false in moniter enter but not set to true again.
            //Monitor.Exit(oSMon);
            //}// Monitor Block
        }


        /// <summary>
        /// Function which aborts the thread.
        /// </summary>
        private void killThreadNoWait()
        {
            if (t != null)
            {
                lock (progClosing)
                {
#if(SPOOL) 
					//Console.WriteLine("killThreadNoWait killing Interpret: " + t.Name);
#endif
                    if (!(bool)progClosing)
                        progClosing = true;
                }
                //				while(t.ThreadState != ThreadState.Stopped)
                //					Thread.Sleep(100);
            }
#if(MODULAR_INTERPRETER)
            if (objHinterpreter != null)
            {
                objHinterpreter.SetProgClosing(ref progClosing);
            }
#endif
        }


        /// <summary>
        /// This is an infinite loop that interprets and executes herbert.
        /// This runs as a thread.
        /// </summary>

        private void Interpret()
        {
#if(SPOOL) 
			//Console.WriteLine(" ");
			//Console.WriteLine("@@@@@@@@@");
			//Console.WriteLine("Interpret() started " + Thread.CurrentThread.Name);
#endif
            lock (m_blnThreadStarted)
            {
                m_blnThreadStarted = true;
            }
            lock (progClosing)
            {
                if ((bool)progClosing)
                    Thread.Sleep(500);
                else
                    Thread.Sleep(200);
            }
            //			MessageBox.Show(this, "m_blnThreadStarted:" + m_blnThreadStarted.ToString(), "vinay");
            //			MessageBox.Show(this, "progClosing:" + arrLevels[currentLevelIndex].progClosing.ToString(), "vinay");
            //			MessageBox.Show(this, "bMonitorLChange:" + bMonitorLChange.ToString(), "vinay");
            //			MessageBox.Show(this, "bSemaphore:" + bSemaphore.ToString(), "vinay");
            lock (progClosing)
            {
                if ((bool)progClosing)
                {
                    //MessageBox.Show(this, "Returning", "vinay");
                    return;
                }
            }
            //check for end of program and progClosing.
            try
            {
                //check for end of program and progClosing.
#if(SPOOL) 
				//Console.WriteLine("Interpret() loop started " + Thread.CurrentThread.Name);
#endif
                while (true)
                {
                    int iWait = (int)(herbtSpeed * 2) + 200;

                    #region Changes by Ani
                    // Check for Level change notification
                    if (Monitor.TryEnter(bMonitorLChange, iWait))
                    {
                        #region Monitoring Level change variable
                        if ((bool)bMonitorLChange)
                        {
                            //Level change initiated so return
                            //m_blnThreadStarted = false;
                            try
                            {
                                Monitor.Exit(bMonitorLChange); // it is hear means level change was initiated
                            }
                            catch { }
                            break;
                        }
                        // Acquire lock on semaphore while still holding a lock on the bMonitorLChange
                        // as this would avoid it interference from the Level change thread.
                        if (Monitor.TryEnter(bSemaphore, iWait))
                        {
                            #region Semaphore & other
                            // Interpretation takes place
                            if (!((bool)(bSemaphore)))
                            {
                                Monitor.Exit(bSemaphore);
                                try
                                {
                                    Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                }
                                catch { }
                                break;
                            }
                            if (blnChangeLevel)
                            {
                                blnChangeLevel = false;
                                //m_blnThreadStarted = false;
                                try
                                {
                                    Monitor.Exit(bSemaphore);
                                }
                                catch
                                {
                                }
                                //								try{Thread.CurrentThread.Abort();}
                                //								catch{}
                                try
                                {
                                    Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                }
                                catch { }
                                break;
                            }
                            bSemaphore = true;
                            try
                            {
                                Monitor.Exit(bMonitorLChange);
                            }
                            catch
                            {
                            }
                            #endregion

                            #region Inside Semaphore Lock
                            try
                            {
                                #region Program Closing as well as End of Program
                                lock (progClosing)
                                {
                                    if ((bool)progClosing)
                                    {
                                        //m_blnThreadStarted = false;
                                        try
                                        {
                                            Monitor.Exit(bSemaphore);
                                        }
                                        catch
                                        {
                                        }
                                        //										try
                                        //										{
                                        //											Thread.CurrentThread.Abort();
                                        //										}
                                        //										catch{}
                                        try
                                        {
                                            Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                        }
                                        catch { }
                                        break;
                                    }
                                }
                                lock (arrLevels[currentLevelIndex].EndofProg)
                                {
                                    if ((bool)arrLevels[currentLevelIndex].EndofProg)
                                    {
                                        //m_blnThreadStarted = false;
                                        try
                                        {
                                            Monitor.Exit(bSemaphore);
                                        }
                                        catch
                                        {
                                        }
                                        //										try
                                        //										{
                                        //											Thread.CurrentThread.Abort();
                                        //										}
                                        //										catch{}
                                        try
                                        {
                                            Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                        }
                                        catch { }
                                        break;
                                    }
                                }
                                #endregion
                                #region Of MoveHerbie
                                if (MoveHerbie())
                                {
                                    #region r1
                                    if (blnChangeLevel)
                                    {
                                        blnChangeLevel = false;
                                        //m_blnThreadStarted = false;
                                        try
                                        {
                                            Monitor.Exit(bSemaphore);
                                        }
                                        catch
                                        {
                                        }
                                        //										try{Thread.CurrentThread.Abort();}
                                        //										catch{}
                                        // The following Message would still pop up even though
                                        // it appears after current thread abort
                                        //MessageBox.Show(this,"Change Level After Move Herbie");
                                        try
                                        {
                                            Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                        }
                                        catch { }
                                        break;
                                    }
                                    #endregion
                                    #region r2
                                    try
                                    {
                                        // -- Introduced by aniruddha to prevent other threads from manipulating Herbert's Level Data
                                        lock (arrLevels[currentLevelIndex])
                                        {
                                            if (arrLevels[currentLevelIndex].blnIsWallHit && GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                            {
                                                //arrLevels[currentLevelIndex].ErasePath(curPosX, curPosY, preDestPosX, preDestPosY);
                                                arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].preDestPosX;
                                                arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].preDestPosY;
                                                arrLevels[currentLevelIndex].blnIsWallHit = false;
                                            }
                                        }
                                    }
                                    catch { }
                                    #endregion
                                    Interpreter();
                                    if (blnSystemError)
                                    {
                                        //m_blnThreadStarted = false;
                                        try
                                        {
                                            Monitor.Exit(bSemaphore);
                                        }
                                        catch
                                        {
                                        }
                                        try
                                        {
                                            Monitor.Exit(bMonitorLChange); // by Pavan to solve issue 3606, as the object bMonitorLChange is never released if it breaks here
                                        }
                                        catch { }
                                        break;
                                    }
                                }
                                else
                                {
                                    if (blnLineTraceStarted || !traceOn)
                                        Thread.Sleep(herbtSpeed);
                                }
                                #endregion
                                // Let go of the Semaphore for small time so that the Level CHange functionality
                                // can acquire the lock in case of changing the level
                                try
                                {
                                    Monitor.Exit(bSemaphore);
                                }
                                catch
                                {
                                }
                            }
                            catch
                            {
                                // Needs to let go even on error
                                try
                                {
                                    Monitor.Exit(bSemaphore);
                                }
                                catch
                                {
                                }
                            }
                            #endregion
                        }
                        else
                        {
                            // This means LevelScroll has lock on the semaphore.. 
                            //m_blnThreadStarted = false;
                            try
                            {
                                Monitor.Exit(bMonitorLChange);
                            }
                            catch
                            {
                            }
                            break;
                        }
                        #endregion
                    }
                    else
                    {
                        // Lock couldn't be acquired 
                        // Signifies levelchange is in progress
                        //m_blnThreadStarted = false;
                        break;
                    }
                    #endregion

                }// end while	
                //Monitor.PulseAll(bSemaphore);
#if(SPOOL) 
				//Console.WriteLine("Interpret() loop ended " + Thread.CurrentThread.Name);
#endif
                //RestoreResources();
                if (blnSystemError)
                {
                    //HaltHrbt_Click(null,null);
                    DisableMenu();
                    btStop.Enabled = true;
                    mnuResetHerbt.Enabled = true;
                    arrLevels[currentLevelIndex].blnResetState = true;
                }
            }
            finally
            {
                lock (m_blnThreadStarted)
                {
                    m_blnThreadStarted = false;
                }
                //RestoreResources();
#if(SPOOL) 
				//Console.WriteLine("Interpret() finally " + Thread.CurrentThread.Name);
#endif
            }
#if(SPOOL) 
			//Console.WriteLine("Interpret() ended " + Thread.CurrentThread.Name);
			//Console.WriteLine("@@@@@@@@@");
			//Console.WriteLine(" ");
#endif
        }


        private void DisableAllItems(bool isUpload)
        {
            if (isUpload)
            {
                lblClosing.Text = "Uploading solutions...";
                //lblLoading.BorderStyle = BorderStyle.None;
                //lblLoading.Visible = true;			
                lblClosing.Location = new Point(this.Width / 2 - lblClosing.Width / 2, this.Height / 2 - lblClosing.Height / 2);
                lblClosing.Visible = true;
                LevelChangeBar.Enabled = false;
#if(CONTEST)
                if (isSiteDefaultUserId != 1)
                {
                    btRestore.Enabled = false;
                    mnuSeperator2Edit.Enabled = false;
                    mnuRestoreBest.Enabled = false;
                }
#endif
            }
            //lblClosing.BringToFront();
            mnuMainFile.Enabled = false;
            mnuMainEdit.Enabled = false;
            mnuMainOptions.Enabled = false;
            mnuMainRun.Enabled = false;
#if(DESIGNER)
			mnuMainDesign.Enabled= false;
#endif
            mnuMainHelp.Enabled = false;
            SpeedBar.Enabled = false;
            txtCodeEditor.ReadOnly = true;
            btRight.Enabled = false;
            btLeft.Enabled = false;
            btStraight.Enabled = false;
            btGoPause.Enabled = false;
            btStep.Enabled = false;
            btStop.Enabled = false;
            if (mnuTxtPaste.Enabled != false)
                btPaste.Enabled = false;
            btCopy.Enabled = false;
            btCut.Enabled = false;
            btTrace.Enabled = false;
            btPath.Enabled = false;
            //			lblClosing.Refresh();
            //			this.Refresh();
        }


        private void EnableAllItems()
        {
            mnuMainFile.Enabled = true;
            mnuMainEdit.Enabled = true;
#if(CONTEST)
            if (isSiteDefaultUserId != 1 && GlobalData.HerbertMode == HMode.Contest)
            {
                mnuRestoreBest.Enabled = true;
                btRestore.Enabled = true;
            }
#endif
            mnuMainOptions.Enabled = true;
            mnuMainRun.Enabled = true;
#if(DESIGNER)
			mnuMainDesign.Enabled= true;
#endif
            mnuMainHelp.Enabled = true;
            LevelChangeBar.Enabled = true;
            SpeedBar.Enabled = true;
            txtCodeEditor.ReadOnly = false;
            lblClosing.Visible = false;
            btRight.Enabled = true;
            btLeft.Enabled = true;
            btStraight.Enabled = true;
            btGoPause.Enabled = true;
            btStep.Enabled = true;
            btStop.Enabled = true;
            if (mnuTxtPaste.Enabled != false)
                btPaste.Enabled = true;
            btCopy.Enabled = true;
            btCut.Enabled = true;
            btTrace.Enabled = true;
            btPath.Enabled = true;
        }


        /// <summary>
        /// Enables all menu item under run menu.
        /// </summary>
        private void EnableMenu()
        {
            mnuStepHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnStepState = true;
            mnuResumeHrtb.Enabled = true;
            arrLevels[currentLevelIndex].blnResumeState = true;
            mnuGoHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnGoState = true;
            mnuResetHerbt.Enabled = true;
            arrLevels[currentLevelIndex].blnResetState = true;
            mnuHaltHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnHaltState = true;
            btGoPause.Enabled = true;
            btStep.Enabled = true;
#if(CONTEST)
            if (isSiteDefaultUserId != 1 && GlobalData.HerbertMode != HMode.Tutorial)
                btRestore.Enabled = true;
#endif
            //btStop.Enabled = true;
        }


        /// <summary>
        /// Disables all menu items under run menu.
        /// </summary>
        private void DisableMenu()
        {
            mnuStepHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnStepState = false;
            mnuResumeHrtb.Enabled = false;
            arrLevels[currentLevelIndex].blnResumeState = false;
            mnuGoHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnGoState = false;
            mnuResetHerbt.Enabled = false;
            arrLevels[currentLevelIndex].blnResetState = false;
            mnuHaltHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnHaltState = false;
            btGoPause.Enabled = false;
            btStop.Enabled = false;
            btStep.Enabled = false;
#if(CONTEST)
            btRestore.Enabled = false;
#endif
        }
        #region By Rajesh fo testing purpose
        public static void displayAllLevelSolveMessagetest()
        {
            //if in intranet zone, the message window should be modal.

            MessageBox.Show("Congratulations! You have solved all of the levels. If you wish, you can try to improve your existing solutions in order to increase your score.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
        #endregion

        //Added by vivek on 2005/06/10

#if(CONTEST)
        /// <summary>
        /// This function displays the congratulatory message after a level is solved for the first time.
        /// </summary>
        /// Added by Vivek for making the window modal
        private void displayLevelSolveMessage()
        {
            //if in intranet zone, the message window should be modal.
            try
            {
                this.Activate();
            }
            catch
            {
            }

            YesNoNextLevel = MessageBox.Show(this, "Congratulations! You have solved this level. Do you want to go to the next unsolved level?", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
        }
#endif
#if(CONTEST)

        /// <summary>
        /// This function displays the congratulatory message after all the levels are solved.
        /// </summary>
        // Added by Vivek for making the window modal.
        private void displayAllLevelSolveMessage()
        {
            //if in intranet zone, the message window should be modal.
            try
            {
                this.Activate();
            }
            catch
            {
            }
            MessageBox.Show(this, "Congratulations! You have solved all of the levels. If you wish, you can try to improve your existing solutions in order to increase your score.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
#endif


#if(CONTEST)
        /// <summary>
        /// This function displays the congratulatory message after all the levels are solved.
        /// </summary>
        /// Added by Vivek for displaying message for bucketing levels.

        private void displayLevelChangeMessage()
        {

            MessageBox.Show(this, "You must solve this level before you can advance to the next level.");
        }
#endif



        /// <summary>
        /// This function takes care of moving herbert.
        /// </summary>
        /// <returns>indicates that it needs next char or not. if it returns 
        /// true then herbert has completed its all 8 steps. else retruns
        /// false.</returns>
        private bool MoveHerbie()
        {
            try
            {

                //bool variable to indicate that herbert has reached to a target or not.
                //<10/03/05>
                //				if(!progClosing)
                //				{
                //</10/03/05>
                bool newPointAchived = false;

                //check if herbert's current and destination positions are same.
                if (arrLevels[currentLevelIndex].curPosX != arrLevels[currentLevelIndex].destPosX || arrLevels[currentLevelIndex].curPosY != arrLevels[currentLevelIndex].destPosY)
                {
                    //check if herbert picture box has completed its rendering
                    //if(hrbtRedrawn)
                    herbertState = ++herbertState % 9;
                    //start//
                    //Adeded By Rajesh
                    //Date 16/8/06
                    //To fix issue 3297
                    if (herbertState == 1)
                    {

                        blnPathChange = false;
                        //To set prePathPos
                        if (PathOn)
                        {
                            //Commented By Rajehs to fix the glitch issue.15/05/07
                            arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                            //arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                            //arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
                        }

                    }
                    //end//
                    if (stateArray[herbertState] != 0 && !isWall() && !arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut))
                    {
                        setCurPos = arrLevels[currentLevelIndex].CurDir;
                    }
                    arrLevels[currentLevelIndex].blnIsWallHit = false;


                    if ((isWall() || arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut)) && herbertState == 8)
                    {
#if(CONTEST)
                        if (mnuPath.Checked && currentLevelIndex != 0)
                            arrLevels[currentLevelIndex].fRemovePath();
#endif
                        //						arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX;
                        //						arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY;	

                        arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].preDestPosX;
                        arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].preDestPosY;


                        arrLevels[currentLevelIndex].blnIsWallHit = true;
#if(DESIGNER)
						///Rajesh
						///To calculate no of Wall Hits
						///Date 3/5/06
						if(arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir,currentLevelId,arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut,arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut)&& herbertState == 8)
						{
                            // added by Nikhil Kardale on 02/04/2008 to stop counting wall hits after a level has been completely solved
                            if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                                arrLevels[currentLevelIndex].NumWallHits++;
						}
#endif
                    }

                    //					if(arrLevels[currentLevelIndex].curPosY<12&&btani)
                    //						//Console.WriteLine(arrLevels[currentLevelIndex].curPosY.ToString());

                    bool wallhit = false;
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                    {
                        //if(PathOn)
                        //Added By Rajesh
                        //Date 16/8/06
                        //To fix issue 3297   
                        if ((PathOn && !blnPathChange) || (!PathOn && blnPathChange))
                        {
                            if ((arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut)))
                            {
                                if (Math.Abs((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - (arrLevels[currentLevelIndex].prePosX * GlobalData.ZoomInZoomOut)) < 12 && Math.Abs((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - (arrLevels[currentLevelIndex].prePosY * GlobalData.ZoomInZoomOut)) < 12)
                                {
                                    //arrLevels[currentLevelIndex].ErasePath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut,arrLevels[currentLevelIndex].prePosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].prePosY * GlobalData.ZoomInZoomOut);
                                    arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].preDestPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].preDestPosY * GlobalData.ZoomInZoomOut);
                                }
                                wallhit = true;
                            }
                        }
                    }
                    //if(hrbtRedrawn && herbtSpeed > 5)
                    if (hrbtRedrawn && herbtSpeed != 0)
                    {
                        // set hrbtRedrawn to false so that currently executing 
                        //thread can't change the location of herbert picture box.
                        hrbtRedrawn = false;

                        try
                        {
                            //lock(this.herbertPicBox)
                            {
                                //lock(arrHrbtImage[stateArray[herbertState]])
                                {
#if (INVOKER)
                                    if (this.herbertPicBox.InvokeRequired)
                                    {
                                        if (herbtSpeed == 0)
                                            lock (imgForPicBox)
                                            {
                                                imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                            }
                                        else
                                            imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                        this.herbertPicBox.Invoke(mi);
                                    }
                                    else
                                    {
#endif
                                        this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
#if (INVOKER)
                                    }
#endif
                                }
                            }

                        }
                        catch
                        {
                            ////Console.WriteLine(exp1.Message + ", MoveHerbie, 10");
                        }
                        try
                        {
                            //change the location of herbert picture box and 2 is used 
                            //because we can't specify the center point of a picture box
                            //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                            // and (curPosX, curPosY) is center point where this picture 
                            //box should be displayed.
                            //lock(this.herbertPicBox)
                            {
                                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                {
                                    if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                                    {
                                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                                    }
                                    else
                                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));

                                }
                                else
                                    this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                            }
                        }
                        catch
                        {
                            ////Console.WriteLine(e.Message + ", MoveHerbie, 11");
                        }
                    }

#if (EXCEPTION)
                    try
                    {
#endif
                        //check if path is on then only display path.
                        //if(PathOn)
                        //Added By Rajesh
                        //Date 16/8/06
                        //To fix issue 3297                        
                        if ((PathOn && !blnPathChange) || (!PathOn && blnPathChange))
                        {
                            //check if herbert board has completed its rendering
                            //							if(hrbtBoardRedrawn && herbtSpeed>3)
                            //							{
                            //call the draw path method of the level class to display path
                            //for this level.
                            if (!(wallhit && GlobalData.ZoomInZoomOut == HConstants.ZOOMIN))
                            {
                                arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                                hrbtBoardRedrawn = false;
                            }
                            //							}					

                        }
#if (EXCEPTION)
                    }
                    catch
                    {
                        ////Console.WriteLine(e.Message + ", MoveHerbie, 31");
                    }
#endif
                    arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
                    newPointAchived = arrLevels[currentLevelIndex].CheckforDot(currentLevelId, arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut, ref HerbertBoard, arrLevels[currentLevelIndex].destPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].destPosY * GlobalData.ZoomInZoomOut, TotalTimeInSecRemaining, GameInterval, InstanceStartTime);

                    if (newPointAchived)
                    {
                        if (NewTargetHitLevelSolved())
                        {
                            return true;
                        }
                    }

                    /*This code written to haldle the herberts jump when current position and destination position are same.*/
                    if (arrLevels[currentLevelIndex].curPosX == arrLevels[currentLevelIndex].destPosX && arrLevels[currentLevelIndex].curPosY == arrLevels[currentLevelIndex].destPosY)
                    {
                        //displaying path when herbert speed is max it is giving errors out side this code.
#if (EXCEPTION)
                        try
                        {
#endif
                            //if(PathOn)
                            //Added By Rajesh
                            //Date 16/8/06
                            //To fix issue 3297   
                            if ((PathOn && !blnPathChange) || (!PathOn && blnPathChange))
                            {
                                if (!(wallhit && GlobalData.ZoomInZoomOut == HConstants.ZOOMIN))
                                {
                                    arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                                    hrbtBoardRedrawn = false;
                                }
                            }
#if (EXCEPTION)
                        }
                        catch
                        {
                            ////Console.WriteLine(e.Message + ", MoveHerbie, 41");
                        }
#endif
                        sNeedChar = true;
                        //if(!EndofProg && !progClosing && herbtSpeed != 0)
                        if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                            Thread.Sleep(herbtSpeed);
                        herbertState = 0;
                        arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].curPosX;
                        arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].curPosY;
                        if (hrbtRedrawn || arrLevels[currentLevelIndex].syntaxCheck)// || herbtSpeed == 0)
                        {
                            // set hrbtRedrawn to false so that currently executing 
                            //thread can't change the location of herbert picture box.
                            hrbtRedrawn = false;
#if (EXCEPTION)
                            try
                            {
#endif
                                //lock(this.herbertPicBox)
                                {
#if (OLDCODE)
										this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                    //lock(arrHrbtImage[stateArray[0]])
                                    {
#if (INVOKER)

                                        if (this.herbertPicBox.InvokeRequired || herbtSpeed == 3)
                                        {
                                            if (herbtSpeed == 0)
                                                lock (imgForPicBox)
                                                {
                                                    imgForPicBox = arrHrbtImage[stateArray[0]];
                                                }
                                            else
                                                imgForPicBox = arrHrbtImage[stateArray[0]];
                                            this.herbertPicBox.Invoke(mi);
                                        }
                                        else
                                        {
#endif
                                            this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];
#if (INVOKER)
                                        }
#endif
                                    }
                                    herbertPicBox.Invalidate();
#endif
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(exp1.Message + ", MoveHerbie, 50");
                            }
#endif
#if (EXCEPTION)
                            try
                            {
#endif
                                //change the location of herbert picture box and 2 is used 
                                //because we can't specify the center point of a picture box
                                //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                // and (curPosX, curPosY) is center point where this picture 
                                //box should be displayed.
                                //lock(this.herbertPicBox)
                                {
                                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                        if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                                        {
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                                        }
                                        else
                                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                                    else
                                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                                }
#if (EXCEPTION)
                            }
                            catch
                            {
                                ////Console.WriteLine(e.Message + ", MoveHerbie, 51");
                            }
#endif
                        }
                    }
                    else
                    {
                        sNeedChar = false;
                    }

                }
#if (EXCEPTION)
            }
            catch// (Exception exp)
            {
                ////Console.WriteLine(fe.Message + ", MoveHerbie, 61");
            }
#endif
#if(SPOOL) 
			//Console.WriteLine("MoveHerbie() Ended: "+t.Name+" ThreadState: "+t.ThreadState.ToString());
#endif
            return sNeedChar;
        }


        /// <summary>
        /// this method is called whenever a white button is touched this checks if level is solved and if required message is shown
        /// (Pavan's extra)  Also checks if bucketing and displays new level(s) as per solved.
        /// </summary>
        /// <returns></returns>
        private bool NewTargetHitLevelSolved()
        {
            int debugLineCounter = 0;
            bool newPointHit;
            int curBucket = 0;
            int curBucketSolvedLevels = 0;
            try
            {
                newPointHit = arrLevels[currentLevelIndex].chkLevelFinished(currentLevelId, TotalTimeInSecRemaining, GameInterval, InstanceStartTime);
                debugLineCounter++; //1
                if (newPointHit)
                {
                    if (arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                        lblLevelSolved.Text = "(Solved!)";
                    else
                        lblLevelSolved.Text = "(Unsolved)";


                    // added by Nikhil Kardale on 07/01/2008 to fix issue id. 3230
                    if (lblLevelNo.Text == "0")
                        lblLevelSolved.Visible = false;
                    else
                        lblLevelSolved.Visible = true;

#if(DESIGNER)
                    // added by Nikhil Kardale on 6/4/2008 to fix issue of 'Solved' message on a newly designed level
                    if (lblLevelNo.Text == "0")
                    {
                        if (arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                            lblLevelSolved.Visible = true;
                        else
                            lblLevelSolved.Visible = false;
                    }
#endif


#if(RTDEBUG)
				strDebugLog += "Level No = "+ currentLevelIndex.ToString() +" Before InstanceStartTime= "+ InstanceStartTime.ToString() +", TotalTimeInSecRemaining= " + TotalTimeInSecRemaining.ToString() + ", GameInterval= " + GameInterval.ToString() + ", arrLevels[currentLevelIndex].FirstSolutionDT= " +  arrLevels[currentLevelIndex].FirstSolutionDT.ToString()+"\n";
#endif

                    //							if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                    //							{
                    //								arrLevels[currentLevelIndex].FirstSolutionDT = InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval);
                    //							}
#if(RTDEBUG)
				strDebugLog += "Level No = "+ currentLevelIndex.ToString() +" After InstanceStartTime= "+ InstanceStartTime.ToString() +", TotalTimeInSecRemaining= " + TotalTimeInSecRemaining.ToString() + ", GameInterval= " + GameInterval.ToString() + ", arrLevels[currentLevelIndex].FirstSolutionDT= " +  arrLevels[currentLevelIndex].FirstSolutionDT.ToString()+"\n";
#endif
                }
                debugLineCounter++; //2

                lblTotalScore.Text = Level.totalScore.ToString() + "/" + iSumOfAllLevelPoints.ToString();
                lblScorePerDot.Text = "(" + arrLevels[currentLevelIndex].scoreCurrently.ToString() + " now)";
                if (currentLevelIndex > 0)
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                else
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + GlobalData.DeginerLevelPoints;
                debugLineCounter++; //3


#if(CONTEST)

                if (!arrLevels[currentLevelIndex].blnLevelSolvedMsgShown && newPointHit && arrLevels[currentLevelIndex].IsLevelFinishedPersistant && arrLevels[currentLevelIndex].levelScore <= arrLevels[currentLevelIndex].scoreCurrently)
                {
                    //								Thread t3 = new Thread(new ThreadStart(SaveScorePerLevelBackGround));
                    //								t3.Priority = ThreadPriority.Lowest;
                    //								t3.Start();
                    //NextUnsolvedLevel = 0;
                    
                    // added by Kapil Natu to solve issued id. 9938 - Level scrolling
                    #region Level scrolling issue resolved
                    
                    #region Commented
                    //bool blnLevelFound = false;
                    //for (NextUnsolvedLevel = 1; NextUnsolvedLevel < arrLevels.Length; NextUnsolvedLevel++)
                    //{
                    //    if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                    //    {
                    //        blnLevelFound = true;
                    //        break;
                    //    }
                    //}
                    #endregion

                    bool blnLevelFound = false;

                    // Checking for next unsolved level between current level and last level.
                    for (NextUnsolvedLevel = currentLevelIndex + 1; NextUnsolvedLevel < arrLevels.Length; NextUnsolvedLevel++)
                    {
                        if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                        {
                            blnLevelFound = true;
                            break;
                        }
                    }
                    if (!blnLevelFound)
                    {
                        for (NextUnsolvedLevel = 1; NextUnsolvedLevel < currentLevelIndex; NextUnsolvedLevel++)
                        {
                            if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                            {
                                blnLevelFound = true;
                                break;
                            }
                        }
                    }

                    //end - changed by kapil
                    #endregion

                    debugLineCounter++; //4

                    #region code for bucketing
                    //-by Pavan to implement bucketing of levels
                    if (isBucketingEnabled)
                    {
                        #region Bucketing By Nikhil Kardale
                        BucketingLevels = GlobalData.reqdLevelSolvePercentage;
                        blnLevelFound = false;
                        for (int i = 1; i < arrLevels.Length; i++)
                        {
                            if (((i - 1) % GlobalData.numLevelsPerBucket) == 0)
                            {
                                if (curBucketSolvedLevels >= GlobalData.reqdLevelSolvePercentage || curBucket == 0)
                                {
                                    curBucket++;
                                    curBucketSolvedLevels = 0;
                                }
                                else
                                {//New bucket, but no of level solved in the lest last levels<no req levls to be solved.                                    
                                    break;
                                }
                            }
                            //End
                            if (arrLevels[i].IsLevelFinishedPersistant)
                            {
                                TotalSolvedLevels++;
                                curBucketSolvedLevels++;//To count the no of Levels solved in the Current level.
                            }
                        }
                        blnLevelFound = false;
                        if (curBucketSolvedLevels < GlobalData.reqdLevelSolvePercentage)
                        {
                            for (NextUnsolvedLevel = ((curBucket - 1) * GlobalData.numLevelsPerBucket) + 1; NextUnsolvedLevel < ((curBucket) * GlobalData.numLevelsPerBucket); NextUnsolvedLevel++)
                            {
                                if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                                {
                                    blnLevelFound = true;
                                    break;
                                }
                            }
                        }
                        int iCurUnsolvedBucket = curBucket;
                        // added by NikhilK on 25/10/2007
                        GlobalData.currentUnsolvedBucket = curBucket;
                        //OpenLevel = 3;
                        if (iCurUnsolvedBucket * GlobalData.numLevelsPerBucket + 1 <= arrLevels.Length)
                            LevelChangeBar.Maximum = (iCurUnsolvedBucket * GlobalData.numLevelsPerBucket + 1) * 10;
                        else
                            LevelChangeBar.Maximum = arrLevels.Length * 10;

                        ///end
                        #endregion
                    }
                    #endregion

                    if (isLevelChangeLogged)
                    {
                        sbErrorLog.Append("\n Solved Level No. " + currentLevelIndex.ToString() + " for the first time.");
                    }
                    if (!blnLevelFound)
                    {
                        // modified by Nikhil Kardale on 4/10/2007 to fix issue 8968 and to show correct message after level is solved
                        for (NextUnsolvedLevel = 1; NextUnsolvedLevel <= (curBucket * GlobalData.numLevelsPerBucket); NextUnsolvedLevel++)
                        {
                            if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                            {
                                blnLevelFound = true;
                                break;
                            }
                        }
                    }
                    debugLineCounter++; //5

                    HerbertBoard.Refresh();
                    arrLevels[currentLevelIndex].blnLevelSolvedMsgShown = true;
                    debugLineCounter++; //6

                    //if(Monitor.TryEnter(oSMon,2000))//by Ani for solving an issue of level change when the congratulatory message appears
                    //{
                    if (!blnLevelFound && !arrLevels[currentLevelIndex].blnLevelFinishedMsg)
                    {
                        //added by Vivek for solving an issue of level change when the
                        // congratulatory message appears
                        MethodInvoker mis = new MethodInvoker(displayAllLevelSolveMessage);
                        this.Invoke(mis);
                        if (isLevelChangeLogged)
                        {
                            sbErrorLog.Append("\n All levels solved!");
                        }
                    }
                    else
                    {

                        arrLevels[currentLevelIndex].blnLevelFinishedMsg = true;
                        //commented for solving an issue of level change when the
                        // congratulatory message appears

                        LevelChangeBar.Enabled = false;


#if(DLL)
							displayLevelSolveMessage();
#else
                        //YesNoNextLevel = MessageBox.Show(this,"Congratulations! You have solved this level. Do you want to go to the next unsolved level?", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);							
                        //MethodInvoker mis = new MethodInvoker(displayLevelSolveMessage);
                        //this.Invoke(mis);

                        // added by Nikhil Kardale to fix issue 9927 - window not modal
                        YesNoNextLevel = MessageBox.Show(this, "Congratulations! You have solved this level. Do you want to go to the next unsolved level?", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
#endif

                        //isMessageDisplayed = true;
                        debugLineCounter++; //6

                        if (YesNoNextLevel == DialogResult.Yes)
                        {
                            //vijay
                            try
                            {
                                killThreadNoWait();
                                LevelChangeBar.Enabled = false;
                                Thread t2 = new Thread(new ThreadStart(scrollLevel));
                                //t2.Priority = ThreadPriority.Lowest;
                                t2.Name = "Scroll Level (" + DateTime.Now.ToShortTimeString() + ")";
                                t2.Start();
                                debugLineCounter++; //7

                                if (isLevelChangeLogged)
                                {
                                    sbErrorLog.Append("\n Going to next unsolved level: " + NextUnsolvedLevel.ToString());
                                }

                                blnChangeLevel = true;

                                arrLevels[currentLevelIndex].blnResumeState = true;

#if(SPOOL)
									//Console.WriteLine("MoveHerbie() ended1: "+t.Name+" ThreadState: "+t.ThreadState.ToString());
#endif
                                LevelChangeBar.Enabled = true;
                                debugLineCounter++; //8
                                return true;
                            }
                            catch//(Exception exp)
                            {
                                LevelChangeBar.Enabled = true;
                            }
                            finally
                            {
                                LevelChangeBar.Enabled = true;
                            }
                        }
                        else
                            arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
                        LevelChangeBar.Enabled = true;
                    }
                    //Monitor.Exit(oSMon);
                    //}

                }
#endif

            }
            catch (Exception exp)
            {
                if (isExceptionLogged)
                {
                    try
                    {
                        sbErrorLog.Append("\n Exception in function NewTargetHitLevelSolved()");
                        sbErrorLog.Append("\n Exception Message: " + exp.Message);
                        sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                        sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                        sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                        LogErrors();
                    }
                    catch
                    {
                    }
                }

            }
            return false;

        }


        /// <summary>
        /// displays the error, welcome, and program relate messages on bottom msgbox.
        /// </summary>
        /// <param name="Message"></param>
        private void DispMessage(String Message)
        {
            if (Message.Length > 0 && Message.CompareTo("Good Luck!") != 0 && Message.CompareTo("End of program reached") != 0)
                //PlaySound();
                arrLevels[currentLevelIndex].stepByStep = false;
            lblMsgBox.Text = Message;
            Message = null;
        }


        /// <summary>
        /// Counts the number of chars in the textcodeEditor as the per the counting logic.
        /// </summary>
        /// <returns>return the number of chars.</returns>
        private int CountChars(string txtCodeEditorTxt)
        {
            lock (txtCodeEditor)
            {
                if (txtCodeEditor.Text.Length == 0)
                    return 0;
            }
            char pc;
            int iCount, i;
            //,iLineLen,iMaxLineLen;
            long lTemp;

            iCount = 0;
            char[] arrCode;
            lock (txtCodeEditor)
            {
                lTemp = txtCodeEditorTxt.Length;
                arrCode = txtCodeEditorTxt.ToCharArray();
            }
            if (lTemp >= 0)
            {
                i = 0;
                while (i < lTemp)
                {
                    pc = arrCode[i];
                    if (Char.IsDigit(pc))
                    {
                        StringBuilder sbNumber = new StringBuilder();
                        while (Char.IsDigit(arrCode[i]))
                        {
                            sbNumber.Append(arrCode[i]);
                            i++;
                            if (i == lTemp)
                                break;
                        }
                        iCount++;
                        i--;
                    }
                    if (pc <= 'Z' && pc >= 'A')
                    {
                        iCount++;
                    }
                    if (pc <= 'z' && pc >= 'a')
                    {
                        iCount++;
                    }

                    i++;

                }
            }
            return (iCount);
        }


#if(DESIGNER)
		/// <summary>
		/// Gets the position of Herbert for the level index
		/// </summary>
		/// <param name="CurrentLevelIndex">int</param>
		private Point GetHerbertPos(int CurrentLevelIndex)
		{
			Point p;
			p = new Point(arrLevels[CurrentLevelIndex].HerbertX *GlobalData.ZoomInZoomOut,arrLevels[CurrentLevelIndex].HerbertY*GlobalData.ZoomInZoomOut);
			//p = new Point(iRoboX, iRoboY);
			return p;
		}
#endif

        /// <summary>
        /// resets the herbert.
        /// </summary>
        private void resetHerbert()
        {
            //resets some of the boolean variables.
            //for(;progClosing;);
            arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
            arrLevels[currentLevelIndex].EndofProg = false;
            arrLevels[currentLevelIndex].blnIsWallHit = false;
            //hrbthalted = false; commented by karthikeyan 16/03
            //progClosing = true;
            arrLevels[currentLevelIndex].goClicked = false;
            blnSystemError = false;


            ////Console.WriteLine("CurDir "+CurDir);
            //sets the direction of herbert to 0.

            arrLevels[currentLevelIndex].CurDir = 0;

            //gets the images which are not atall rotated.
            getImages();

#if (EXCEPTION)
            try
            {
#endif
                //if level is more than 10 then get herbert's x,y position from level class else
                //use hardcoded values.
# if(DESIGNER)
				if(currentLevelId >0)
					InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
				else if(arrLevels[currentLevelIndex].IsLevelUpdate && currentLevelIndex == 0)
					InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
				else
				{
#endif

                //					InitialOrResetHrbt.X = (BoardWidth/2+HOFFSET-HConstants.DOTSPACE)+(GlobalData.ZoomInZoomOut-1);
                //					InitialOrResetHrbt.Y = (BoardHeight/2+HOFFSET-HConstants.DOTSPACE)+(GlobalData.ZoomInZoomOut-1);
#if(CONTEST)
                if (currentLevelId > 0)
                {
                    ////Console.WriteLine("inside resetHerbert");

                    InitialOrResetHrbt = arrLevels[currentLevelIndex].getRoboXY(currentLevelId);
                    ////Console.WriteLine("InitialOrResetHrbt ("+InitialOrResetHrbt.X+","+InitialOrResetHrbt.Y+")");
                }
                else
#endif
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                        InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                    else
                        InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
# if(DESIGNER)
				}
#endif


                //lock(this.herbertPicBox)
                {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                    //lock(arrHrbtImage[0])
                    {
#if (INVOKER)

                        if (this.herbertPicBox.InvokeRequired)
                        {
                            if (herbtSpeed == 0)
                                lock (imgForPicBox)
                                {
                                    imgForPicBox = arrHrbtImage[0];
                                }
                            else
                                imgForPicBox = arrHrbtImage[0];
                            this.herbertPicBox.Invoke(mi);
                            /////Console.WriteLine("Invoking....");
                        }
                        else
                        {
#endif
                            this.herbertPicBox.Image = arrHrbtImage[0];
#if (INVOKER)
                        }


                        //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                    }
                    //herbertPicBox.Invalidate();
                    //Application.DoEvents();
#endif
                }
                //resets the herbert's position variables like prePos$, destPos$ etc.
                arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut;
                arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut;
#if(CONTEST)
                arrLevels[currentLevelIndex].fDisposePathStore();
#endif
                if (GlobalData.HerbertMode != HMode.Designer || !arrLevels[currentLevelIndex].IsLevelUpdate)
                    arrLevels[currentLevelIndex].ResetLevel(currentLevelId);
                else
                    arrLevels[currentLevelIndex].resetLevelDesigner(currentLevelId);
#if(PATTERN_GENERATER)
                //arrLevels[currentLevelIndex].IsPatternEnabled = false;
#endif
                //vinay02/09/05HerbertBoard.Refresh();;
                HerbertBoard.Invalidate();

#if (EXCEPTION)
                try
                {
#endif
                    //lock(this.herbertPicBox)
                    {
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                            if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                            {
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                            }
                            else
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                        else
                            herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(e.Message + ", resetHerbert, 11");
                }
#endif
                //				}
                arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;

#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(e.Message + ", resetHerbert, 21");
            }

#endif

# if(DESIGNER)
			Level.SetRoboPos(arrLevels[currentLevelIndex].curPosX, arrLevels[currentLevelIndex].curPosY);
			arrLevels[currentLevelIndex].HerbertX = arrLevels[currentLevelIndex].curPosX;
			arrLevels[currentLevelIndex].HerbertY = arrLevels[currentLevelIndex].curPosY;
			mnuMainDesign.Enabled = true;
			HerbertBoard.Enabled=true;
			txtLevelPoints.ReadOnly = false;

			Level.totalScore = 0;
			arrLevels[currentLevelIndex].levelScore = 0;
			arrLevels[currentLevelIndex].BestLevelScore = 0;
			arrLevels[currentLevelIndex].IsLevelFinished = false;
			arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;

			if(!arrLevels[currentLevelIndex].IsLevelUpdate)
				txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
			else
				txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();

			if(currentLevelIndex > 0)
				lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
			else
				lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + lvlpoints.ToString();	

			//get the level status.
			if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
				lblLevelSolved.Text = "(Solved!)";
			else
				lblLevelSolved.Text = "(Unsolved)";
#endif

            //reset edior tracing variables
            iStartIndexET = iEndIndexET = 0;
            //reset Line Tracing variables
            iStartIndexLT = iEndIndexLT = iFrameLT = 0;
            TraceX = 0;
            //drawLevel(currentLevelId);
            EnableMenu();
            arrLevels[currentLevelIndex].syntaxCheck = true;
            arrLevels[currentLevelIndex].checkSyntaxGo = true;
            arrLevels[currentLevelIndex].stepByStep = false;

            sNeedChar = true;
            //displayBox = false;  commented by karthikeyan 16/03
            lblTraceFirst.Text = "";
            lblBlack.Text = "";
            lblBlack.Visible = false;
            lblTraceSecond.Text = "";
            arrLevels[currentLevelIndex].blnHReset = true;

            txtCodeEditor.Visible = true;

            // this is used for code editor tracing and is set to zero so that when reset this box should not be displayed.
            lineWidth = 0;
            //patchwork
            //deSelectError();
            if (!errorShown)
                DispMessage("");
            //resets the currently score label.
            lblScorePerDot.Text = "(0 now)";
            //Thread.Sleep(150);
        }


        //		private int CorrectPos(int pos)
        //		{
        //			int rem = 0;
        //			int res = Math.DivRem(pos,8,rem);
        //		}


#if(CONTEST)

        //Added by Vivek Balagangadharan
        // Description : This function is called in the ValueChanged event of LevelChangeBar to stop herbert
        //				 at it's position if it's running.
        /// <summary>
        /// Function to stop herbert movement on level change
        /// </summary>
        private void StopHerbert()
        {
            int debugLineCounter = 0;
            //check if the halt menu is enabled, i.e. Herbert is running
            if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg && arrLevels[currentLevelIndex].blnHaltState)
            {
                ////Console.WriteLine("inside StopHerbert, currentLevelIndex : " + currentLevelIndex);
                killThread();
                debugLineCounter++; //1

                arrLevels[currentLevelIndex].blnResumeState = true;
                mnuResumeHrtb.Enabled = true;

                arrLevels[currentLevelIndex].blnGoState = false;
                mnuGoHrbt.Enabled = false;

                herbertState = 0;
                debugLineCounter++; //2
#if (EXCEPTION)
                try
                {
#endif
                    //lock(this.herbertPicBox)
                    {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null)
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                        //lock(arrHrbtImage[stateArray[herbertState]])
                        {
#if (INVOKER)
                            if (this.herbertPicBox.InvokeRequired)
                            {
                                if (herbtSpeed == 0)
                                    lock (imgForPicBox)
                                    {
                                        imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                    }
                                else
                                    imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                this.herbertPicBox.Invoke(mi);
                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
                                HerbertBoard.Invalidate();
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];

#endif
                        }
                        //herbertPicBox.Invalidate();

                        //Application.DoEvents();
#endif
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(exp1.Message + ", HaltHrbt_Click, 10");
                }
                debugLineCounter++; //3
                try
                {
#endif

                    //wall check

                    //Hurdle check
                    bool blnTempIsDestIsHerdle = false;
                    if (arrLevels[currentLevelIndex].CurDir == 0)
                    {
                        if (arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, arrLevels[currentLevelIndex].destPosX * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY + 3) * GlobalData.ZoomInZoomOut))
                        {
                            blnTempIsDestIsHerdle = true;
                        }
                    }
                    else if (arrLevels[currentLevelIndex].CurDir == 1)
                    {
                        if (arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, (arrLevels[currentLevelIndex].destPosX - 2) * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY) * GlobalData.ZoomInZoomOut))
                        {
                            blnTempIsDestIsHerdle = true;
                        }
                    }
                    else if (arrLevels[currentLevelIndex].CurDir == 2)
                    {
                        if (arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, (arrLevels[currentLevelIndex].destPosX) * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY - 2) * GlobalData.ZoomInZoomOut))
                        {
                            blnTempIsDestIsHerdle = true;
                        }
                    }
                    else if (arrLevels[currentLevelIndex].CurDir == 3)
                    {
                        if (arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir, currentLevelId, (arrLevels[currentLevelIndex].destPosX + 3) * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY) * GlobalData.ZoomInZoomOut))
                        {
                            blnTempIsDestIsHerdle = true;
                        }
                    }
                    else
                        blnTempIsDestIsHerdle = false;

                    debugLineCounter++; //4
                    //					if(arrLevels[currentLevelIndex].destPosX < 0 || arrLevels[currentLevelIndex].destPosY < 0)
                    //						//Console.WriteLine("hi");

                    //if(isWall() || arrLevels[currentLevelIndex].isHurdle(arrLevels[currentLevelIndex].CurDir,currentLevelId,arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut,arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut))
                    if (isWall())
                    {

                        if (!((arrLevels[currentLevelIndex].curPosX == arrLevels[currentLevelIndex].destPosX) &&
                            (arrLevels[currentLevelIndex].curPosY == arrLevels[currentLevelIndex].destPosY)))
                        {
                            ////Console.WriteLine("inside wall");
                            if (mnuPath.Checked && currentLevelIndex != 0)
                                arrLevels[currentLevelIndex].fRemovePath();
                            //						arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].preDestPosX;
                            //						arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].preDestPosY;
                            arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].destPosX = ((arrLevels[currentLevelIndex].preDestPosX) / 8) * 8 + 4;
                            arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].destPosY = ((arrLevels[currentLevelIndex].preDestPosY) / 8) * 8 + 4;
                            arrLevels[currentLevelIndex].blnIsWallHit = true;
                        }
                        //						if(arrLevels[currentLevelIndex].curPosY < 4)
                        //						{
                        //							MessageBox.Show("In the isWall() section, of level:" + currentLevelIndex.ToString() + "\nCurPosX = "+ arrLevels[currentLevelIndex].curPosX.ToString() + "\nCurPosY = " +arrLevels[currentLevelIndex].curPosY.ToString()+"\nDestPosX = " +arrLevels[currentLevelIndex].destPosX.ToString()+"\nDestPosY = " +arrLevels[currentLevelIndex].destPosX.ToString());
                        //						}
                    }
                    else if (blnTempIsDestIsHerdle)
                    {
                        ////Console.WriteLine("inside hurdle");
                        if (mnuPath.Checked && currentLevelIndex != 0)
                            arrLevels[currentLevelIndex].fRemovePath();
                        //					arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].preDestPosX;
                        //					arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].preDestPosY;			
                        arrLevels[currentLevelIndex].curPosX = ((arrLevels[currentLevelIndex].preDestPosX) / 8) * 8 + 4;
                        arrLevels[currentLevelIndex].curPosY = ((arrLevels[currentLevelIndex].preDestPosY) / 8) * 8 + 4;
                    }
                    else
                    {
                        //						MessageBox.Show("In the 3rd else of level:" + currentLevelIndex.ToString() + "\nCurPosX = "+ arrLevels[currentLevelIndex].curPosX.ToString() + "\nCurPosY = " +arrLevels[currentLevelIndex].curPosY.ToString()+"\nDestPosX = " +arrLevels[currentLevelIndex].destPosX.ToString()+"\nDestPosY = " +arrLevels[currentLevelIndex].destPosX.ToString());

                        if (arrLevels[currentLevelIndex].destPosX < 0 || arrLevels[currentLevelIndex].destPosY < 0)
                        {
                            arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].destPosX = ((arrLevels[currentLevelIndex].preDestPosX) / 8) * 8 + 4;
                            arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].destPosY = ((arrLevels[currentLevelIndex].preDestPosY) / 8) * 8 + 4;
                        }
                        else
                        {
                            arrLevels[currentLevelIndex].curPosX = ((arrLevels[currentLevelIndex].destPosX) / 8) * 8 + 4;

                            //							if(arrLevels[currentLevelIndex].destPosY < 36)
                            //							{
                            //								//Console.WriteLine("This is where the problem lies :(");
                            //							}
                            arrLevels[currentLevelIndex].curPosY = ((arrLevels[currentLevelIndex].destPosY) / 8) * 8 + 4;

                        }
                    }
                    debugLineCounter++; //5


                    //					else
                    //					{
                    //						arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].destPosX;
                    //						arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].destPosY;
                    //					}

                    //change the location of herbert picture box and 2 is used
                    //because we can't specify the center point of a picture box
                    //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                    // and (arrLevels[currentLevelIndex].curPosX, arrLevels[currentLevelIndex].curPosY) is center point where this picture
                    //box should be displayed.

                    //lock(this.herbertPicBox)
                    {
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                            if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                            {
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].destPosX - 2) * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].destPosY - 2) * GlobalData.ZoomInZoomOut - 1));
                            }
                            else
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].destPosX - 2) * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].destPosY - 2) * GlobalData.ZoomInZoomOut - 1 + 2));
                        else
                            this.herbertPicBox.Location = new System.Drawing.Point((arrLevels[currentLevelIndex].destPosX - 2), (arrLevels[currentLevelIndex].destPosY - 2));
                    }
                    debugLineCounter++; //6
                    if (isLevelChangeLogged)
                    {
                        sbErrorLog.Append("\n Level No.: " + currentLevelIndex.ToString() + " Herbert stopped on scrolling at (" + arrLevels[currentLevelIndex].curPosX.ToString() + "," + arrLevels[currentLevelIndex].curPosY.ToString() + ").");
                    }
#if (EXCEPTION)
                }
                catch (Exception exp)
                {
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n Exception in StopHerbert()");
                            sbErrorLog.Append("\n Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
                }
#endif






#if(THREADSLEEP)
				Thread.Sleep(100);
#endif

            }
        }


        //Added by Vivek Balagangadharan
        // Description : This function is called in the ValueChanged event of LevelChangeBar for levels in which 
        //				 Herbert was in motion while switching levels
        /// <summary>
        /// Function to resume herbert movement on level change
        /// </summary>
        private void ResumeHerbert()
        {
            int debugLineCounter = 0;
            //check if the resume menu of Herbert is active, i.e. Herbert is halted.
            if (arrLevels[currentLevelIndex].blnResumeState && arrLevels[currentLevelIndex].blnHaltState)
            {
                try
                {
                    mnuResumeHrtb.Enabled = false;
                    arrLevels[currentLevelIndex].blnResumeState = false;
                    debugLineCounter++; //1

                    getImages();
                    RotateImages(arrLevels[currentLevelIndex].CurDir);
                    debugLineCounter++; //2

#if(THREADSLEEP)
				Thread.Sleep(100);
#endif
                    if (arrLevels[currentLevelIndex].blnRorLStep)
                    {
                        arrLevels[currentLevelIndex].blnRorLStep = false;

                        Command = arrLevels[currentLevelIndex].StepCharRorL.ToString().ToUpper();

                    }
                    debugLineCounter++; //3

                    getTextData();
                    debugLineCounter++; //4

                    //arrLevels[currentLevelIndex].fDisplayStoredPath();
                    if (traceOn)
                    {
                        lock (txtCodeEditor)
                        {
                            txtCodeEditor.Visible = false;
                        }
                        SetupEditorTrace(0);
                        EditorTrace(arrLevels[currentLevelIndex].tHState.curLine);
                    }
                    else
                        txtCodeEditor.Visible = true;
                    debugLineCounter++; //5
                    //Added by Vivek Balagangadharan
                    // Description : We have set Herbert to the next position
                    //				 in case it is in between two points.
                    //				 Here we have to check whether it is a white button or not.
                    //				 herbertState has been set to 7 as this is the state when it 
                    //				 touches the dot.
                    // Added On : 05-Aug-2005

                    herbertState = 7;
                    bool isButtonHit = arrLevels[currentLevelIndex].CheckforDot(currentLevelId, arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut, ref HerbertBoard, arrLevels[currentLevelIndex].destPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].destPosY * GlobalData.ZoomInZoomOut, TotalTimeInSecRemaining, GameInterval, InstanceStartTime);

                    debugLineCounter++; //6

                    if (isButtonHit)
                    {
                        if (NewTargetHitLevelSolved())
                            return;
                    }
                    debugLineCounter++; //7

                    startThread();
                    debugLineCounter++; //8
                }
                catch (Exception exp)
                {
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n Exception in ResumeHerbert()");
                            sbErrorLog.Append("\n Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
                }
            }
        }


        /// <summary>
        /// resets the herbert to its previous position.
        /// this is used while levelchange.
        /// </summary>
        private void resetHerbertToPrevPos()
        {
            ////Console.WriteLine("inside resetHerbertToPrevPos, currentLevelIndex : " + currentLevelIndex); 
            arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
            arrLevels[currentLevelIndex].blnIsWallHit = false;
            blnSystemError = false;
            getImages();
            RotateImages(arrLevels[currentLevelIndex].CurDir);

#if (EXCEPTION)
            try
            {
#endif
                if (currentLevelId > 0)
                {
                    InitialOrResetHrbt = new Point(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                }
                else
                {
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                        InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                    else
                        InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
                }

                //lock(this.herbertPicBox)
                {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null)
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                    //lock(arrHrbtImage[0])
                    {
#if (INVOKER)

                        if (this.herbertPicBox.InvokeRequired)
                        {
                            imgForPicBox = arrHrbtImage[0];
                            this.herbertPicBox.Invoke(mi);
                        }
                        else
                        {
#endif
                            this.herbertPicBox.Image = arrHrbtImage[0];
#if (INVOKER)
                        }

#endif
                    }

#endif
                }
                //resets the herbert's position variables like prePos$, destPos$ etc.
                //				arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut ;
                //				arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut ;

                if (arrLevels[currentLevelIndex].curPosX == 0 || arrLevels[currentLevelIndex].curPosY == 0 || arrLevels[currentLevelIndex].curPosX > 204 || arrLevels[currentLevelIndex].curPosY > 204)
                {
                    if (currentLevelId > 0)
                    {
                        InitialOrResetHrbt = arrLevels[currentLevelIndex].getRoboXY(currentLevelId);
                    }
                    else
                    {
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                            InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                        else
                            InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
                    }
                }

                //				//Console.WriteLine("InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut =" + InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut);
                //				//Console.WriteLine("InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut =" + InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut);
                //				//Console.WriteLine("aaa1");
                arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut;
                arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut;


                arrLevels[currentLevelIndex].ResetLevelState(currentLevelId);

                HerbertBoard.Invalidate();

#if (EXCEPTION)
                try
                {
#endif
                    //lock(this.herbertPicBox)
                    {
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                            if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                            {
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                            }
                            else
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                        else
                            herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(e.Message + ", resetHerbert, 11");
                }
#endif

                arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;

#if (EXCEPTION)
            }
            catch//(Exception e)
            {
                ////Console.WriteLine(e.Message + ", resetHerbert, 21");
            }

#endif

# if(DESIGNER)
			Level.SetRoboPos(arrLevels[currentLevelIndex].curPosX, arrLevels[currentLevelIndex].curPosY);
			mnuMainDesign.Visible = true;
#endif

            //reset edior tracing variables
            iStartIndexET = iEndIndexET = 0;

            //reset Line Tracing variables
            iStartIndexLT = iEndIndexLT = iFrameLT = 0;
            TraceX = 0;

            sNeedChar = true;

            //txtLineTrace.Clear();
            lblTraceFirst.Text = "";
            lblBlack.Text = "";
            lblTraceSecond.Text = "";
            //arrLevels[currentLevelIndex].blnHReset = true;

            txtCodeEditor.Visible = true;

            // this is used for code editor tracing and is set to zero so that when reset this box should not be displayed.
            lineWidth = 0;

            if (!errorShown)
                DispMessage("");

            //resets the currently score label.
            lblScorePerDot.Text = "(" + arrLevels[currentLevelIndex].scoreCurrently.ToString() + " now)";

        }

#endif
        private void scrollLevel()
        {

            if (currentLevelIndex == NextUnsolvedLevel - 1 || currentLevelIndex == NextUnsolvedLevel + 1)
                blnSkeepLevel = false;
            else
                blnSkeepLevel = true;

            //bool blnExp = false;
            //			try
            //			{
            //				Monitor.Enter(objMonitorLevelChange);
            LevelChangeBar.Value = NextUnsolvedLevel * 10;
            //				Monitor.Exit(objMonitorLevelChange);
            //			}
            //			catch
            //			{
            //				blnExp = true;
            //			}
            //			finally
            //			{
            //				if(!blnExp)
            //					Monitor.Exit(objMonitorLevelChange);
            //			}

        }


        private Random rd;
        /// <summary>
        /// generate a random number.
        /// </summary>
        /// <param name="iSeed">seed for this random number.</param>
        /// <returns></returns>
        private int getRandomNo(int iSeed)
        {
            rd = new Random();
            return rd.Next(iSeed - iMinTimeForPolling);
        }


#if(DESIGNER)
		/*==============================================================================
		 *  Created On : 13-Apr-2006
		 *  Created By : Vivek Balagangadharan
		 *  Special Comments : Created to fix issue of levelpoints appearing incorrect on scroll.
		 * ==============================================================================*/
		/// <summary>
		/// boolean variable indicating whether level change (or scroll) is occuring.
		/// </summary>
		private bool isLevelChanging = false;
#endif

        /// <summary>
        /// all functionality of LevelChange_ValueChanged are moved here.
        /// (Pavan's comments) this function executed during the level change,
        ///					   it basically changes the scroll bar value. 
        ///					   stops the initial level hebert execution and saves the data for that level.
        ///					   Also gets and sets data for new changed level.
        /// </summary>
        //        private void ChangeLevel()
        //        {
        //#if(DESIGNER)
        //            //indicates that the level is changing(scroll started)
        //            isLevelChanging = true;
        //#endif
        //            int debugLineCounter = 0;
        //            try
        //            {
        //#if(CONTEST)

        //                DisableAllItems(false);
        //                ////Console.WriteLine("disable all items called");
        //                debugLineCounter++; //1

        //                //if it is not the first time this function is called, then stop herbert.
        //                // this function is called for the first time in loaddata()
        //                if(!blnFirstFunctionCall)
        //                {
        //                    StopHerbert();
        //                }
        //                else 
        //                {
        //                    killThread();
        //                }
        //                debugLineCounter++; //2

        //#endif
        //#if(DESIGNER)
        //            killThread();
        //#endif

        //                //for smooth scorlling.
        //                if(isSmoothScrollEnabled)
        //                {
        //                    iPrvIndex = currentLevelIndex;
        //                }
        //                debugLineCounter++; //3

        //#if(DESIGNER)
        //                try
        //                {
        //                    if(GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate)
        //                    {					
        //                        arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelId);
        //                    }
        //                }
        //                catch
        //                {
        //                    //MessageBox.Show(this,exp.Message);
        ////					//Console.WriteLine(exp.Message);
        //                }
        //# endif

        //                #region commented for new implementation logic for bucketing
        //                /*if(isBucketingEnabled)
        //                {
        //                    //Added by Vivek Balagangadharan
        //                    // Description : Added for temporarily implementing the bucketing factor.
        //                    // Bucket size = 1. Levels reqd to be solved to move to next level = 100%
        //                    // Hence, without solving the current level, higher level can't be accessed.
        //                    // Added On : 12-Sep-2005
        //                    if(!((arrLevels[currentLevelIndex].IsLevelFinished) || (currentLevelId == 0) || (currentLevelIndex>LevelChangeBar.Value/10) ))
        //                    {
        //                        if(GlobalData.SkipLevel == 1)
        //                        {
        //                            GlobalData.SkipLevel = 0;
        //                            LevelChangeBar.Enabled = false;
        //                            MethodInvoker mis = new MethodInvoker(displayLevelChangeMessage);
        //                            this.Invoke(mis);
        //                            LevelChangeBar.Enabled = true;
        //                            LevelChangeBar.Value = currentLevelIndex * 10;
        //                        }
        //                        else
        //                            if(GlobalData.SkipLevel == 0)
        //                        {
        //                            //GlobalData.SkipLevel = 1;
        //                            if(!arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnResumeState)
        //                            {
        //                                GlobalData.SkipLevel = 1;
        //                                ResumeHerbert();
        //                            }
        //                            else
        //                                GlobalData.SkipLevel = 1;
        //                        }
        //                        return;
        //                    }
        //                }*/
        //                #endregion

        //                debugLineCounter++; //4
        //                deSelectError();
        //                arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
        //                debugLineCounter++; //5
        //# if(DESIGNER)
        //            Level.totalScore = 0;
        //            arrLevels[currentLevelIndex].levelScore = 0;
        //            arrLevels[currentLevelIndex].BestLevelScore = 0;			
        //            Level.saveLevelPoints(currentLevelIndex, GlobalData.DeginerLevelPoints);
        //            Level.saveLevelProgram(currentLevelIndex, txtCodeEditor.Text);
        //            //arrLevels[currentLevelIndex].setNonSavedDesignData();//By Rajesh,21/8/06,3885

        //#endif
        //                arrLevels[currentLevelIndex].blnFirstStepClick = true;
        //                debugLineCounter++; //6

        //#if(CONTEST)
        //                if(isSiteDefaultUserId == 0)
        //                {
        //                    if(currentLevelIndex > 0)
        //                    {

        //                        if(!blnFirstFunctionCall)
        //                        {
        //                            DataRow[] drLevel = GlobalData.dsAllHData.Tables["tblGameLevelScore"].Select("LevelScoreId = "+arrLevels[currentLevelIndex].LevelScoreId.ToString());

        //                            if(String.Compare(drLevel[0]["CurrentProgram"].ToString(),arrLevels[currentLevelIndex].iCurrentProgram) != 0)
        //                            {
        //                                arrLevels[currentLevelIndex].isLevelDataChanged = true;
        //                            }
        //                        }

        //                        for(int i = 0; i < arrLevels.Length ; i++)
        //                        {
        //                            if(arrLevels[i].isLevelDataChanged)
        //                            {
        //                                if((arrLevels[currentLevelIndex].tSaveLevel == null) || (arrLevels[currentLevelIndex].tSaveLevel.ThreadState != System.Threading.ThreadState.Running))
        //                                {
        //                                    arrLevels[currentLevelIndex].tSaveLevel = new Thread(new ThreadStart(SavePerLevelData));
        //                                    arrLevels[currentLevelIndex].tSaveLevel.Name = "Silent Save ("+DateTime.Now.ToShortTimeString()+")";
        //                                    arrLevels[currentLevelIndex].tSaveLevel.Priority = ThreadPriority.Highest;
        //                                    arrLevels[currentLevelIndex].tSaveLevel.Start();
        //                                    break;
        //                                }
        //                            }
        //                        }
        //                    }
        //                }
        //                debugLineCounter++; //7
        //#endif

        //                //changes for contest 11/02/05.
        //                //get the value of current level.
        //#if(DESIGNER)
        //            if((!isSingleLevelDesigner) || (currentLevelIndex==0)) 
        //            {			
        //#endif
        //                if(isLevelChangeLogged)
        //                {
        //                    sbErrorLog.Append("\n In ChangeLevel(), moving from level no.: " + currentLevelIndex.ToString());
        //                    sbErrorLog.Append("\n Current Level Program: "+arrLevels[currentLevelIndex].iCurrentProgram);
        //                }
        //                currentLevelIndex = LevelChangeBar.Value/10;
        //                debugLineCounter++; //8
        //                //			if(currentLevelIndex == arrLevels.Length-1)
        //                //			{
        //                //				//Console.WriteLine("first");
        //                //				//Console.WriteLine("currentLevelIndex " + currentLevelIndex);
        //                //				//Console.WriteLine("currentLevelId " + currentLevelId);
        //                //				//Console.WriteLine("("+arrLevels[currentLevelIndex].curPosX+","+arrLevels[currentLevelIndex].curPosY+")");
        //                //				//Console.WriteLine(arrLevels[currentLevelIndex].getRoboXY(currentLevelId).X +"-"+arrLevels[currentLevelIndex].getRoboXY(currentLevelId).Y);
        //                //				//Console.WriteLine("end");
        //                //			}

        //#if(DESIGNER)
        //            }			
        //#endif

        //                #region commented for new implementation logic for bucketing
        //                /*if(isBucketingEnabled)
        //                {
        //                    ////Console.WriteLine("Going to: " + currentLevelIndex.ToString());

        //                    //Added by Vivek Balagangadharan
        //                    // Description : To check cases where level change bar dragged to come to a higher level 
        //                    // Added On : 19-Sep-2005
        //                    int lastSolvedLevelIndex = 0;
        //                    if(currentLevelIndex>0)
        //                    {
        //                        lastSolvedLevelIndex = currentLevelIndex - 1;
        //                    }
        //                    ////Console.WriteLine("Hence last solved level should be: " + lastSolvedLevelIndex.ToString());
        //                    while(lastSolvedLevelIndex > 0)
        //                    {
        //                        if(!arrLevels[lastSolvedLevelIndex].IsLevelFinished)
        //                        {
        //                            lastSolvedLevelIndex--;
        //                        }
        //                        else
        //                        {
        //                            break;
        //                        }
        //                    }

        //                    ////Console.WriteLine("Last solved level is: {0}" , lastSolvedLevelIndex.ToString());
        //                    if((lastSolvedLevelIndex >= 0)&&(currentLevelIndex>0)&&(lastSolvedLevelIndex != currentLevelIndex-1))
        //                    {
        //                        if(GlobalData.SkipLevel == 1)
        //                        {
        //                            //Console.WriteLine("Entered change portion");
        //                            GlobalData.SkipLevel = 0;
        //                            arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
        //                            if(lastSolvedLevelIndex == 0)
        //                            {
        //                                currentLevelIndex = 1;
        //                            }
        //                            else
        //                                currentLevelIndex = lastSolvedLevelIndex;
        //                            LevelChangeBar.Value = currentLevelIndex * 10;
        //                        }

        //                        GlobalData.SkipLevel = 1;
        //                        return;				
        //                    }
        //                }*/
        //                #endregion

        //                debugLineCounter++; //9

        //                lblLevelNo.Text = currentLevelIndex.ToString();
        //                //changes for valid level to be displayed.
        //                currentLevelId = Level.GetLevelId(currentLevelIndex);
        //                debugLineCounter++; //10
        //                //			if(arrLevels[currentLevelIndex].curPosX<6 || arrLevels[currentLevelIndex].curPosY < 6)
        //                //			{
        //                //				//Console.WriteLine("currentLevelIndex " + currentLevelIndex);
        //                //				//Console.WriteLine("currentLevelId " + currentLevelId);
        //                //				//Console.WriteLine("("+arrLevels[currentLevelIndex].curPosX+","+arrLevels[currentLevelIndex].curPosY+")");
        //                //				//Console.WriteLine(arrLevels[currentLevelIndex].getRoboXY(currentLevelId).X +"-"+arrLevels[currentLevelIndex].getRoboXY(currentLevelId).Y);
        //                //			}
        //                if(isSmoothScrollEnabled)
        //                {
        //                    iNextIndex = currentLevelIndex;
        //                }
        //                debugLineCounter++; //11

        //#if(DESIGNER)
        //                arrLevels[currentLevelIndex].IsLevelFinished = false;
        //                arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;
        //#endif
        //                //#if(CONTEST)
        //                //			txtCodeEditor.Text = arrLevels[currentLevelIndex].iCurrentProgram;
        //                //#endif
        //#if(DESIGNER)

        //                if(GlobalData.HerbertMode == HMode.Designer)
        //                {
        //                    //for designer
        //                    //cbDifficultyBucket.SelectedIndex = arrLevels[currentLevelIndex].getDifficultyBucket(currentLevelId)-1;
        //                    //currentLevelId = levelstodisp[Level.arrValidLevelNo[currentLevelId]];
        //                }
        //                //txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();


        //                /*==============================================================================
        //                 *  Added By : Vivek Balagangadharan
        //                 *  Description : Added to fix the issue id:3746
        //                 *  Added On : 18-Apr-2006
        //                 *  Special Comments : By making this read-only, the text change event code works
        //                 * ==============================================================================*/
        //                txtLevelPoints.ReadOnly = false;

        //                if(!arrLevels[currentLevelIndex].IsLevelUpdate)
        //                    txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
        //                else
        //                    txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();
        //                txtLevelPoints.Refresh();
        //                //added By Rajesh For adding level type 17/05/07
        //                if (arrLevels[currentLevelIndex].LevelType != "")
        //                    cmbxLevelType.Text = arrLevels[currentLevelIndex].LevelType;
        //                else
        //                    cmbxLevelType.Text = "Normal";
        //                //end
        //                txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex).Replace("\n","\r\n");
        //                if(GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate)
        //                {
        //                    //arrLevels[currentLevelIndex].updateBuffer();//By Rajesh,21/8/06,3885
        //                    arrLevels[currentLevelIndex].getLevelDataToUpdate(currentLevelId);
        //                    //arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelId);//By Rajesh,21/8/06,3885
        //                    //arrLevels[currentLevelIndex].getUpdatedLevelData(currentLevelId);
        //                }
        //#endif

        //                lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
        //                lblMaxChars.Text = "(Max " + arrLevels[currentLevelIndex].getMaxChar(currentLevelId).ToString() +")";
        //                debugLineCounter++; //12

        //                //txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex);
        //# if(CONTEST)
        //                lblTotalScore.Text = Level.totalScore.ToString()+"/"+iSumOfAllLevelPoints.ToString();
        //                if(currentLevelIndex > 0)
        //                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
        //                else
        //                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + currentLevelIndex.ToString();	
        //                debugLineCounter++; //13
        //#endif
        //#if(DESIGNER)
        //            if(currentLevelIndex > 0)
        //                lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
        //            else
        //                lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + lvlpoints.ToString();	
        //#endif
        //                //get the level status.
        //                //Commented by Vivek Balagangadharan
        //                // Description : 
        //                // Added On : 30-Aug-2005			
        //                //			if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
        //                //				lblLevelSolved.Text = "(Solved!)";
        //                //			else
        //                //				lblLevelSolved.Text = "(Unsolved)";

        //                iNumTimesLevelVisitedHelper = 0;
        //#if(CONTEST)

        //                if(isSmoothScrollEnabled)
        //                {
        //                    if(iNextIndex != iPrvIndex)
        //                    {
        //                        if(!blnSkeepLevel)
        //                        {
        //                            blnSkeepSmoothScrollPaint = false;
        //                            fScrollBoard();
        //                            GC.Collect();
        //                        }
        //                        else
        //                        {
        //                            Thread.Sleep(100);
        //                            GC.Collect();
        //                            blnSkeepSmoothScrollPaint = true;
        //                            blnSkeepLevel = false;
        //                            if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
        //                                lblLevelSolved.Text = "(Solved!)";
        //                            else
        //                                lblLevelSolved.Text = "(Unsolved)";
        //                        }
        //                    }
        //                }
        //                else
        //                {
        //                    Thread.Sleep(200);
        //                    if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
        //                        lblLevelSolved.Text = "(Solved!)";
        //                    else
        //                        lblLevelSolved.Text = "(Unsolved)";
        //                }
        //                debugLineCounter++; //14

        //                if(isLevelChangeLogged)
        //                {
        //                    sbErrorLog.Append("\n In ChangeLevel(), moving to level no.: " + currentLevelIndex.ToString());
        //                    sbErrorLog.Append("\n Current Level Program: "+arrLevels[currentLevelIndex].iCurrentProgram);
        //                }

        //#endif
        //#if(DESIGNER)

        //            resetHerbert();
        //#endif
        //#if(CONTEST)
        //                resetHerbertToPrevPos();
        //                debugLineCounter++; //15
        //#endif
        //#if(DESIGNER)

        //            if(isSmoothScrollEnabled)
        //            {
        //                if(iNextIndex != iPrvIndex)
        //                {				
        //                    if(!blnSkeepLevel)
        //                    {
        //                        blnSkeepSmoothScrollPaint = false;
        //                        fScrollBoard();
        //                        GC.Collect();
        //                    }
        //                    else
        //                    {
        //                        Thread.Sleep(100);
        //                        GC.Collect();
        //                        blnSkeepSmoothScrollPaint = true;
        //                        blnSkeepLevel = false;
        //                    }

        //                    /*==============================================================================
        //                     *  Commented By : Vivek Balagangadharan
        //                     *  Description : This was an old implementation which was to make sure that 
        //                     *				  level 0 does not load with single level designer.
        //                     *  Added On : 10-Apr-2006
        //                     *  Special Comments : 
        //                     * ==============================================================================*/
        ////					if(GlobalData.iLevelId > 0)
        ////					{
        ////						LevelChangeBar.Enabled = false;
        ////						txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
        ////					}
        //                    /* End */
        //                }
        //            }



        //#endif



        //#if(DESIGNER)
        //            txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex).Replace("\n","\r\n");
        //                if(!arrLevels[currentLevelIndex].IsLevelUpdate)
        //                    txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
        //                else
        //                    txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();
        //#if(PATTERN_GENERATER)
        //                if (currentLevelIndex != 0)
        //                {
        //                    if (arrLevels[currentLevelIndex].IsPatternEnabled)
        //                    {
        //                        this.hTooltip.SetToolTip(this.btShowPattern, "Remove Pattern");
        //                        btShowPattern.FlatStyle = FlatStyle.Flat;
        //                    }
        //                    else
        //                    {
        //                        this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
        //                        btShowPattern.FlatStyle = FlatStyle.Standard;
        //                    }
        //                }
        //                else
        //                {
        //                    this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
        //                    btShowPattern.FlatStyle = FlatStyle.Standard;
        //                }
        //#endif                
        //#endif
        //#if(CONTEST)
        //                txtCodeEditor.Text = arrLevels[currentLevelIndex].iCurrentProgram;
        //                //Added By Rajesh to fix the issue while scolling + Run+ pause event 22/05/07
        //                getTextData();
        //                debugLineCounter++; //16
        //#endif
        //#if(DESIGNER)
        //            IniOrResetRunMenu();			
        //#endif
        //#if(CONTEST)
        //                EnableAllItems();
        //                debugLineCounter++; //17
        //                if(!blnFirstFunctionCall && currentLevelIndex!=0 )
        //                {

        //                    //Added by Vivek Balagangadharan
        //                    // Description : retain all the previous menus
        //                    // Added On : 22-Jul-2005
        //                    if(arrLevels[currentLevelIndex].blnGoState)
        //                    {
        //                        mnuGoHrbt.Enabled=true;
        //                    }
        //                    else
        //                    {
        //                        mnuGoHrbt.Enabled=false;
        //                    }
        //                    debugLineCounter++; //18
        //                    if(!(arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnHaltState))
        //                    {
        //                        btGoPause.Enabled=false;
        //                    }
        //                    else
        //                    {
        //                        btGoPause.Enabled=true;
        //                    }
        //                    debugLineCounter++; //19
        //                    if(arrLevels[currentLevelIndex].blnHaltState)
        //                    {
        //                        mnuHaltHrbt.Enabled = true;
        //                    }
        //                    else
        //                    {
        //                        mnuHaltHrbt.Enabled = false;
        //                    }
        //                    debugLineCounter++; //20
        //                    if(arrLevels[currentLevelIndex].blnResetState)
        //                    {
        //                        mnuResetHerbt.Enabled = true;
        //                        btStop.Enabled = true;
        //                    }
        //                    else
        //                    {
        //                        mnuResetHerbt.Enabled = false;
        //                        btStop.Enabled = false;
        //                    }
        //                    if(arrLevels[currentLevelIndex].blnStepState)
        //                    {
        //                        mnuStepHrbt.Enabled = true;
        //                        btStep.Enabled = true;
        //                    }
        //                    else
        //                    {
        //                        mnuStepHrbt.Enabled = false;
        //                        btStep.Enabled = false;
        //                    }
        //                    if(arrLevels[currentLevelIndex].blnResumeState)
        //                    {
        //                        mnuResumeHrtb.Enabled = true;
        //                    }
        //                    else
        //                    {
        //                        mnuResumeHrtb.Enabled = false;
        //                    }
        //                    if(arrLevels[currentLevelIndex].goPauseState == 0)
        //                    {
        //                        btGoPause.Image = pbRun.Image;
        //                        if(arrLevels[currentLevelIndex].goClicked || arrLevels[currentLevelIndex].stepByStep)
        //                            this.hTooltip.SetToolTip(this.btGoPause, "Resume");
        //                        else
        //                            this.hTooltip.SetToolTip(this.btGoPause, "Go");	
        //                    }    
        //                    else
        //                    {
        //                        btGoPause.Image = pbPause.Image;
        //                        this.hTooltip.SetToolTip(this.btGoPause, "Pause");
        //                    }
        //                    debugLineCounter++; //21

        //                    if(!arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnResumeState)
        //                    {
        //                        ResumeHerbert();
        //                        //added By Rajesh to show eod messages. 14/05/07
        //                        if ((bool)arrLevels[currentLevelIndex].EndofProg)
        //                        {
        //                            DispMessage("End of program reached");
        //                        }
        //                    }
        //                    debugLineCounter++; //22
        //                }
        //                else /* in case of zeroth level or loaddata() */
        //                {
        //                    resetHerbert();
        //                    IniOrResetRunMenu();
        //                }
        //                blnFirstFunctionCall = false;


        //                //Added for smart save.
        //                arrLevels[currentLevelIndex].isLevelStatisticsChanged = true;
        //                debugLineCounter++; //23
        //#endif
        //            }
        //            catch(Exception exp)
        //            {
        //                if(isExceptionLogged)
        //                {
        //                    try
        //                    {
        //                        sbErrorLog.Append("\n Exception in ChangeLevel()");
        //                        sbErrorLog.Append("\n Exception Message: " + exp.Message);
        //                        sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
        //                        sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
        //                        sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
        //                        LogErrors();
        //                    }
        //                    catch
        //                    {
        //                    }
        //                }
        //            }
        //#if(DESIGNER)
        //            //indicates that the level scroll is over
        //            ///Rajesh
        //            if(currentLevelIndex!=0 && arrLevels[currentLevelIndex].IsLevelChanged!=true)
        //                mnuSaveLevel.Enabled=false;
        //            else if(currentLevelIndex==0)
        //                mnuSaveLevel.Enabled=true;
        //            ///end

        //            isLevelChanging = false;
        //#endif

        //        }
        private void ChangeLevel()
        {
#if(DESIGNER)
            //indicates that the level is changing(scroll started)
            isLevelChanging = true;
#endif
            int debugLineCounter = 0;
            try
            {
#if(CONTEST)

                DisableAllItems(false);
                ////Console.WriteLine("disable all items called");
                debugLineCounter++; //1

                //if it is not the first time this function is called, then stop herbert.
                // this function is called for the first time in loaddata()
                if (!blnFirstFunctionCall)
                {
                    StopHerbert();
                }
                else
                {
                    killThread();
                }
                debugLineCounter++; //2

#endif
#if(DESIGNER)
                killThread();
#endif

                //for smooth scorlling.
                if (isSmoothScrollEnabled)
                {
                    iPrvIndex = currentLevelIndex;
                }
                debugLineCounter++; //3

#if(DESIGNER)
                try
                {
                    if (GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate)
                    {
                        arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelId);
                    }
                }
                catch
                {
                    //MessageBox.Show(this,exp.Message);
                    //					//Console.WriteLine(exp.Message);
                }
# endif

                #region commented for new implementation logic for bucketing
                /*if(isBucketingEnabled)
				{
					//Added by Vivek Balagangadharan
					// Description : Added for temporarily implementing the bucketing factor.
					// Bucket size = 1. Levels reqd to be solved to move to next level = 100%
					// Hence, without solving the current level, higher level can't be accessed.
					// Added On : 12-Sep-2005
					if(!((arrLevels[currentLevelIndex].IsLevelFinished) || (currentLevelId == 0) || (currentLevelIndex>LevelChangeBar.Value/10) ))
					{
						if(GlobalData.SkipLevel == 1)
						{
							GlobalData.SkipLevel = 0;
							LevelChangeBar.Enabled = false;
							MethodInvoker mis = new MethodInvoker(displayLevelChangeMessage);
							this.Invoke(mis);
							LevelChangeBar.Enabled = true;
							LevelChangeBar.Value = currentLevelIndex * 10;
						}
						else
							if(GlobalData.SkipLevel == 0)
						{
							//GlobalData.SkipLevel = 1;
							if(!arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnResumeState)
							{
								GlobalData.SkipLevel = 1;
								ResumeHerbert();
							}
							else
								GlobalData.SkipLevel = 1;
						}
						return;
					}
				}*/
                #endregion

                debugLineCounter++; //4
                deSelectError();
                arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                debugLineCounter++; //5
# if(DESIGNER)
                Level.totalScore = 0;
                arrLevels[currentLevelIndex].levelScore = 0;
                arrLevels[currentLevelIndex].BestLevelScore = 0;
                Level.saveLevelPoints(currentLevelIndex, GlobalData.DeginerLevelPoints);
                Level.saveLevelProgram(currentLevelIndex, txtCodeEditor.Text);
                //arrLevels[currentLevelIndex].setNonSavedDesignData();//By Rajesh,21/8/06,3885

#endif
                arrLevels[currentLevelIndex].blnFirstStepClick = true;
                debugLineCounter++; //6

#if(CONTEST)
                if (isSiteDefaultUserId == 0)
                {
                    if (currentLevelIndex > 0)
                    {

                        if (!blnFirstFunctionCall)
                        {
                            DataRow[] drLevel = GlobalData.dsAllHData.Tables["tblGameLevelScore"].Select("LevelScoreId = '" + arrLevels[currentLevelIndex].LevelScoreId.ToString() + "'");

                            if (String.Compare(drLevel[0]["CurrentProgram"].ToString(), arrLevels[currentLevelIndex].iCurrentProgram) != 0)
                            {
                                arrLevels[currentLevelIndex].isLevelDataChanged = true;
                            }
                        }

                        for (int i = 0; i < arrLevels.Length; i++)
                        {
                            if (arrLevels[i].isLevelDataChanged)
                            {
                                if ((arrLevels[currentLevelIndex].tSaveLevel == null) || (arrLevels[currentLevelIndex].tSaveLevel.ThreadState != System.Threading.ThreadState.Running))
                                {
                                    arrLevels[currentLevelIndex].tSaveLevel = new Thread(new ThreadStart(SavePerLevelData));
                                    arrLevels[currentLevelIndex].tSaveLevel.Name = "Silent Save (" + DateTime.Now.ToShortTimeString() + ")";
                                    arrLevels[currentLevelIndex].tSaveLevel.Priority = ThreadPriority.Highest;
                                    arrLevels[currentLevelIndex].tSaveLevel.Start();
                                    break;
                                }
                            }
                        }
                    }
                }
                debugLineCounter++; //7
#endif

                //changes for contest 11/02/05.
                //get the value of current level.
#if(DESIGNER)
                if ((!isSingleLevelDesigner) || (currentLevelIndex == 0))
                {
#endif
                if (isLevelChangeLogged)
                {
                    sbErrorLog.Append("\n In ChangeLevel(), moving from level no.: " + currentLevelIndex.ToString());
                    sbErrorLog.Append("\n Current Level Program: " + arrLevels[currentLevelIndex].iCurrentProgram);
                }
                currentLevelIndex = LevelChangeBar.Value / 10;
                debugLineCounter++; //8
                //			if(currentLevelIndex == arrLevels.Length-1)
                //			{
                //				//Console.WriteLine("first");
                //				//Console.WriteLine("currentLevelIndex " + currentLevelIndex);
                //				//Console.WriteLine("currentLevelId " + currentLevelId);
                //				//Console.WriteLine("("+arrLevels[currentLevelIndex].curPosX+","+arrLevels[currentLevelIndex].curPosY+")");
                //				//Console.WriteLine(arrLevels[currentLevelIndex].getRoboXY(currentLevelId).X +"-"+arrLevels[currentLevelIndex].getRoboXY(currentLevelId).Y);
                //				//Console.WriteLine("end");
                //			}

#if(DESIGNER)
                }
#endif

                #region commented for new implementation logic for bucketing
                /*if(isBucketingEnabled)
				{
					////Console.WriteLine("Going to: " + currentLevelIndex.ToString());
				
					//Added by Vivek Balagangadharan
					// Description : To check cases where level change bar dragged to come to a higher level 
					// Added On : 19-Sep-2005
					int lastSolvedLevelIndex = 0;
					if(currentLevelIndex>0)
					{
						lastSolvedLevelIndex = currentLevelIndex - 1;
					}
					////Console.WriteLine("Hence last solved level should be: " + lastSolvedLevelIndex.ToString());
					while(lastSolvedLevelIndex > 0)
					{
						if(!arrLevels[lastSolvedLevelIndex].IsLevelFinished)
						{
							lastSolvedLevelIndex--;
						}
						else
						{
							break;
						}
					}

					////Console.WriteLine("Last solved level is: {0}" , lastSolvedLevelIndex.ToString());
					if((lastSolvedLevelIndex >= 0)&&(currentLevelIndex>0)&&(lastSolvedLevelIndex != currentLevelIndex-1))
					{
						if(GlobalData.SkipLevel == 1)
						{
							//Console.WriteLine("Entered change portion");
							GlobalData.SkipLevel = 0;
							arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
							if(lastSolvedLevelIndex == 0)
							{
								currentLevelIndex = 1;
							}
							else
								currentLevelIndex = lastSolvedLevelIndex;
							LevelChangeBar.Value = currentLevelIndex * 10;
						}

						GlobalData.SkipLevel = 1;
						return;				
					}
				}*/
                #endregion

                debugLineCounter++; //9

                lblLevelNo.Text = currentLevelIndex.ToString();
                //changes for valid level to be displayed.
                currentLevelId = Level.GetLevelId(currentLevelIndex);
                debugLineCounter++; //10
                //			if(arrLevels[currentLevelIndex].curPosX<6 || arrLevels[currentLevelIndex].curPosY < 6)
                //			{
                //				//Console.WriteLine("currentLevelIndex " + currentLevelIndex);
                //				//Console.WriteLine("currentLevelId " + currentLevelId);
                //				//Console.WriteLine("("+arrLevels[currentLevelIndex].curPosX+","+arrLevels[currentLevelIndex].curPosY+")");
                //				//Console.WriteLine(arrLevels[currentLevelIndex].getRoboXY(currentLevelId).X +"-"+arrLevels[currentLevelIndex].getRoboXY(currentLevelId).Y);
                //			}
                if (isSmoothScrollEnabled)
                {
                    iNextIndex = currentLevelIndex;
                }
                debugLineCounter++; //11

#if(DESIGNER)
                arrLevels[currentLevelIndex].IsLevelFinished = false;
                arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;
#endif
                //#if(CONTEST)
                //			txtCodeEditor.Text = arrLevels[currentLevelIndex].iCurrentProgram;
                //#endif
#if(DESIGNER)

                if (GlobalData.HerbertMode == HMode.Designer)
                {
                    //for designer
                    //cbDifficultyBucket.SelectedIndex = arrLevels[currentLevelIndex].getDifficultyBucket(currentLevelId)-1;
                    //currentLevelId = levelstodisp[Level.arrValidLevelNo[currentLevelId]];
                }
                //txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();


                /*==============================================================================
                 *  Added By : Vivek Balagangadharan
                 *  Description : Added to fix the issue id:3746
                 *  Added On : 18-Apr-2006
                 *  Special Comments : By making this read-only, the text change event code works
                 * ==============================================================================*/
                txtLevelPoints.ReadOnly = false;

                if (!arrLevels[currentLevelIndex].IsLevelUpdate)
                    txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
                else
                    txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();
                txtLevelPoints.Refresh();

                //added By Rajesh For adding level type 17/05/07
                if (arrLevels[currentLevelIndex].LevelType != "")
                    cmbxLevelType.Text = arrLevels[currentLevelIndex].LevelType;
                else
                    cmbxLevelType.Text = "Normal";
                //end

                txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex).Replace("\n", "\r\n");
                if (GlobalData.HerbertMode == HMode.Designer )
                {
                    //arrLevels[currentLevelIndex].updateBuffer();//By Rajesh,21/8/06,3885
                    arrLevels[currentLevelIndex].getLevelDataToUpdate(currentLevelId);
                    //arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelId);//By Rajesh,21/8/06,3885
                    //arrLevels[currentLevelIndex].getUpdatedLevelData(currentLevelId);
                }
#endif

                lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
                lblMaxChars.Text = "(Max " + arrLevels[currentLevelIndex].getMaxChar(currentLevelId).ToString() + ")";
                debugLineCounter++; //12

                //txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex);
# if(CONTEST)
                lblTotalScore.Text = Level.totalScore.ToString() + "/" + iSumOfAllLevelPoints.ToString();
                if (currentLevelIndex > 0)
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                else
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + currentLevelIndex.ToString();
                debugLineCounter++; //13
#endif
#if(DESIGNER)
                if (currentLevelIndex > 0)
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                else
                    lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + lvlpoints.ToString();
#endif
                //get the level status.
                //Commented by Vivek Balagangadharan
                // Description : 
                // Added On : 30-Aug-2005			
                //			if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                //				lblLevelSolved.Text = "(Solved!)";
                //			else
                //				lblLevelSolved.Text = "(Unsolved)";

                iNumTimesLevelVisitedHelper = 0;
#if(CONTEST)

                if (isSmoothScrollEnabled)
                {
                    if (iNextIndex != iPrvIndex)
                    {
                        if (!blnSkeepLevel)
                        {
                            blnSkeepSmoothScrollPaint = false;
                            fScrollBoard();
                            GC.Collect();
                        }
                        else
                        {
                            Thread.Sleep(100);
                            GC.Collect();
                            blnSkeepSmoothScrollPaint = true;
                            blnSkeepLevel = false;
                            if (arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                                lblLevelSolved.Text = "(Solved!)";
                            else
                                lblLevelSolved.Text = "(Unsolved)";
                        }
                    }
                }
                else
                {
                    Thread.Sleep(200);
                    if (arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                        lblLevelSolved.Text = "(Solved!)";
                    else
                        lblLevelSolved.Text = "(Unsolved)";
                }


                // added by Nikhil Kardale on 07/01/2008 to fix issue id. 3230
                if (lblLevelNo.Text == "0")
                    lblLevelSolved.Visible = false;
                else
                    lblLevelSolved.Visible = true;


                debugLineCounter++; //14

                if (isLevelChangeLogged)
                {
                    sbErrorLog.Append("\n In ChangeLevel(), moving to level no.: " + currentLevelIndex.ToString());
                    sbErrorLog.Append("\n Current Level Program: " + arrLevels[currentLevelIndex].iCurrentProgram);
                }

#endif
#if(DESIGNER)
                // added by Nikhil Kardale on 07/01/2008 to fix issue id. 3230
                if (lblLevelNo.Text == "0")
                    lblLevelSolved.Visible = false;
                else
                    lblLevelSolved.Visible = true;
                resetHerbert();
#endif
#if(CONTEST)
                resetHerbertToPrevPos();
                debugLineCounter++; //15
#endif
#if(DESIGNER)

                if (isSmoothScrollEnabled)
                {
                    if (iNextIndex != iPrvIndex)
                    {
                        if (!blnSkeepLevel)
                        {
                            blnSkeepSmoothScrollPaint = false;
                            fScrollBoard();
                            GC.Collect();
                        }
                        else
                        {
                            Thread.Sleep(100);
                            GC.Collect();
                            blnSkeepSmoothScrollPaint = true;
                            blnSkeepLevel = false;
                        }

                        /*==============================================================================
                         *  Commented By : Vivek Balagangadharan
                         *  Description : This was an old implementation which was to make sure that 
                         *				  level 0 does not load with single level designer.
                         *  Added On : 10-Apr-2006
                         *  Special Comments : 
                         * ==============================================================================*/
                        //					if(GlobalData.iLevelId > 0)
                        //					{
                        //						LevelChangeBar.Enabled = false;
                        //						txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
                        //					}
                        /* End */
                    }
                }



#endif



#if(DESIGNER)
                txtCodeEditor.Text = Level.getLevelProgram(currentLevelIndex).Replace("\n", "\r\n");
                if (!arrLevels[currentLevelIndex].IsLevelUpdate)
                    txtLevelPoints.Text = Level.fgetLevelPoints(currentLevelId).ToString();
                else
                    txtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();
#if(PATTERN_GENERATER)
                if (currentLevelIndex != 0)
                {
                    if (arrLevels[currentLevelIndex].IsPatternEnabled)
                    {
                        this.hTooltip.SetToolTip(this.btShowPattern, "Remove Pattern");
                        btShowPattern.FlatStyle = FlatStyle.Flat;
                        // added by Nikhil Kardale on 20/03/2008 to resolve issue id. 10919
                        mnuShowPattern.Checked = true;
                        mnuShowPattern.Text = "Remove Pattern";
                    }
                    else
                    {
                        this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                        btShowPattern.FlatStyle = FlatStyle.Standard;
                        // added by Nikhil Kardale on 20/03/2008 to resolve issue id. 10919
                        mnuShowPattern.Checked = false;
                        mnuShowPattern.Text = "Show Pattern";
                    }
                }
                else
                {
                    this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                    btShowPattern.FlatStyle = FlatStyle.Standard;
                    // added by Nikhil Kardale on 20/03/2008 to resolve issue id. 10919
                    mnuShowPattern.Checked = false;
                    mnuShowPattern.Text = "Show Pattern";
                }
#endif

#endif
#if(CONTEST)
                txtCodeEditor.Text = arrLevels[currentLevelIndex].iCurrentProgram;
                debugLineCounter++; //16
#endif
#if(DESIGNER)
                IniOrResetRunMenu();
#endif
#if(CONTEST)
                EnableAllItems();
                debugLineCounter++; //17
                if (!blnFirstFunctionCall && currentLevelIndex != 0)
                {

                    //Added by Vivek Balagangadharan
                    // Description : retain all the previous menus
                    // Added On : 22-Jul-2005
                    if (arrLevels[currentLevelIndex].blnGoState)
                    {
                        mnuGoHrbt.Enabled = true;
                    }
                    else
                    {
                        mnuGoHrbt.Enabled = false;
                    }
                    debugLineCounter++; //18
                    if (!(arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnHaltState))
                    {
                        btGoPause.Enabled = false;
                    }
                    else
                    {
                        btGoPause.Enabled = true;
                    }
                    debugLineCounter++; //19
                    if (arrLevels[currentLevelIndex].blnHaltState)
                    {
                        mnuHaltHrbt.Enabled = true;
                    }
                    else
                    {
                        mnuHaltHrbt.Enabled = false;
                    }
                    debugLineCounter++; //20
                    if (arrLevels[currentLevelIndex].blnResetState)
                    {
                        mnuResetHerbt.Enabled = true;
                        btStop.Enabled = true;
                    }
                    else
                    {
                        mnuResetHerbt.Enabled = false;
                        btStop.Enabled = false;
                    }
                    if (arrLevels[currentLevelIndex].blnStepState)
                    {
                        mnuStepHrbt.Enabled = true;
                        btStep.Enabled = true;
                    }
                    else
                    {
                        mnuStepHrbt.Enabled = false;
                        btStep.Enabled = false;
                    }
                    if (arrLevels[currentLevelIndex].blnResumeState)
                    {
                        mnuResumeHrtb.Enabled = true;
                    }
                    else
                    {
                        mnuResumeHrtb.Enabled = false;
                    }
                    if (arrLevels[currentLevelIndex].goPauseState == 0)
                    {
                        btGoPause.Image = pbRun.Image;
                        if (arrLevels[currentLevelIndex].goClicked || arrLevels[currentLevelIndex].stepByStep)
                            this.hTooltip.SetToolTip(this.btGoPause, "Resume");
                        else
                            this.hTooltip.SetToolTip(this.btGoPause, "Go");
                    }
                    else
                    {
                        btGoPause.Image = pbPause.Image;
                        this.hTooltip.SetToolTip(this.btGoPause, "Pause");
                    }
                    debugLineCounter++; //21

                    if (!arrLevels[currentLevelIndex].blnGoState || arrLevels[currentLevelIndex].blnResumeState)
                    {
                        ResumeHerbert();
                    }
                    debugLineCounter++; //22
                }
                else /* in case of zeroth level or loaddata() */
                {
                    resetHerbert();
                    IniOrResetRunMenu();
                }
                blnFirstFunctionCall = false;


                //Added for smart save.
                arrLevels[currentLevelIndex].isLevelStatisticsChanged = true;
                debugLineCounter++; //23
#endif
            }
            catch (Exception exp)
            {
                if (isExceptionLogged)
                {
                    try
                    {
                        sbErrorLog.Append("\n Exception in ChangeLevel()");
                        sbErrorLog.Append("\n Exception Message: " + exp.Message);
                        sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                        sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                        sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                        LogErrors();
                    }
                    catch
                    {
                    }
                }
            }
#if(DESIGNER)
            //indicates that the level scroll is over
            ///Rajesh
            if (currentLevelIndex != 0 && arrLevels[currentLevelIndex].IsLevelChanged != true)
                mnuSaveLevel.Enabled = false;
            else if (currentLevelIndex == 0)
                mnuSaveLevel.Enabled = true;
            ///end

            isLevelChanging = false;
#endif

        }

        /// <summary>
        /// this method is used for placing level scroll bar properly.
        /// </summary>
        private void setLevelScrollProperly()
        {
            try
            {
                int x = 0, y = 0;
                x = Math.DivRem(LevelChangeBar.Value, 10, out y);

                if (x == 0)// && levelChangeValue != x )//|| y<3))
                {
#if(CONTEST)
                    blnProgramaticallyLevelChanged = true;
                    LevelChangeBar.Value = x * 10;
#endif

                    /*==============================================================================
					*  Added By : Vivek Balagangadharan
					*  Description : Added to solve the issue of scrollbar not scrolling on level 0,
					*				  with no other levels.
					*  Added On : 18-Apr-2006
					* ==============================================================================*/
#if(DESIGNER)
					blnProgramaticallyLevelChanged = true;
					if(arrLevels.Length > 1)
					{
						LevelChangeBar.Value = x*10;
					}
#endif
                }
                else if ((x) * 10 >= LevelChangeBar.Maximum - 10)
                {
                    blnProgramaticallyLevelChanged = true;
                    LevelChangeBar.Value += 1;
                }
                blnProgramaticallyLevelChanged = false;
            }
            catch
            {
                blnProgramaticallyLevelChanged = false;
            }
        }

        /// <summary>
        /// min max time both has to be provided by user.
        /// </summary>
        /// <param name="iMinSeed"></param>
        /// <param name="iMaxSeed"></param>
        /// <returns></returns>
        internal int GetRandomDelay(int iMinSeed, int iMaxSeed)
        {
            RNGCryptoServiceProvider objRCSP = new RNGCryptoServiceProvider();
            Byte[] rnd = new byte[1];
            objRCSP.GetNonZeroBytes(rnd);
            int seed = iMaxSeed * int.Parse(rnd[0].ToString());
            Random rd = new Random(seed);
            int x = rd.Next(iMinSeed, seed);
            int y = x / int.Parse(rnd[0].ToString());
            return y;
        }

        /// <summary>
        /// min time in this function is 0.
        /// </summary>
        /// <param name="iMaxSeed"></param>
        /// <returns></returns>
        internal int GetRandomDelay(int iMaxSeed)
        {
            RNGCryptoServiceProvider objRCSP = new RNGCryptoServiceProvider();
            Byte[] rnd = new byte[1];
            objRCSP.GetNonZeroBytes(rnd);
            int seed = iMaxSeed * int.Parse(rnd[0].ToString());
            Random rd = new Random(seed);
            int x = rd.Next(0, seed);
            int y = x / int.Parse(rnd[0].ToString());
            return y;
        }
        #endregion

        #region Contest Related Methods
# if(CONTEST)

        private void UploadSolutionsInDBForThread()
        {
            UploadSolutionsInDB(false);
        }

        /// <summary>
        /// this function is called when upload solutions is clicked.
        /// </summary>
        private void UploadSolutionsInDB()
        {

            int debugLineCounter = 0;
            if (GlobalData.HerbertMode != HMode.Tutorial)
            {
                /*
                 * Add By : Rajesh
                 * To convert the local date into the en-us format.
                 * 19-Dec-06
                 */
                DateTimeFormatInfo dfi = new DateTimeFormatInfo();
                CultureInfo ci = new CultureInfo("en-us");
                dfi.MonthDayPattern = "mm/dd/yy";
                ci.DateTimeFormat = dfi;
                /*end*/
                //int levelCount = arrLevels.Length-1;
                int levelCount = 0;

                arrLevels[currentLevelIndex].isLevelStatisticsChanged = true;
                debugLineCounter++; //1

                for (int i = 1; i < arrLevels.Length; i++)
                {
                    if (arrLevels[i].isLevelStatisticsChanged)
                    {
                        levelCount++;
                    }
                }
                debugLineCounter++; //2

                object[] arrLevelScoreId = new object[levelCount];
                object[] arrlvlpCurrently = new object[levelCount];
                object[] arrlvlp = new object[levelCount];
                object[] arrlvlscore = new object[levelCount];
                //object[] arrMaxlvlScore = new object[levelCount];
                object[] arrbyteused = new object[levelCount];
                object[] arrlvlstatus = new object[levelCount];
                object[] arrlvltimespend = new object[levelCount];
                object[] arrLevelId = new object[levelCount];
                object[] arrdotspressed = new object[levelCount];
                object[] arrNumGoAttempted = new object[levelCount];
                object[] arrNumTimesLevelVisited = new object[levelCount];
                object[] arrFirstSolutionDT = new object[levelCount];
                object[] arrNumCharTyped = new object[levelCount];
                object[] arrFirstCharTypedDT = new object[levelCount];
                object[] arrFristSolution = new object[levelCount];
                object[] arrFristSolutionBytes = new object[levelCount];
                object[] arrTotGoAttempted = new object[levelCount];
                object[] arrTotTimeSpend = new object[levelCount];

                object[] arrFirstGos = new object[levelCount];
                object[] arrFirstTimeSpent = new object[levelCount];
                object[] arrFirstCharsTyped = new object[levelCount];
                object[] arrBestDate = new object[levelCount];
                object[] arrBestCharsTyped = new object[levelCount];
                object[] arrBestVisits = new object[levelCount];
                object[] arrLastDate = new object[levelCount];
                object[] arrLastProgram = new object[levelCount];
                object[] arrLastBytes = new object[levelCount];
                object[] arrLastGos = new object[levelCount];
                object[] arrLastTimeSpent = new object[levelCount];
                object[] arrLastCharsTyped = new object[levelCount];
                object[] arrLastVisits = new object[levelCount];
                object[] arrFirstScore = new object[levelCount];
                object[] arrFirstVisits = new object[levelCount];
                object[] arrTotalCharsTyped = new object[levelCount];

                object[] updatedLevelIndex = new object[levelCount];

                debugLineCounter++; //3

                try
                {
                    deSelectError();
                    arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                    DisableAllItems(true);
                    lblClosing.Refresh();
                    debugLineCounter++; //4

                    this.Refresh();
                    if (GameInterval <= 0)
                        Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay));

#if(THREADSLEEP)					
					Thread.Sleep(300);
#endif
                    //calculate the total time game is palyed in minutes.
                    TotalGameTimeInMinSpent += ((TotalTimeInSecRemaining - GameInterval) / 60);
                    debugLineCounter++; //5
                    int index = 0;
                    //get all level data in arrays.
                    for (int i = 1; i < arrLevels.Length; i++)
                    {
                        if (arrLevels[i].isLevelStatisticsChanged)
                        {
                            try
                            {
                                if (isMismatchProbeOn)
                                {
                                    //2 indicates that the check is done during file -> Upload Solutions
                                    ScoreMismatchCheck(i, 2);
                                }
                            }
                            catch
                            {
                            }

                            arrLevelScoreId[index] = DisableMyMenu(arrLevels[i].LevelScoreId, GlobalData.GUID, 2);
                            arrlvlpCurrently[index] = DisableMyMenu(arrLevels[i].iCurrentProgram, GlobalData.GUID, 2);
                            arrlvlp[index] = DisableMyMenu(arrLevels[i].iBestProgram, GlobalData.GUID, 2);
                            arrlvlscore[index] = DisableMyMenu(arrLevels[i].levelScore, GlobalData.GUID, 2);
                            arrbyteused[index] = DisableMyMenu(arrLevels[i].iBestBytes, GlobalData.GUID, 2);
                            arrlvlstatus[index] = DisableMyMenu((arrLevels[i].IsLevelFinishedPersistant ? 1 : 0), GlobalData.GUID, 2);
                            arrlvltimespend[index] = DisableMyMenu(arrLevels[i].iBestTimeSpent, GlobalData.GUID, 2);
                            arrLevelId[index] = DisableMyMenu(Level.arrLevelId[i], GlobalData.GUID, 2);
                            arrdotspressed[index] = DisableMyMenu(arrLevels[i].numDotsPressed, GlobalData.GUID, 2);
                            arrNumGoAttempted[index] = DisableMyMenu(arrLevels[i].iBestGos, GlobalData.GUID, 2);
                            arrNumTimesLevelVisited[index] = DisableMyMenu(arrLevels[i].pNumVisits, GlobalData.GUID, 2);
                            //						arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrFirstSolutionDT[index] = DisableMyMenu(formatDate(arrLevels[i].iFirstDate),GlobalData.GUID,2);
                            //arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);//changed By Rajesh
                            arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(ci), GlobalData.GUID, 2);
                            arrNumCharTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //						arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrFirstCharTypedDT[index] = DisableMyMenu(formatDate(arrLevels[i].FirstCharTypedDT),GlobalData.GUID,2);
                            //arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);//Cahnged By Rajesh
                            arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(ci), GlobalData.GUID, 2);
                            arrFristSolution[index] = DisableMyMenu(arrLevels[i].iFirstProgram, GlobalData.GUID, 2);
                            arrFristSolutionBytes[index] = DisableMyMenu(arrLevels[i].iFirstBytes, GlobalData.GUID, 2);
                            arrTotGoAttempted[index] = DisableMyMenu(arrLevels[i].iTotalGos, GlobalData.GUID, 2);
                            arrTotTimeSpend[index] = DisableMyMenu(arrLevels[i].iTotalTimeSpent, GlobalData.GUID, 2);

                            arrFirstGos[index] = DisableMyMenu(arrLevels[i].iFirstGos, GlobalData.GUID, 2);
                            arrFirstTimeSpent[index] = DisableMyMenu(arrLevels[i].iFirstTimeSpent, GlobalData.GUID, 2);
                            arrFirstCharsTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //						arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrBestDate[index] = DisableMyMenu(formatDate(arrLevels[i].iBestDate),GlobalData.GUID,2);
                            //arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2); Changed By rajesh 19-dec
                            arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(ci), GlobalData.GUID, 2);
                            arrBestCharsTyped[index] = DisableMyMenu(arrLevels[i].iBestCharsTyped, GlobalData.GUID, 2);
                            arrBestVisits[index] = DisableMyMenu(arrLevels[i].iBestVisits, GlobalData.GUID, 2);
                            //						arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrLastDate[index] = DisableMyMenu(formatDate(arrLevels[i].iLastDate),GlobalData.GUID,2);
                            //arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(ci), GlobalData.GUID, 2);

                            arrLastProgram[index] = DisableMyMenu(arrLevels[i].iLastProgram, GlobalData.GUID, 2);
                            arrLastBytes[index] = DisableMyMenu(arrLevels[i].iLastBytes, GlobalData.GUID, 2);
                            arrLastGos[index] = DisableMyMenu(arrLevels[i].iLastGos, GlobalData.GUID, 2);
                            arrLastTimeSpent[index] = DisableMyMenu(arrLevels[i].iLastTimeSpent, GlobalData.GUID, 2);
                            arrLastCharsTyped[index] = DisableMyMenu(arrLevels[i].iLastCharsTyped, GlobalData.GUID, 2);
                            arrLastVisits[index] = DisableMyMenu(arrLevels[i].iLastVisits, GlobalData.GUID, 2);
                            arrFirstScore[index] = DisableMyMenu(arrLevels[i].iFirstLevelScore, GlobalData.GUID, 2);
                            arrFirstVisits[index] = DisableMyMenu(arrLevels[i].iFirstVisits, GlobalData.GUID, 2);
                            arrTotalCharsTyped[index] = DisableMyMenu(arrLevels[i].iTotalCharsTyped, GlobalData.GUID, 2);

                            updatedLevelIndex[index] = i;

                            index++;
                        }
                    }
                    debugLineCounter++; //5

                    Object TraceOnOff = (mnuTrace.Checked) ? 1 : 0;
                    //Added by rajesh
                    //Date 8/8/06
                    //Issue :3305, to restore toolBar state
                    Object ToolBarOnOff = (mnuToolBar.Checked) ? 1 : 0;
                    Object PathOnOff = (mnuPath.Checked) ? 1 : 0;
                    Object SmoothScrollOnOff = (mnuSmoothScroll.Checked) ? 1 : 0;

                    debugLineCounter++; //6
                    TraceOnOff = DisableMyMenu(TraceOnOff, GlobalData.GUID, 2);
                    ToolBarOnOff = DisableMyMenu(ToolBarOnOff, GlobalData.GUID, 2);
                    PathOnOff = DisableMyMenu(PathOnOff, GlobalData.GUID, 2);
                    SmoothScrollOnOff = DisableMyMenu(SmoothScrollOnOff, GlobalData.GUID, 2);
                    debugLineCounter++; //7

                    Object oper = EnableMyMenu(GlobalData.GUID);
                    int iUSScoreSaveDBRetryCount = 0;
                    //Object values = DisableMyMenu(plain);
                    Object values = DisableMyMenu(plain, GlobalData.GUID, 2);
#if(CONTEST)
                    Object VersionNo = DisableMyMenu(Application.ProductVersion, GlobalData.GUID, 2);
#endif
#if(DESIGNER)
					Object VersionNo = DisableMyMenu("1.0.3.14",GlobalData.GUID,2);
#endif
                    //					Object endTime = DisableMyMenu((InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval)).ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                    //					Object endTime = DisableMyMenu(formatDate(InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval)),GlobalData.GUID,2);
                    //Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                    Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(ci), GlobalData.GUID, 2);
                    Object IdScore = DisableMyMenu(ScoreId, GlobalData.GUID, 2);
                    Object IdContestant = DisableMyMenu(GlobalData.ContestantId, GlobalData.GUID, 2);
                    Object scoreTotal = DisableMyMenu(Level.totalScore, GlobalData.GUID, 2);
                    Object timeTotal = DisableMyMenu(TotalGameTimeInMinSpent, GlobalData.GUID, 2);
                    //					Object dateStart = DisableMyMenu(startdate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                    //					Object dateStart = DisableMyMenu(formatDate(startdate),GlobalData.GUID,2);


                    // Object dateStart = DisableMyMenu(startdate.ToString("mm/dd/yy"),GlobalData.GUID,2);

                    Object dateStart = DisableMyMenu(startdate.ToString(ci), GlobalData.GUID, 2);
                    Object indexCurrent = DisableMyMenu(currentLevelIndex, GlobalData.GUID, 2);
                    //uploadStatus = 2 in case of Uploading solutions from file menu
                    int uploadStatus = 2;
                    Object reason = DisableMyMenu(uploadStatus, GlobalData.GUID, 2);
                    debugLineCounter++; //8

                    try
                    {
                        //GlobalData.initlizeWS();




                        while (true)
                        {
#if(DLL)
							GlobalData.initlizeWS();
#else
                            HSUploadSolution = new Designer.HService.HDataService();
                            HSUploadSolution.Url = GlobalData.URL;
                            HSUploadSolution.Timeout = GlobalData.sessionTimeOut;
                            HSUploadSolution.PreAuthenticate = true;
                            HSUploadSolution.Proxy = GlobalData.GetProxy();
                            debugLineCounter++; //9
#endif

                            try
                            {
#if(RTDEBUG)
						int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
							Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
							arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
							arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
							currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
							arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2,strDebugLog);
#else
                                //						int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
                                //							Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
                                //							arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
                                //							arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
                                //							currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
                                //							arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2);


#if(DLL)
								int z = (int)GlobalData.DS.VerifyData(oper, IdScore, IdContestant,
									scoreTotal, timeTotal, dateStart, endTime,arrLevelScoreId,
									arrlvlpCurrently,arrlvlp,arrlvlscore,arrbyteused,arrlvlstatus,
									arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
									indexCurrent, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
									arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,reason,arrTotGoAttempted,arrTotTimeSpend,
									arrFirstGos,arrFirstTimeSpent,arrBestDate,arrBestCharsTyped,arrBestVisits,
									arrLastDate,arrLastProgram,arrLastBytes,arrLastGos,arrLastTimeSpent,arrLastCharsTyped,
									arrLastVisits,arrFirstScore,arrFirstVisits,arrTotalCharsTyped,iUSScoreSaveDBRetryCount, SmoothScrollOnOff);
#else
                                //Added by rajesh
                                //Date 8/8/06
                                //Issue :3305, to restore toolBar state, ToolBarOnOff parameter added.
                                int z = (int)HSUploadSolution.VerifyData(oper, IdScore, IdContestant,
                                    scoreTotal, timeTotal, dateStart, endTime, arrLevelScoreId,
                                    arrlvlpCurrently, arrlvlp, arrlvlscore, arrbyteused, arrlvlstatus,
                                    arrlvltimespend, arrLevelId, arrdotspressed, arrNumGoAttempted, arrNumTimesLevelVisited,
                                    indexCurrent, TraceOnOff, values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
                                    arrFirstCharTypedDT, arrFristSolution, arrFristSolutionBytes, reason, arrTotGoAttempted, arrTotTimeSpend,
                                    arrFirstGos, arrFirstTimeSpent, arrBestDate, arrBestCharsTyped, arrBestVisits,
                                    arrLastDate, arrLastProgram, arrLastBytes, arrLastGos, arrLastTimeSpent, arrLastCharsTyped,
                                    arrLastVisits, arrFirstScore, arrFirstVisits, arrTotalCharsTyped, iUSScoreSaveDBRetryCount, SmoothScrollOnOff, ToolBarOnOff);

                                if (z == -1)
                                {
                                    DialogResult dgEndContest = new DialogResult();
                                    dgEndContest = MessageBox.Show(this, "Sorry, your scores cannot be uploaded because contest has closed.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    if (dgEndContest == DialogResult.OK)
                                        Application.Exit();
                                }

#endif
                                debugLineCounter++; //10
                                for (int i = 0; i < levelCount; i++)
                                {
                                    arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = false;
                                }
                                debugLineCounter++; //11
#endif
                                break;
                            }
                            catch (Exception exp)
                            {

                                //								//Console.WriteLine(exp.Message);
                                iUSScoreSaveDBRetryCount++;
                                if (GameInterval <= 0)
                                    Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay / 10, GlobalData.iIniSeedRandomDelay));
                                // add code for offline version proxy check here - Nikhil Kardale
                                // ------------ added by NikhilK to fix issue 9552 ---------------
                                if (exp.Message.IndexOf("HTTP status 407") >= 0 || exp.Message.IndexOf("Unauthorized") >= 0 || exp.Message.IndexOf("HTTP status 403") >= 0)
                                {
                                    /*Start: Added By Rajesh to show credential window*/
                                    try
                                    {
                                        DialogResult drNetwork = DialogResult.No;
                                        Login lNetwork = new Login();

                                        lNetwork.CheckForProxyForOfflineVersion();
                                        lNetwork.ShowNetworkLoginWindow();
                                        drNetwork = lNetwork.ShowDialog();
                                    }
                                    catch (Exception innerExp)
                                    {
                                        if (exp.Message.IndexOf("Request for the permission") >= 0)
                                        {
                                            MessageBox.Show(this, "H0093: Herbert exe does not have enough permissions. \nTo grant this permission please see the help section.", "Login error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                            return;
                                        }
                                        else
                                        {

                                        }
                                    }
                                }
                                // ---------------------------------------------------------------

                                if (iUSScoreSaveDBRetryCount >= 3)
                                {
                                    if (exp.Message.IndexOf("timed-out") > 0)
                                    {
                                        YesNoCancel = MessageBox.Show(this, "H0009: There was an error in uploading your solutions. Connection to the server timed out.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0009: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                //sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    else if (exp.Message.IndexOf("HS0011") >= 0)
                                    {
                                        if (!isInstanceInvalidWarningDisplayed)
                                        {
                                            MessageBox.Show(this, "H0017: Your solutions could not be uploaded. \nSince you launched this instance of Herbert, another instance has started. \nPlease close the current instance and switch to the new instance, or launch Herbert again if there is no other instance.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                            //Commented By Rajesh 26-4-07//isInstanceInvalidWarningDisplayed = true;
                                        }
                                        EnableAllItems();
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0017: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                        return;


                                    }
                                    else if (exp.Message.IndexOf("underlying connection was closed") > 0 || exp.Message.IndexOf("remote name could not be resolved") > 0)
                                    {
                                        YesNoCancel = MessageBox.Show(this, "H0010: There was an error in uploading your solutions. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error);
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0010: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                //LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    else
                                    {
                                        YesNoCancel = MessageBox.Show(this, "H0011: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error);
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0011: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    for (int i = 0; i < levelCount; i++)
                                    {
                                        arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = true;
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception exp)
                    {
                        MessageBox.Show(this, "H0012: There was an error uploading your solutions. Could not connect to the server.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        if (isExceptionLogged)
                        {
                            try
                            {
                                sbErrorLog.Append("\n H0012: Exception Message: " + exp.Message);
                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                LogErrors();
                            }
                            catch
                            {
                            }
                        }
                    }
                }
                catch (Exception exp)
                {
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n H0012: Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
#if(ERRORLOG)
					try
					{
						GlobalData.initlizeWS(); //try initializing and log error
						Object oper = EnableMyMenu(GlobalData.GUID);
						Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
						Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
						GlobalData.HS.DisplayInfo(IdContestant,oper,error );
					}
					catch{}
#endif
                }
                finally
                {
                    //set null all arrays.
                    arrlvlp = null;
                    arrlvlscore = null;
                    arrbyteused = null;
                    arrlvlstatus = null;
                    arrlvltimespend = null;
                    arrLevelId = null;
                    arrdotspressed = null;
                    arrNumGoAttempted = null;

#if(DLL)
					if(GlobalData.DS!=null)
						GlobalData.DS.Dispose();
					GlobalData.DS = null;					
#else
                    if (HSUploadSolution != null)
                        HSUploadSolution.Dispose();
                    HSUploadSolution = null;
#endif
                }
            }
        }

        /// <summary>
        /// For silent upload to the database
        /// </summary>
        /// <param name="bNotify"></param>
        private void UploadSolutionsInDB(bool bNotify)
        {
            int debugLineCounter = 0;
            if (GlobalData.HerbertMode != HMode.Tutorial)
            {
                /*
                * Add By : Rajesh
                * To convert the local date into the en-us format.
                * 19-Dec-06
                */
                DateTimeFormatInfo dfi = new DateTimeFormatInfo();
                CultureInfo ci = new CultureInfo("en-us");
                dfi.MonthDayPattern = "mm/dd/yy";
                ci.DateTimeFormat = dfi;
                /*end*/
                //int levelCount = arrLevels.Length-1;
                int levelCount = 0;

                arrLevels[currentLevelIndex].isLevelStatisticsChanged = true;
                debugLineCounter++; //1

                for (int i = 1; i < arrLevels.Length; i++)
                {
                    if (arrLevels[i].isLevelStatisticsChanged)
                    {
                        levelCount++;
                    }
                }
                debugLineCounter++; //2

                object[] arrLevelScoreId = new object[levelCount];
                object[] arrlvlpCurrently = new object[levelCount];
                object[] arrlvlp = new object[levelCount];
                object[] arrlvlscore = new object[levelCount];
                //object[] arrMaxlvlScore = new object[levelCount];
                object[] arrbyteused = new object[levelCount];
                object[] arrlvlstatus = new object[levelCount];
                object[] arrlvltimespend = new object[levelCount];
                object[] arrLevelId = new object[levelCount];
                object[] arrdotspressed = new object[levelCount];
                object[] arrNumGoAttempted = new object[levelCount];
                object[] arrNumTimesLevelVisited = new object[levelCount];
                object[] arrFirstSolutionDT = new object[levelCount];
                object[] arrNumCharTyped = new object[levelCount];
                object[] arrFirstCharTypedDT = new object[levelCount];
                object[] arrFristSolution = new object[levelCount];
                object[] arrFristSolutionBytes = new object[levelCount];
                object[] arrTotGoAttempted = new object[levelCount];
                object[] arrTotTimeSpend = new object[levelCount];

                object[] arrFirstGos = new object[levelCount];
                object[] arrFirstTimeSpent = new object[levelCount];
                object[] arrFirstCharsTyped = new object[levelCount];
                object[] arrBestDate = new object[levelCount];
                object[] arrBestCharsTyped = new object[levelCount];
                object[] arrBestVisits = new object[levelCount];
                object[] arrLastDate = new object[levelCount];
                object[] arrLastProgram = new object[levelCount];
                object[] arrLastBytes = new object[levelCount];
                object[] arrLastGos = new object[levelCount];
                object[] arrLastTimeSpent = new object[levelCount];
                object[] arrLastCharsTyped = new object[levelCount];
                object[] arrLastVisits = new object[levelCount];
                object[] arrFirstScore = new object[levelCount];
                object[] arrFirstVisits = new object[levelCount];
                object[] arrTotalCharsTyped = new object[levelCount];

                object[] updatedLevelIndex = new object[levelCount];

                debugLineCounter++; //3

                try
                {
                    //deSelectError();
                    arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                    //DisableAllItems(true);
                    //lblClosing.Refresh();
                    debugLineCounter++; //4

                    //this.Refresh();
                    if (GameInterval <= 60 * 60)
                        Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay));

#if(THREADSLEEP)					
					Thread.Sleep(300);
#endif
                    //calculate the total time game is palyed in minutes.
                    TotalGameTimeInMinSpent += ((TotalTimeInSecRemaining - GameInterval) / 60);
                    debugLineCounter++; //5
                    int index = 0;
                    //get all level data in arrays.
                    for (int i = 1; i < arrLevels.Length; i++)
                    {
                        if (arrLevels[i].isLevelStatisticsChanged)
                        {
                            try
                            {
                                if (isMismatchProbeOn)
                                {
                                    //2 indicates that the check is done during file -> Upload Solutions
                                    ScoreMismatchCheck(i, 2);
                                }
                            }
                            catch
                            {
                            }

                            arrLevelScoreId[index] = DisableMyMenu(arrLevels[i].LevelScoreId, GlobalData.GUID, 2);
                            arrlvlpCurrently[index] = DisableMyMenu(arrLevels[i].iCurrentProgram, GlobalData.GUID, 2);
                            arrlvlp[index] = DisableMyMenu(arrLevels[i].iBestProgram, GlobalData.GUID, 2);
                            arrlvlscore[index] = DisableMyMenu(arrLevels[i].levelScore, GlobalData.GUID, 2);
                            arrbyteused[index] = DisableMyMenu(arrLevels[i].iBestBytes, GlobalData.GUID, 2);
                            arrlvlstatus[index] = DisableMyMenu((arrLevels[i].IsLevelFinishedPersistant ? 1 : 0), GlobalData.GUID, 2);
                            arrlvltimespend[index] = DisableMyMenu(arrLevels[i].iBestTimeSpent, GlobalData.GUID, 2);
                            arrLevelId[index] = DisableMyMenu(Level.arrLevelId[i], GlobalData.GUID, 2);
                            arrdotspressed[index] = DisableMyMenu(arrLevels[i].numDotsPressed, GlobalData.GUID, 2);
                            arrNumGoAttempted[index] = DisableMyMenu(arrLevels[i].iBestGos, GlobalData.GUID, 2);
                            arrNumTimesLevelVisited[index] = DisableMyMenu(arrLevels[i].pNumVisits, GlobalData.GUID, 2);
                            //						arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrFirstSolutionDT[index] = DisableMyMenu(formatDate(arrLevels[i].iFirstDate),GlobalData.GUID,2);
                            //arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(ci), GlobalData.GUID, 2);
                            arrNumCharTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //						arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrFirstCharTypedDT[index] = DisableMyMenu(formatDate(arrLevels[i].FirstCharTypedDT),GlobalData.GUID,2);
                            //arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(ci), GlobalData.GUID, 2);
                            arrFristSolution[index] = DisableMyMenu(arrLevels[i].iFirstProgram, GlobalData.GUID, 2);
                            arrFristSolutionBytes[index] = DisableMyMenu(arrLevels[i].iFirstBytes, GlobalData.GUID, 2);
                            arrTotGoAttempted[index] = DisableMyMenu(arrLevels[i].iTotalGos, GlobalData.GUID, 2);
                            arrTotTimeSpend[index] = DisableMyMenu(arrLevels[i].iTotalTimeSpent, GlobalData.GUID, 2);

                            arrFirstGos[index] = DisableMyMenu(arrLevels[i].iFirstGos, GlobalData.GUID, 2);
                            arrFirstTimeSpent[index] = DisableMyMenu(arrLevels[i].iFirstTimeSpent, GlobalData.GUID, 2);
                            arrFirstCharsTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //						arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrBestDate[index] = DisableMyMenu(formatDate(arrLevels[i].iBestDate),GlobalData.GUID,2);
                            //arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(ci), GlobalData.GUID, 2);
                            arrBestCharsTyped[index] = DisableMyMenu(arrLevels[i].iBestCharsTyped, GlobalData.GUID, 2);
                            arrBestVisits[index] = DisableMyMenu(arrLevels[i].iBestVisits, GlobalData.GUID, 2);
                            //						arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                            //						arrLastDate[index] = DisableMyMenu(formatDate(arrLevels[i].iLastDate),GlobalData.GUID,2);
                            //arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(ci), GlobalData.GUID, 2);

                            arrLastProgram[index] = DisableMyMenu(arrLevels[i].iLastProgram, GlobalData.GUID, 2);
                            arrLastBytes[index] = DisableMyMenu(arrLevels[i].iLastBytes, GlobalData.GUID, 2);
                            arrLastGos[index] = DisableMyMenu(arrLevels[i].iLastGos, GlobalData.GUID, 2);
                            arrLastTimeSpent[index] = DisableMyMenu(arrLevels[i].iLastTimeSpent, GlobalData.GUID, 2);
                            arrLastCharsTyped[index] = DisableMyMenu(arrLevels[i].iLastCharsTyped, GlobalData.GUID, 2);
                            arrLastVisits[index] = DisableMyMenu(arrLevels[i].iLastVisits, GlobalData.GUID, 2);
                            arrFirstScore[index] = DisableMyMenu(arrLevels[i].iFirstLevelScore, GlobalData.GUID, 2);
                            arrFirstVisits[index] = DisableMyMenu(arrLevels[i].iFirstVisits, GlobalData.GUID, 2);
                            arrTotalCharsTyped[index] = DisableMyMenu(arrLevels[i].iTotalCharsTyped, GlobalData.GUID, 2);

                            updatedLevelIndex[index] = i;

                            index++;
                        }
                    }
                    debugLineCounter++; //5

                    Object TraceOnOff = (mnuTrace.Checked) ? 1 : 0;
                    //Added by rajesh
                    //Date 8/8/06
                    //Issue :3305, to restore toolBar state
                    Object ToolBarOnOff = (mnuToolBar.Checked) ? 1 : 0;
                    Object PathOnOff = (mnuPath.Checked) ? 1 : 0;
                    Object SmoothScrollOnOff = (mnuSmoothScroll.Checked) ? 1 : 0;

                    debugLineCounter++; //6
                    TraceOnOff = DisableMyMenu(TraceOnOff, GlobalData.GUID, 2);
                    ToolBarOnOff = DisableMyMenu(ToolBarOnOff, GlobalData.GUID, 2);
                    PathOnOff = DisableMyMenu(PathOnOff, GlobalData.GUID, 2);
                    SmoothScrollOnOff = DisableMyMenu(SmoothScrollOnOff, GlobalData.GUID, 2);
                    debugLineCounter++; //7

                    Object oper = EnableMyMenu(GlobalData.GUID);
                    int iUSScoreSaveDBRetryCount = 0;
                    //Object values = DisableMyMenu(plain);
                    Object values = DisableMyMenu(plain, GlobalData.GUID, 2);
#if(CONTEST)

                    Object VersionNo = DisableMyMenu(Application.ProductVersion, GlobalData.GUID, 2);
#endif
#if(DESIGNER)
					Object VersionNo = DisableMyMenu("1.0.2.193",GlobalData.GUID,2);
#endif
                    //					Object endTime = DisableMyMenu((InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval)).ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                    //					Object endTime = DisableMyMenu(formatDate(InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval)),GlobalData.GUID,2);
                    //Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                    Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(ci), GlobalData.GUID, 2);
                    Object IdScore = DisableMyMenu(ScoreId, GlobalData.GUID, 2);
                    Object IdContestant = DisableMyMenu(GlobalData.ContestantId, GlobalData.GUID, 2);
                    Object scoreTotal = DisableMyMenu(Level.totalScore, GlobalData.GUID, 2);
                    Object timeTotal = DisableMyMenu(TotalGameTimeInMinSpent, GlobalData.GUID, 2);
                    //					Object dateStart = DisableMyMenu(startdate.ToString("yyyy-MM-dd HH:mm:ss"),GlobalData.GUID,2);
                    //					Object dateStart = DisableMyMenu(formatDate(startdate),GlobalData.GUID,2);
                    //Object dateStart = DisableMyMenu(startdate.ToString("mm/dd/yy"),GlobalData.GUID,2);
                    Object dateStart = DisableMyMenu(startdate.ToString(ci), GlobalData.GUID, 2);
                    Object indexCurrent = DisableMyMenu(currentLevelIndex, GlobalData.GUID, 2);
                    //uploadStatus = 2 in case of Uploading solutions from file menu
                    int uploadStatus = 2;
                    Object reason = DisableMyMenu(uploadStatus, GlobalData.GUID, 2);
                    debugLineCounter++; //8

                    try
                    {
                        //GlobalData.initlizeWS();




                        while (true)
                        {
#if(DLL)
							GlobalData.initlizeWS();
#else
                            HSUploadSolution = new Designer.HService.HDataService();
                            HSUploadSolution.Url = GlobalData.URL;
                            HSUploadSolution.Timeout = GlobalData.sessionTimeOut;
                            HSUploadSolution.PreAuthenticate = true;
                            HSUploadSolution.Proxy = GlobalData.GetProxy();
                            debugLineCounter++; //9
#endif

                            try
                            {
#if(RTDEBUG)
						int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
							Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
							arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
							arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
							currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
							arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2,strDebugLog);
#else
                                //						int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
                                //							Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
                                //							arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
                                //							arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
                                //							currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
                                //							arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2);


#if(DLL)
								int z = (int)GlobalData.DS.VerifyData(oper, IdScore, IdContestant,
									scoreTotal, timeTotal, dateStart, endTime,arrLevelScoreId,
									arrlvlpCurrently,arrlvlp,arrlvlscore,arrbyteused,arrlvlstatus,
									arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
									indexCurrent, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
									arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,reason,arrTotGoAttempted,arrTotTimeSpend,
									arrFirstGos,arrFirstTimeSpent,arrBestDate,arrBestCharsTyped,arrBestVisits,
									arrLastDate,arrLastProgram,arrLastBytes,arrLastGos,arrLastTimeSpent,arrLastCharsTyped,
									arrLastVisits,arrFirstScore,arrFirstVisits,arrTotalCharsTyped,iUSScoreSaveDBRetryCount, SmoothScrollOnOff);
#else
                                //Added by rajesh
                                //Date 8/8/06
                                //Issue :3305, to restore toolBar state,ToolBar parameter added
                                int z = (int)HSUploadSolution.VerifyData(oper, IdScore, IdContestant,
                                    scoreTotal, timeTotal, dateStart, endTime, arrLevelScoreId,
                                    arrlvlpCurrently, arrlvlp, arrlvlscore, arrbyteused, arrlvlstatus,
                                    arrlvltimespend, arrLevelId, arrdotspressed, arrNumGoAttempted, arrNumTimesLevelVisited,
                                    indexCurrent, TraceOnOff, values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
                                    arrFirstCharTypedDT, arrFristSolution, arrFristSolutionBytes, reason, arrTotGoAttempted, arrTotTimeSpend,
                                    arrFirstGos, arrFirstTimeSpent, arrBestDate, arrBestCharsTyped, arrBestVisits,
                                    arrLastDate, arrLastProgram, arrLastBytes, arrLastGos, arrLastTimeSpent, arrLastCharsTyped,
                                    arrLastVisits, arrFirstScore, arrFirstVisits, arrTotalCharsTyped, iUSScoreSaveDBRetryCount, SmoothScrollOnOff, ToolBarOnOff);

                                if (z == -1)
                                {
                                    DialogResult dgEndContest = new DialogResult();
                                    dgEndContest = MessageBox.Show(this, "Sorry, your scores cannot be uploaded because contest has closed.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    if (dgEndContest == DialogResult.OK)
                                        Application.Exit();
                                }

#endif
                                debugLineCounter++; //10
                                for (int i = 0; i < levelCount; i++)
                                {
                                    arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = false;
                                }
                                debugLineCounter++; //11
#endif
                                if (!bNotify)
                                    blnIsSilentSaveSuccessful = !bNotify;
                                break;
                            }
                            catch (Exception exp)
                            {

                                //								//Console.WriteLine(exp.Message);
                                iUSScoreSaveDBRetryCount++;
                                if (GameInterval <= 60 * 60)
                                    Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay / 10, GlobalData.iIniSeedRandomDelay));

                                // add code for offline version proxy check here - Nikhil Kardale
                                // ------------ added by NikhilK to fix issue 9552 ---------------
                                if (exp.Message.IndexOf("HTTP status 407") >= 0 || exp.Message.IndexOf("Unauthorized") >= 0 || exp.Message.IndexOf("HTTP status 403") >= 0)
                                {
                                    /*Start: Added By Rajesh to show credential window*/
                                    try
                                    {
                                        DialogResult drNetwork = DialogResult.No;
                                        Login lNetwork = new Login();

                                        lNetwork.CheckForProxyForOfflineVersion();
                                        lNetwork.ShowNetworkLoginWindow();
                                        drNetwork = lNetwork.ShowDialog();
                                    }
                                    catch (Exception innerExp)
                                    {
                                        if (exp.Message.IndexOf("Request for the permission") >= 0)
                                        {
                                            MessageBox.Show(this, "H0093: Herbert exe does not have enough permissions. \nTo grant this permission please see the help section.", "Login error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                            return;
                                        }
                                        else
                                        {

                                        }
                                    }
                                }
                                // ---------------------------------------------------------------

                                if (iUSScoreSaveDBRetryCount >= 3)
                                {
                                    if (exp.Message.IndexOf("timed-out") > 0)
                                    {
                                        YesNoCancel = bNotify ? MessageBox.Show(this, "H0009: There was an error in uploading your solutions. Connection to the server timed out.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) : DialogResult.No;
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            //EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0009: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    else if (exp.Message.IndexOf("underlying connection was closed") > 0)
                                    {
                                        YesNoCancel = bNotify ? MessageBox.Show(this, "H0010: There was an error in uploading your solutions. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error) : DialogResult.No;
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            //EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0010: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    else
                                    {
                                        YesNoCancel = bNotify ? MessageBox.Show(this, "H0011: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error) : DialogResult.No;
                                        if (YesNoCancel == DialogResult.No)
                                        {
                                            //EnableAllItems();
                                            return;
                                        }
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0011: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                    }
                                    for (int i = 0; i < levelCount; i++)
                                    {
                                        arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = true;
                                    }
                                }
                            }
                        }
                    }
                    catch (Exception exp)
                    {
                        if (bNotify)
                            MessageBox.Show(this, "H0012: There was an error uploading your solutions. Could not connect to the server.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        if (isExceptionLogged)
                        {
                            try
                            {
                                sbErrorLog.Append("\n H0012: Exception Message: " + exp.Message);
                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                                sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                                LogErrors();
                            }
                            catch
                            {
                            }
                        }
                    }
                }
                catch (Exception exp)
                {
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n H0012: Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
#if(ERRORLOG)
					try
					{
						GlobalData.initlizeWS(); //try initializing and log error
						Object oper = EnableMyMenu(GlobalData.GUID);
						Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
						Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
						GlobalData.HS.DisplayInfo(IdContestant,oper,error );
					}
					catch{}
#endif
                }
                finally
                {
                    //set null all arrays.
                    arrlvlp = null;
                    arrlvlscore = null;
                    arrbyteused = null;
                    arrlvlstatus = null;
                    arrlvltimespend = null;
                    arrLevelId = null;
                    arrdotspressed = null;
                    arrNumGoAttempted = null;

#if(DLL)
					if(GlobalData.DS!=null)
						GlobalData.DS.Dispose();
					GlobalData.DS = null;					
#else
                    if (HSUploadSolution != null)
                        HSUploadSolution.Dispose();
                    HSUploadSolution = null;
#endif
                }
            }
        }

        /*==============================================================================
        *  Function Name : ScoreMismatchCheck
        *  Parameters : Level Index
        *  Return values : none
        *  Description : Function used for checking and logging a score mismatch.
        *  Created On : 02-Mar-2006
        *  Created By : Vivek Balagangadharan
        *  Special Comments : Added during maintenance of ic2006 on 02-Mar-2006
        * ==========================================================-===================*/
        private void ScoreMismatchCheck(int index, int SaveMode)
        {
            int CalculatedScore = arrLevels[index].CalcScore(arrLevels[index].numDotsPressed, arrLevels[index].iBestBytes, Level.GetLevelId(index));
            //int CalculatedScore = arrLevels[index].CalcScore(arrLevels[index].numDotsPressed,10,Level.GetLevelId(index));
            if (CalculatedScore != arrLevels[index].levelScore)
            {
                try
                {
                    sbErrorLog.Append("\n----------------------------------------------------");
                    sbErrorLog.Append("\nScore Mismatch found in exe : ");
                    switch (SaveMode)
                    {
                        case 1: sbErrorLog.Append("\nSave on Level Scroll");
                            break;
                        case 2: sbErrorLog.Append("\nSave on File -> Upload Solutions");
                            break;
                        case 3: sbErrorLog.Append("\nSave on Exit");
                            break;
                        default: sbErrorLog.Append("\nSave mode not found!!");
                            break;
                    }
                    sbErrorLog.Append("\nLevelScoreId from DB: " + arrLevels[index].LevelScoreId.ToString());
                    sbErrorLog.Append("\nCalculated Score: " + CalculatedScore.ToString());
                    sbErrorLog.Append("\nHerbert exe score: " + arrLevels[index].levelScore.ToString());
                    sbErrorLog.Append("\nBest Bytes : " + arrLevels[index].iBestBytes.ToString());
                    sbErrorLog.Append("\nNumber of buttons pressed: " + arrLevels[index].numDotsPressed.ToString());
                    sbErrorLog.Append("\nTemp variables: Current Score: " + arrLevels[index].scoreCurrently.ToString() + " BytesUsed: " + arrLevels[index].charused.ToString() + "Number of dots: " + arrLevels[index].temp_numDotsPressed.ToString());
                    sbErrorLog.Append("\n----------------------------------------------------");
                    LogErrors();
                }
                catch
                {
                    // do nothing
                }
            }
        }


        /*==============================================================================
        *  Function Name : SavePerLevelData
        *  Parameters : none
        *  Return values : none
        *  Description : Function used for silent save during level change.
        *  Created On : 15-Nov-2005
        *  Created By : Vinay Shanker Prasad
        *  Last Modified On : 22-Nov-2005
        *  Last Modified By : Vivek Balagangadharan
        *  Special Comments : 
        * ==============================================================================*/

        /// <summary>
        /// this function will save all data for a perticualar level and any other level's data
        /// which is not saved in the last save. this function will be invoked in a thread.
        /// </summary>
        private void SavePerLevelData()
        {

            /// <summary>
            /// the number of levels for which data is to be updated to the server.
            /// </summary>
            /*
                * Add By : Rajesh
                * To convert the local date into the en-us format.
                * 19-Dec-06
                */
            DateTimeFormatInfo dfi = new DateTimeFormatInfo();
            CultureInfo ci = new CultureInfo("en-us");
            dfi.MonthDayPattern = "mm/dd/yy";
            ci.DateTimeFormat = dfi;
            /*end*/

            int levelCount = 0;

            for (int i = 0; i < arrLevels.Length; i++)
            {
                if (arrLevels[i].isLevelDataChanged)
                {
                    levelCount++;
                }
            }

            object[] arrLevelScoreId = new object[levelCount];
            object[] arrlvlProgCurrently = new object[levelCount];
            object[] arrlvlProgBest = new object[levelCount];
            object[] arrlvlscore = new object[levelCount];
            object[] arrbyteused = new object[levelCount];
            object[] arrlvlstatus = new object[levelCount];
            object[] arrdotspressed = new object[levelCount];
            object[] arrTotGoAttempted = new object[levelCount];
            object[] arrFirstSolution = new object[levelCount];
            object[] arrFirstBytes = new object[levelCount];
            object[] arrTotTimeSpend = new object[levelCount];
            object[] arrBestSolutionDate = new object[levelCount];
            object[] arrLastProgram = new object[levelCount];
            object[] arrLastBytes = new object[levelCount];
            object[] arrFirstScore = new object[levelCount];

            object[] updatedLevelIndex = new object[levelCount];

            try
            {

                //arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;

                int index = 0;

                //get all level data in arrays.
                for (int i = 0; i < arrLevels.Length; i++)
                {
                    if (arrLevels[i].isLevelDataChanged)
                    {
                        arrLevels[i].isLevelDataChanged = false;
                        try
                        {
                            if (isMismatchProbeOn)
                            {
                                //1 indicates that the check is done during save on level scroll
                                ScoreMismatchCheck(i, 1);
                            }
                        }
                        catch
                        {
                        }

                        arrLevelScoreId[index] = DisableMyMenu(arrLevels[i].LevelScoreId, GlobalData.GUID, 2);

                        DataRow[] drLevel = GlobalData.dsAllHData.Tables["tblGameLevelScore"].Select("LevelScoreId = '" + arrLevels[i].LevelScoreId.ToString() + "'");

                        /* Current Program */
                        if (String.Compare(drLevel[0]["CurrentProgram"].ToString(), arrLevels[i].iCurrentProgram) == 0)
                        {
                            arrlvlProgCurrently[index] = null;
                        }
                        else
                        {
                            arrlvlProgCurrently[index] = DisableMyMenu(arrLevels[i].iCurrentProgram, GlobalData.GUID, 2);
                        }

                        /* Best Program */
                        if (String.Compare(drLevel[0]["BestProgram"].ToString(), arrLevels[i].iBestProgram) == 0)
                        {
                            arrlvlProgBest[index] = null;
                        }
                        else
                        {
                            arrlvlProgBest[index] = DisableMyMenu(arrLevels[i].iBestProgram, GlobalData.GUID, 2);
                        }

                        /* Level Score */
                        if (int.Parse(drLevel[0]["LevelScore"].ToString()) == arrLevels[i].levelScore)
                        {
                            arrlvlscore[index] = null;
                        }
                        else
                        {
                            arrlvlscore[index] = DisableMyMenu(arrLevels[i].levelScore, GlobalData.GUID, 2);
                        }

                        /* Best Bytes */
                        if (int.Parse(drLevel[0]["BestBytes"].ToString()) == arrLevels[i].iBestBytes)
                        {
                            arrbyteused[index] = null;
                        }
                        else
                        {
                            arrbyteused[index] = DisableMyMenu(arrLevels[i].iBestBytes, GlobalData.GUID, 2);
                        }

                        /* Level Status */
                        if (bool.Parse(drLevel[0]["LevelStatus"].ToString()) == (arrLevels[i].IsLevelFinishedPersistant))
                        {
                            arrlvlstatus[index] = null;
                        }
                        else
                        {
                            arrlvlstatus[index] = DisableMyMenu((arrLevels[i].IsLevelFinishedPersistant ? 1 : 0), GlobalData.GUID, 2);
                        }

                        /* Best Num Buttons Pressed */
                        if (int.Parse(drLevel[0]["BestNumButtonsPressed"].ToString()) == arrLevels[i].numDotsPressed)
                        {
                            arrdotspressed[index] = null;
                        }
                        else
                        {
                            arrdotspressed[index] = DisableMyMenu(arrLevels[i].numDotsPressed, GlobalData.GUID, 2);
                        }

                        /* Best Num Buttons Pressed */
                        if (int.Parse(drLevel[0]["TotalGos"].ToString()) == arrLevels[i].iTotalGos)
                        {
                            arrTotGoAttempted[index] = null;
                        }
                        else
                        {
                            arrTotGoAttempted[index] = DisableMyMenu(arrLevels[i].iTotalGos, GlobalData.GUID, 2);
                        }

                        /* First Program */
                        if (String.Compare(drLevel[0]["FirstProgram"].ToString(), arrLevels[i].iFirstProgram) == 0)
                        {
                            arrFirstSolution[index] = null;
                        }
                        else
                        {
                            arrFirstSolution[index] = DisableMyMenu(arrLevels[i].iFirstProgram, GlobalData.GUID, 2);
                        }

                        /* First Bytes */
                        if (int.Parse(drLevel[0]["FirstBytes"].ToString()) == arrLevels[i].iFirstBytes)
                        {
                            arrFirstBytes[index] = null;
                        }
                        else
                        {
                            arrFirstBytes[index] = DisableMyMenu(arrLevels[i].iFirstBytes, GlobalData.GUID, 2);
                        }

                        /* Total Time Spent */
                        if (int.Parse(drLevel[0]["TotalTimeSpent"].ToString()) == arrLevels[i].iTotalTimeSpent)
                        {
                            arrTotTimeSpend[index] = null;
                        }
                        else
                        {
                            arrTotTimeSpend[index] = DisableMyMenu(arrLevels[i].iTotalTimeSpent, GlobalData.GUID, 2);
                        }

                        /* Best Solution Date */
                        if (DateTime.Compare(DateTime.Parse(drLevel[0]["BestDate"].ToString()), arrLevels[i].iBestDate) == 0)
                        {
                            arrBestSolutionDate[index] = null;
                        }
                        else
                        {
                            //arrBestSolutionDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrBestSolutionDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(ci), GlobalData.GUID, 2);
                        }

                        /* Last Program */
                        if (String.Compare(drLevel[0]["LastProgram"].ToString(), arrLevels[i].iLastProgram) == 0)
                        {
                            arrLastProgram[index] = null;
                        }
                        else
                        {
                            arrLastProgram[index] = DisableMyMenu(arrLevels[i].iLastProgram, GlobalData.GUID, 2);
                        }

                        /* Last Bytes */
                        if (int.Parse(drLevel[0]["LastBytes"].ToString()) == arrLevels[i].iLastBytes)
                        {
                            arrLastBytes[index] = null;
                        }
                        else
                        {
                            arrLastBytes[index] = DisableMyMenu(arrLevels[i].iLastBytes, GlobalData.GUID, 2);
                        }

                        /* First Score*/
                        if (int.Parse(drLevel[0]["FirstScore"].ToString()) == arrLevels[i].iFirstLevelScore)
                        {
                            arrFirstScore[index] = null;
                        }
                        else
                        {
                            arrFirstScore[index] = DisableMyMenu(arrLevels[i].iFirstLevelScore, GlobalData.GUID, 2);
                        }

                        updatedLevelIndex[index] = i;
                        index++;
                    }
                }//end of for loop

                Object oper = EnableMyMenu(GlobalData.GUID);
                Object values = DisableMyMenu(plain, GlobalData.GUID, 2);
                Object IdContestantForLevels = DisableMyMenu(GlobalData.ContestantId, GlobalData.GUID, 2);

                try
                {
                    //GlobalData.initlizeWS();
                    //GlobalData.HS.Timeout = 30000;

                    while (true)
                    {
#if(DLL)

						GlobalData.initlizeWS();
#else
                        HSLevelSave = new Designer.HService.HDataService();
                        HSLevelSave.Url = GlobalData.URL;
                        HSLevelSave.Timeout = GlobalData.sessionTimeOut;
                        HSLevelSave.PreAuthenticate = true;
                        HSLevelSave.Proxy = GlobalData.GetProxy();
#endif

                        try
                        {
#if(DLL)

							GlobalData.DS.VerifyDataLevel(oper, values, ScoreSaveDBRetryCount, arrLevelScoreId,
								arrlvlProgCurrently,arrlvlProgBest,arrlvlscore,arrbyteused,arrlvlstatus,
								arrdotspressed, arrTotGoAttempted, arrFirstSolution, arrFirstBytes, arrTotTimeSpend,
								arrBestSolutionDate, arrLastProgram, arrLastBytes, arrFirstScore);

#else
                            
                                HSLevelSave.VerifyDataLevel(oper, values, ScoreSaveDBRetryCount, arrLevelScoreId,
                                    arrlvlProgCurrently, arrlvlProgBest, arrlvlscore, arrbyteused, arrlvlstatus,
                                    arrdotspressed, arrTotGoAttempted, arrFirstSolution, arrFirstBytes, arrTotTimeSpend,
                                    arrBestSolutionDate, arrLastProgram, arrLastBytes, arrFirstScore);
                           
                            

                            //int z = HSLevelSave.VerifyDataLevel(oper, values, ScoreSaveDBRetryCount, arrLevelScoreId,
                            //    arrlvlProgCurrently, arrlvlProgBest, arrlvlscore, arrbyteused, arrlvlstatus,
                            //    arrdotspressed, arrTotGoAttempted, arrFirstSolution, arrFirstBytes, arrTotTimeSpend,
                            //    arrBestSolutionDate, arrLastProgram, arrLastBytes, arrFirstScore, IdContestantForLevels);

                            //if (z == -1)
                            //{
                            //    DialogResult dgEndContest = new DialogResult();
                            //    dgEndContest= MessageBox.Show(this, "Sorry, your scores cannot be uploaded because contest has closed.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            //    if (dgEndContest == DialogResult.OK)
                            //        Application.Exit();
                            //}
#endif

                            //							GlobalData.dsAllHData.Tables["tblGameLevelScore"].LoadDataRow(

                            try
                            {
                                int colCount = GlobalData.dsAllHData.Tables["tblGameLevelScore"].Columns.Count;
                                // Create an array for the values.
                                object[] newRow = new object[colCount];
                                // Set the values of the array.
                                for (int i = 0; i < levelCount; i++)
                                {

                                    DataRow[] drLevel = GlobalData.dsAllHData.Tables["tblGameLevelScore"].Select("LevelScoreId = '" + Decrypt(arrLevelScoreId[i], GlobalData.GUID, 2).ToString() + "'");
                                    newRow = drLevel[0].ItemArray;

                                    //Updating Current Program in the dataset
                                    if (arrlvlProgCurrently[i] != null)
                                    {
                                        newRow[3] = Decrypt(arrlvlProgCurrently[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Best Program in the dataset
                                    if (arrlvlProgBest[i] != null)
                                    {
                                        newRow[4] = Decrypt(arrlvlProgBest[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Level Score in the dataset
                                    if (arrlvlscore[i] != null)
                                    {
                                        newRow[5] = Decrypt(arrlvlscore[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Best bytes in the dataset
                                    if (arrbyteused[i] != null)
                                    {
                                        newRow[6] = Decrypt(arrbyteused[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Level Status in the dataset
                                    if (arrlvlstatus[i] != null)
                                    {
                                        newRow[7] = Decrypt(arrlvlstatus[i], GlobalData.GUID, 2);
                                    }

                                    //Updating BestNumButtonPressed in the dataset
                                    if (arrdotspressed[i] != null)
                                    {
                                        newRow[10] = Decrypt(arrdotspressed[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Total Gos in the dataset
                                    if (arrTotGoAttempted[i] != null)
                                    {
                                        newRow[19] = Decrypt(arrTotGoAttempted[i], GlobalData.GUID, 2);
                                    }

                                    //Updating First Program in the dataset
                                    if (arrFirstSolution[i] != null)
                                    {
                                        newRow[14] = Decrypt(arrFirstSolution[i], GlobalData.GUID, 2);
                                    }

                                    //Updating First Bytes in the dataset
                                    if (arrFirstBytes[i] != null)
                                    {
                                        newRow[13] = Decrypt(arrFirstBytes[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Total time spent in the dataset
                                    if (arrTotTimeSpend[i] != null)
                                    {
                                        newRow[20] = Decrypt(arrTotTimeSpend[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Best solution date in the dataset
                                    if (arrBestSolutionDate[i] != null)
                                    {
                                        newRow[23] = Decrypt(arrBestSolutionDate[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Last Program in the dataset
                                    if (arrLastProgram[i] != null)
                                    {
                                        newRow[27] = Decrypt(arrLastProgram[i], GlobalData.GUID, 2);
                                    }

                                    //Updating Last Bytes in the dataset
                                    if (arrLastBytes[i] != null)
                                    {
                                        newRow[28] = Decrypt(arrLastBytes[i], GlobalData.GUID, 2);
                                    }

                                    //Updating First Score in the dataset
                                    if (arrFirstScore[i] != null)
                                    {
                                        newRow[33] = Decrypt(arrFirstScore[i], GlobalData.GUID, 2);
                                    }


                                    GlobalData.dsAllHData.Tables["tblGameLevelScore"].BeginLoadData();

                                    // Add the new row to the rows collection.
                                    GlobalData.dsAllHData.Tables["tblGameLevelScore"].LoadDataRow(newRow, true);

                                    GlobalData.dsAllHData.Tables["tblGameLevelScore"].EndLoadData();
                                }
                            }
                            catch
                            {
                                //do nothing
                            }
                            break;
                        }//end of try block
                        catch(Exception excp)
                        {
                            if (excp.Message.Contains("HS0099"))
                            {
                                DialogResult dgEndContest = new DialogResult();
                                dgEndContest = MessageBox.Show(this, "Sorry, your scores cannot be uploaded because contest has closed.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                if (dgEndContest == DialogResult.OK)
                                    Application.Exit();
                            }
                            else
                            {
                                ScoreSaveDBRetryCount++;
                                if (ScoreSaveDBRetryCount >= 3)
                                {
                                    for (int i = 0; i < levelCount; i++)
                                    {
                                        arrLevels[(int)updatedLevelIndex[i]].isLevelDataChanged = true;
                                    }
                                    break;
                                }
                            }
                        }
                    }//end of while loop
                }//end of try block
                catch//(Exception exp)
                {

                }//end of catch block
            }//end of try
            catch
            {
#if(ERRORLOG)
				try
				{
					GlobalData.initlizeWS(); //try initializing and log error
					Object oper = EnableMyMenu(GlobalData.GUID);
					Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
					Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
					GlobalData.HS.DisplayInfo(IdContestant,oper,error );
					

				}
				catch{}
#endif

            }
            finally
            {
                //set null all arrays.
                arrLevelScoreId = null;
                arrlvlProgCurrently = null;
                arrlvlProgBest = null;
                arrlvlscore = null;
                arrbyteused = null;
                arrlvlstatus = null;
                arrdotspressed = null;
                arrTotGoAttempted = null;
                arrFirstSolution = null;
                arrFirstBytes = null;
                arrTotTimeSpend = null;
                arrBestSolutionDate =
                    arrLastProgram = null;
                arrLastBytes = null;
                arrFirstScore = null;

#if(DLL)
		
				if(GlobalData.DS != null) 
					GlobalData.DS.Dispose();
				GlobalData.DS = null;
	
#else
                if (HSLevelSave != null)
                    HSLevelSave.Dispose();
                HSLevelSave = null;
#endif
            }


        }

        /// <summary>
        /// saves the level scores in database this function is called only if herbert is closing.
        /// if version is not turorial
        /// </summary>
        private void SaveDataInDB()
        {
            if (GlobalData.HerbertMode != HMode.Tutorial)
            {
                /*
                 * Add By : Rajesh
                 * To convert the local date into the en-us format.
                 * 19-Dec-06
                 */
                DateTimeFormatInfo dfi = new DateTimeFormatInfo();
                CultureInfo ci = new CultureInfo("en-us");
                dfi.MonthDayPattern = "mm/dd/yy";
                ci.DateTimeFormat = dfi;
                /*end*/
                HaltHrbt_Click(null, null);
                //int count = arrLevels.Length-1;

                int levelCount = 0;

                arrLevels[currentLevelIndex].isLevelStatisticsChanged = true;

                for (int i = 1; i < arrLevels.Length; i++)
                {
                    if ((arrLevels[i].isLevelStatisticsChanged && !blnIsSilentSaveSuccessful) || (arrLevels[currentLevelIndex].isLevelDataChanged))
                    {
                        levelCount++;
                    }
                }


                /* Data */

                object[] arrLevelScoreId = new object[levelCount];
                object[] arrlvlpCurrently = new object[levelCount];
                object[] arrlvlp = new object[levelCount];
                object[] arrlvlscore = new object[levelCount];
                object[] arrbyteused = new object[levelCount];
                object[] arrlvlstatus = new object[levelCount];
                object[] arrdotspressed = new object[levelCount];
                object[] arrTotGoAttempted = new object[levelCount];
                object[] arrFristSolution = new object[levelCount];
                object[] arrFristSolutionBytes = new object[levelCount];
                object[] arrTotTimeSpend = new object[levelCount];
                object[] arrBestDate = new object[levelCount];
                object[] arrLastProgram = new object[levelCount];
                object[] arrLastBytes = new object[levelCount];
                object[] arrFirstScore = new object[levelCount];

                /* Statistics */
                object[] arrlvltimespend = new object[levelCount];
                object[] arrLevelId = new object[levelCount];
                object[] arrNumGoAttempted = new object[levelCount];
                object[] arrNumTimesLevelVisited = new object[levelCount];
                object[] arrFirstSolutionDT = new object[levelCount];
                object[] arrNumCharTyped = new object[levelCount];
                object[] arrFirstCharTypedDT = new object[levelCount];
                object[] arrFirstGos = new object[levelCount];
                object[] arrFirstTimeSpent = new object[levelCount];
                object[] arrFirstCharsTyped = new object[levelCount];
                object[] arrBestCharsTyped = new object[levelCount];
                object[] arrBestVisits = new object[levelCount];
                object[] arrLastDate = new object[levelCount];
                object[] arrLastGos = new object[levelCount];
                object[] arrLastTimeSpent = new object[levelCount];
                object[] arrLastCharsTyped = new object[levelCount];
                object[] arrLastVisits = new object[levelCount];
                object[] arrFirstVisits = new object[levelCount];
                object[] arrTotalCharsTyped = new object[levelCount];

                object[] updatedLevelIndex = new object[levelCount];

                try
                {
                    deSelectError();
                    arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                    //Check is added By Rajesh 05-may-07.
                    if (!isInstanceInvalidWarningDisplayed)
                        DisableAllItems(true);
                    else
                    {
                        DisableAllItems(false);
                    }
                    lblClosing.Refresh();
                    this.Refresh();
                    if (GameInterval <= 0)
                        Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay));

#if(THREADSLEEP)					
				Thread.Sleep(300);
#endif

                    //calculate the total time game is palyed in minutes.
                    TotalGameTimeInMinSpent += ((TotalTimeInSecRemaining - GameInterval) / 60);



                    int index = 0;
                    //get all level data in arrays.
                    for (int i = 1; i < arrLevels.Length; i++)
                    {
                        if ((arrLevels[i].isLevelStatisticsChanged && !blnIsSilentSaveSuccessful) || (arrLevels[currentLevelIndex].isLevelDataChanged))
                        {
                            try
                            {
                                if (isMismatchProbeOn)
                                {
                                    //3 indicates that the check is done during save on exit
                                    ScoreMismatchCheck(i, 3);
                                }
                            }
                            catch
                            {
                            }

                            arrLevelScoreId[index] = DisableMyMenu(arrLevels[i].LevelScoreId, GlobalData.GUID, 2);
                            arrlvlpCurrently[index] = DisableMyMenu(arrLevels[i].iCurrentProgram, GlobalData.GUID, 2);
                            arrlvlp[index] = DisableMyMenu(arrLevels[i].iBestProgram, GlobalData.GUID, 2);
                            arrlvlscore[index] = DisableMyMenu(arrLevels[i].levelScore, GlobalData.GUID, 2);
                            arrbyteused[index] = DisableMyMenu(arrLevels[i].iBestBytes, GlobalData.GUID, 2);
                            arrlvlstatus[index] = DisableMyMenu((arrLevels[i].IsLevelFinishedPersistant ? 1 : 0), GlobalData.GUID, 2);
                            arrlvltimespend[index] = DisableMyMenu(arrLevels[i].iBestTimeSpent, GlobalData.GUID, 2);
                            arrLevelId[index] = DisableMyMenu(Level.arrLevelId[i], GlobalData.GUID, 2);
                            arrdotspressed[index] = DisableMyMenu(arrLevels[i].numDotsPressed, GlobalData.GUID, 2);
                            arrNumGoAttempted[index] = DisableMyMenu(arrLevels[i].iBestGos, GlobalData.GUID, 2);
                            arrNumTimesLevelVisited[index] = DisableMyMenu(arrLevels[i].pNumVisits, GlobalData.GUID, 2);
                            //arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);//Cahnged By Rajesh
                            arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(ci), GlobalData.GUID, 2);
                            arrNumCharTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);Changed by rajesh
                            arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(ci), GlobalData.GUID, 2);
                            arrFristSolution[index] = DisableMyMenu(arrLevels[i].iFirstProgram, GlobalData.GUID, 2);
                            arrFristSolutionBytes[index] = DisableMyMenu(arrLevels[i].iFirstBytes, GlobalData.GUID, 2);
                            arrTotGoAttempted[index] = DisableMyMenu(arrLevels[i].iTotalGos, GlobalData.GUID, 2);
                            arrTotTimeSpend[index] = DisableMyMenu(arrLevels[i].iTotalTimeSpent, GlobalData.GUID, 2);

                            arrFirstGos[index] = DisableMyMenu(arrLevels[i].iFirstGos, GlobalData.GUID, 2);
                            arrFirstTimeSpent[index] = DisableMyMenu(arrLevels[i].iFirstTimeSpent, GlobalData.GUID, 2);
                            arrFirstCharsTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped, GlobalData.GUID, 2);
                            //arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);//changed By rajesh
                            arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(ci), GlobalData.GUID, 2);
                            arrBestCharsTyped[index] = DisableMyMenu(arrLevels[i].iBestCharsTyped, GlobalData.GUID, 2);
                            arrBestVisits[index] = DisableMyMenu(arrLevels[i].iBestVisits, GlobalData.GUID, 2);
                            //arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                            arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(ci), GlobalData.GUID, 2);
                            arrLastProgram[index] = DisableMyMenu(arrLevels[i].iLastProgram, GlobalData.GUID, 2);
                            arrLastBytes[index] = DisableMyMenu(arrLevels[i].iLastBytes, GlobalData.GUID, 2);
                            arrLastGos[index] = DisableMyMenu(arrLevels[i].iLastGos, GlobalData.GUID, 2);
                            arrLastTimeSpent[index] = DisableMyMenu(arrLevels[i].iLastTimeSpent, GlobalData.GUID, 2);
                            arrLastCharsTyped[index] = DisableMyMenu(arrLevels[i].iLastCharsTyped, GlobalData.GUID, 2);
                            arrLastVisits[index] = DisableMyMenu(arrLevels[i].iLastVisits, GlobalData.GUID, 2);
                            arrFirstScore[index] = DisableMyMenu(arrLevels[i].iFirstLevelScore, GlobalData.GUID, 2);
                            arrFirstVisits[index] = DisableMyMenu(arrLevels[i].iFirstVisits, GlobalData.GUID, 2);
                            arrTotalCharsTyped[index] = DisableMyMenu(arrLevels[i].iTotalCharsTyped, GlobalData.GUID, 2);
                            updatedLevelIndex[index] = i;
                            index++;
                        }
                    }//end of for loop

                    Object TraceOnOff = (mnuTrace.Checked) ? 1 : 0;
                    Object ToolBarOnOff = (mnuToolBar.Checked) ? 1 : 0;
                    Object PathOnOff = (mnuPath.Checked) ? 1 : 0;
                    Object SmoothScrollOnOff = (mnuSmoothScroll.Checked) ? 1 : 0;
                    TraceOnOff = DisableMyMenu(TraceOnOff, GlobalData.GUID, 2);
                    ToolBarOnOff = DisableMyMenu(ToolBarOnOff, GlobalData.GUID, 2);
                    PathOnOff = DisableMyMenu(PathOnOff, GlobalData.GUID, 2);
                    SmoothScrollOnOff = DisableMyMenu(SmoothScrollOnOff, GlobalData.GUID, 2);
                    Object oper = EnableMyMenu(GlobalData.GUID);
                    Object values = DisableMyMenu(plain, GlobalData.GUID, 2);
#if(CONTEST)
                    Object VersionNo = DisableMyMenu(Application.ProductVersion, GlobalData.GUID, 2);
#endif
#if(DESIGNER)
				Object VersionNo = DisableMyMenu("1.0.2.193",GlobalData.GUID,2);
#endif

                    //Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
                    Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(ci), GlobalData.GUID, 2);

                    Object IdScore = DisableMyMenu(ScoreId, GlobalData.GUID, 2);
                    Object IdContestant = DisableMyMenu(GlobalData.ContestantId, GlobalData.GUID, 2);
                    Object scoreTotal = DisableMyMenu(Level.totalScore, GlobalData.GUID, 2);
                    Object timeTotal = DisableMyMenu(TotalGameTimeInMinSpent, GlobalData.GUID, 2);
                    //Object dateStart = DisableMyMenu(startdate.ToString("mm/dd/yy",new CultureInfo("en-US")),GlobalData.GUID,2);
                    Object dateStart = DisableMyMenu(startdate.ToString(ci), GlobalData.GUID, 2);
                    Object indexCurrent = DisableMyMenu(currentLevelIndex, GlobalData.GUID, 2);
                    //uploadStatus = 1 in case of Saving solutions while exiting the app
                    int uploadStatus = 1;
                    Object reason = DisableMyMenu(uploadStatus, GlobalData.GUID, 2);

                    try
                    {
                        //GlobalData.initlizeWS();

                        ScoreSaveDBRetryCount = 0;
                        while (true)
                        {
#if(DLL)
					
						GlobalData.initlizeWS();
					
#else
                            HSSaveOnExit = new Designer.HService.HDataService();
                            HSSaveOnExit.Url = GlobalData.URL;
                            HSSaveOnExit.Timeout = GlobalData.sessionTimeOut;
                            HSSaveOnExit.PreAuthenticate = true;
                            HSSaveOnExit.Proxy = GlobalData.GetProxy();
#endif

                            try
                            {
#if(RTDEBUG)
					int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
						Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
						arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
						arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
						currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
						arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2,strDebugLog);
#else

#if(DLL)
	
							int z = (int)GlobalData.DS.VerifyData(oper, IdScore, IdContestant,
								scoreTotal, timeTotal, dateStart, endTime,arrLevelScoreId,
								arrlvlpCurrently,arrlvlp,arrlvlscore,arrbyteused,arrlvlstatus,
								arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
								indexCurrent, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
								arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,reason,arrTotGoAttempted,arrTotTimeSpend,
								arrFirstGos,arrFirstTimeSpent,arrBestDate,arrBestCharsTyped,arrBestVisits,
								arrLastDate,arrLastProgram,arrLastBytes,arrLastGos,arrLastTimeSpent,arrLastCharsTyped,
								arrLastVisits,arrFirstScore,arrFirstVisits,arrTotalCharsTyped,ScoreSaveDBRetryCount,SmoothScrollOnOff);
	
#else

                                int z = (int)HSSaveOnExit.VerifyData(oper, IdScore, IdContestant,
                                    scoreTotal, timeTotal, dateStart, endTime, arrLevelScoreId,
                                    arrlvlpCurrently, arrlvlp, arrlvlscore, arrbyteused, arrlvlstatus,
                                    arrlvltimespend, arrLevelId, arrdotspressed, arrNumGoAttempted, arrNumTimesLevelVisited,
                                    indexCurrent, TraceOnOff, values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
                                    arrFirstCharTypedDT, arrFristSolution, arrFristSolutionBytes, reason, arrTotGoAttempted, arrTotTimeSpend,
                                    arrFirstGos, arrFirstTimeSpent, arrBestDate, arrBestCharsTyped, arrBestVisits,
                                    arrLastDate, arrLastProgram, arrLastBytes, arrLastGos, arrLastTimeSpent, arrLastCharsTyped,
                                    arrLastVisits, arrFirstScore, arrFirstVisits, arrTotalCharsTyped, ScoreSaveDBRetryCount, SmoothScrollOnOff, ToolBarOnOff);

                                if (z == -1)
                                {
                                    DialogResult dgEndContest = new DialogResult();
                                    dgEndContest = MessageBox.Show(this, "Sorry, your scores cannot be uploaded because contest has closed.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                    if (dgEndContest == DialogResult.OK)
                                        Application.Exit();
                                }
#endif
                                for (int i = 0; i < levelCount; i++)
                                {
                                    arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = false;
                                }
#endif
                                break;
                            }//end of try block
                            catch (Exception exp)
                            {

                                ScoreSaveDBRetryCount++;
                                if (GameInterval <= 0)
                                    Thread.Sleep(GetRandomDelay(GlobalData.iIniSeedRandomDelay / 10, GlobalData.iIniSeedRandomDelay));
                                // ------------ added by NikhilK to fix issue 9552 ---------------
                                if (exp.Message.IndexOf("HTTP status 407") >= 0 || exp.Message.IndexOf("Unauthorized") >= 0 || exp.Message.IndexOf("HTTP status 403") >= 0)
                                {
                                    /*Start: Added By Rajesh to show credential window*/
                                    try
                                    {
                                        DialogResult drNetwork = DialogResult.No;
                                        Login lNetwork = new Login();

                                        lNetwork.CheckForProxyForOfflineVersion();
                                        lNetwork.ShowNetworkLoginWindow();
                                        drNetwork = lNetwork.ShowDialog();
                                    }
                                    catch (Exception innerExp)
                                    {
                                        if (exp.Message.IndexOf("Request for the permission") >= 0)
                                        {
                                            MessageBox.Show(this, "H0093: Herbert exe does not have enough permissions. \nTo grant this permission please see the help section.", "Login error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                            return;
                                        }
                                        else
                                        {

                                        }
                                    }
                                }
                                // ---------------------------------------------------------------

                                if (ScoreSaveDBRetryCount >= 3)
                                {
                                    if (exp.Message.IndexOf("timed-out") > 0 || exp.Message.IndexOf("timed out") > 0)
                                    {
                                        if (GlobalData.isHerbertFromSite == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0005: There was an error in uploading your solutions. Connection to the server timed-out.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                ScoreSaveDBRetryCount = 0;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else if (GlobalData.isEmploymentContest == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0005: There was an error in uploading your solutions. Connection to the server timed-out.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                ScoreSaveDBRetryCount = 0;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            YesNoCancelOffline = MessageBox.Show(this, "H0005: There was an error in uploading your solutions. Connection to the server timed-out.\nThis session will now be saved locally, and will be automatically loaded when you login to Herbert the next time.\nPress Yes to save and exit, No to exit without saving, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                            if (YesNoCancelOffline == DialogResult.Cancel)
                                            {
                                                ScoreSaveDBRetryCount = 0;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancelOffline == DialogResult.Yes)
                                            {
                                                if (GlobalData.HerbertMode == HMode.Contest)
                                                {
                                                    try
                                                    {
                                                        if (!GlobalData.isHerbertFromSite)
                                                        {
                                                            CreateSession();
#if(SESSIONMAGEMENT)

                                                            if (GlobalData.IsShowContestList)
                                                            {
                                                                MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                                GlobalData.IsShowContestList = false;
                                                            }
#endif
                                                        }
                                                        break;
                                                    }
                                                    catch
                                                    {
                                                        YesNoCancelOffline = MessageBox.Show(this, "H0096: Unable to save session locally. Do you want to exit?", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                                        if (YesNoCancelOffline == DialogResult.Yes)
                                                        {
                                                            break;
                                                        }
                                                        //Problem in creating the session file.
                                                    }
                                                }

                                            }
                                            else
                                            {
#if(SESSIONMAGEMENT)

                                                if (GlobalData.IsShowContestList)
                                                {
                                                    MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                    GlobalData.IsShowContestList = false;
                                                }
#endif
                                                break;
                                            }
                                        }
                                    }
                                    else if (exp.Message.IndexOf("underlying connection was closed") > 0)
                                    {
                                        if (GlobalData.isHerbertFromSite == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0006: There was an error in uploading your solutions. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);
                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                ScoreSaveDBRetryCount = 0;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else if (GlobalData.isEmploymentContest == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0006: There was an error in uploading your solutions. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);
                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                ScoreSaveDBRetryCount = 0;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            //For offline herbert
                                            YesNoCancelOffline = MessageBox.Show(this, "H0027: There was an error connecting to the server.\nThis session will now be saved locally, and will be automatically loaded when you login to Herbert the next time.\nPress Yes to save and exit, No to exit without saving, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                            if (YesNoCancelOffline == DialogResult.Cancel)
                                            {
                                                YesNoCancel = YesNoCancelOffline;
                                                GlobalData.IsShowContestList = false;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancelOffline == DialogResult.Yes)
                                            {
                                                if (GlobalData.HerbertMode == HMode.Contest)
                                                {
                                                    try
                                                    {
                                                        if (!GlobalData.isHerbertFromSite)
                                                        {
                                                            CreateSession();
#if(SESSIONMAGEMENT)

                                                            if (GlobalData.IsShowContestList)
                                                            {
                                                                MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                                GlobalData.IsShowContestList = false;
                                                            }
#endif
                                                        }
                                                        break;
                                                    }
                                                    catch
                                                    {
                                                        YesNoCancelOffline = MessageBox.Show(this, "H0028: Unable to save session locally. Do you want to exit?", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                                        if (YesNoCancelOffline == DialogResult.Yes)
                                                        {
                                                            break;
                                                        }
                                                        //Problem in creating the session file.
                                                    }
                                                }
                                            }
                                            else
                                            {
#if(SESSIONMAGEMENT)

                                                if (GlobalData.IsShowContestList)
                                                {
                                                    MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                    GlobalData.IsShowContestList = false;
                                                }
#endif
                                                break;
                                            }
                                        }
                                    }
                                    else if (exp.Message.IndexOf("HS0011") >= 0)
                                    {
                                        if (!isInstanceInvalidWarningDisplayed)
                                        {
                                            MessageBox.Show(this, "H0018: Your solutions could not be uploaded. \nSince you launched this instance of Herbert, another instance has started. \nPlease close the current instance and switch to the new instance, or launch Herbert again if there is no other instance.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                            isInstanceInvalidWarningDisplayed = true;
                                            YesNoCancel = DialogResult.Cancel;
                                            ScoreSaveDBRetryCount = 0;
                                            EnableAllItems();
                                            return;
                                        }
                                        //YesNo = DialogResult.Yes;

                                        EnableAllItems();
                                        if (isExceptionLogged)
                                        {
                                            try
                                            {
                                                sbErrorLog.Append("\n H0018: Exception Message: " + exp.Message);
                                                sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                                                sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());

                                                LogErrors();
                                            }
                                            catch
                                            {
                                            }
                                        }
                                        return;


                                    }
                                    else if (exp.Message.IndexOf("HS0004") >= 0)
                                    {
                                        //There is error while saving the data to the DB. rare case
                                        if (GlobalData.isHerbertFromSite != true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0007: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.\n", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else if (GlobalData.isEmploymentContest == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0007: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.\n", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            YesNoCancelOffline = MessageBox.Show(this, "H0029: There was an error uploading solutions to the server.\nThis session will now be saved locally, and will be automatically loaded when you login to Herbert the next time.\nPress Yes to save and exit, No to exit without saving, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                            if (YesNoCancelOffline == DialogResult.Cancel)
                                            {
                                                YesNoCancel = YesNoCancelOffline;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancelOffline == DialogResult.Yes)
                                            {
                                                if (GlobalData.HerbertMode == HMode.Contest)
                                                {
                                                    try
                                                    {
                                                        if (!GlobalData.isHerbertFromSite)
                                                        {
                                                            CreateSession();
#if(SESSIONMAGEMENT)
                                                            if (GlobalData.IsShowContestList)
                                                            {
                                                                MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                                GlobalData.IsShowContestList = false;
                                                            }
#endif
                                                        }
                                                        break;
                                                    }
                                                    catch
                                                    {
                                                        YesNoCancelOffline = MessageBox.Show(this, "H0028: Unable to save session locally. Do you want to exit?", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                                        if (YesNoCancelOffline == DialogResult.Yes)
                                                        {
#if(SESSIONMAGEMENT)

                                                            if (GlobalData.IsShowContestList)
                                                            {
                                                                MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                                GlobalData.IsShowContestList = false;
                                                            }
#endif
                                                            break;
                                                        }
                                                        //Problem in creating the session file.
                                                    }

                                                }
                                            }
                                            else
                                            {
#if(SESSIONMAGEMENT)

                                                if (GlobalData.IsShowContestList)
                                                {
                                                    MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                    GlobalData.IsShowContestList = false;
                                                }
#endif
                                                break;
                                            }
                                        }

                                    }
                                    else
                                    {
                                        if (GlobalData.isHerbertFromSite == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0007: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.\n", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else if (GlobalData.isEmploymentContest == true)
                                        {
                                            YesNoCancel = MessageBox.Show(this, "H0007: There was an error in uploading your solutions. There was an error connecting to the server.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.\n", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error);

                                            if (YesNoCancel == DialogResult.Cancel)
                                            {
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancel == DialogResult.No)
                                            {
                                                YesNo = MessageBox.Show(this, "If you exit Herbert without uploading, your solutions may be lost. Continue?", "Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                                                if (YesNo == DialogResult.Yes)
                                                {
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            YesNoCancelOffline = MessageBox.Show(this, "H0027: There was an error connecting to the server.\nThis session will now be saved locally, and will be automatically loaded when you login to Herbert the next time.\nPress Yes to save and exit, No to exit without saving, or Cancel to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                            if (YesNoCancelOffline == DialogResult.Cancel)
                                            {
                                                YesNoCancel = YesNoCancelOffline;
                                                GlobalData.IsShowContestList = false;
                                                EnableAllItems();
                                                return;
                                            }
                                            else if (YesNoCancelOffline == DialogResult.Yes)
                                            {
                                                if (GlobalData.HerbertMode == HMode.Contest)
                                                {
                                                    try
                                                    {
                                                        if (!GlobalData.isHerbertFromSite)
                                                        {
                                                            CreateSession();
#if(SESSIONMAGEMENT)

                                                            if (GlobalData.IsShowContestList)
                                                            {
                                                                MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                                GlobalData.IsShowContestList = false;
                                                            }
#endif
                                                        }
                                                        break;
                                                    }
                                                    catch
                                                    {
                                                        YesNoCancelOffline = MessageBox.Show(this, "H0028: Unable to save session locally. Do you want to exit?", "Herbert - Error", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                                                        if (YesNoCancelOffline == DialogResult.Yes)
                                                        {
                                                            break;
                                                        }
                                                        //Problem in creating the session file.
                                                    }
                                                }

                                            }
                                            else
                                            {
#if(SESSIONMAGEMENT)

                                                if (GlobalData.IsShowContestList)
                                                {
                                                    MessageBox.Show(this, "H0025: Could not connect to the server. Cannot switch to another contest. Application will close now.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                                    GlobalData.IsShowContestList = false;
                                                }
#endif
                                                break;
                                            }
                                        }
                                    }// end of else							
                                }// end of if(ScoreSaveDBRetryCount >= 3)
                            }//end of catch
                        }//end of while loop
                    }//end of try block
                    catch//(Exception exp)
                    {

                    }//end of catch block
                }//end of try
                catch (Exception exp)
                {
                    if (isExceptionLogged)
                    {
                        try
                        {
                            sbErrorLog.Append("\n H0012: Exception Message: " + exp.Message);
                            sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                            sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                            //sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                            LogErrors();
                        }
                        catch
                        {
                        }
                    }
#if(ERRORLOG)
				try
				{
					GlobalData.initlizeWS(); //try initializing and log error
					Object oper = EnableMyMenu(GlobalData.GUID);
					Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
					Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
					GlobalData.HS.DisplayInfo(IdContestant,oper,error );
				}
				catch{}
#endif
                }
                finally
                {
                    //set null all arrays.
                    arrlvlp = null;
                    arrlvlscore = null;
                    arrbyteused = null;
                    arrlvlstatus = null;
                    arrlvltimespend = null;
                    arrLevelId = null;
                    arrdotspressed = null;
                    arrNumGoAttempted = null;
#if(DLL)					
				if(GlobalData.DS != null) 
					GlobalData.DS.Dispose();
				GlobalData.DS = null;
				
#else
                    if (HSSaveOnExit != null)
                        HSSaveOnExit.Dispose();
                    HSSaveOnExit = null;
#endif
                }
            }
        }

        /// <summary>
        /// upload solution menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuUploadSolutions_Click(object sender, System.EventArgs e)
        {
            blnUploadingSolutions = true;

            HaltHrbt_Click(null, null);

            ControlStatus = new bool[27];
            MenuStatus = new bool[5];

            SaveControlStates();

            SaveMenuStatus();

#if(CONTEST)
#if(SESSIONMAGEMENT)
            //Check added By Rajesh to check if the contest is closed.
            if (GlobalData.IsLoadFromFile)
            {
                blnTimeIntervalChanged = false;
                tPolling = new Thread(new ThreadStart(PoolForMaintData));
                tPolling.Name = "Maintainance Polling (" + DateTime.Now.ToShortTimeString() + ")";
                tPolling.Priority = ThreadPriority.Highest;
                tPolling.Start();
                tPolling.Join();
                if (GameInterval <= 0)
                {
                    MessageBox.Show(this, "Sorry! You are out of time for this contest. The application will now close.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    GlobalData.GUID = null;//Not to allow to save the data in the db for savedataindb()
                    blnUploadingSolutions = false;
                    this.Close();
                    GlobalData.IsShowContestList = false;
                    GlobalData.isContestFinished = true;
                    return;
                }
                else
                {
                    GlobalData.isContestFinished = false;
                    if (blnTimeIntervalChanged)
                    {
                        UploadSolutionsInDB();
                        blnTimeIntervalChanged = true;
                    }
                    else
                    {//While not able to update the the gameintervale.
                        MessageBox.Show(this, "H0012: There was an error uploading your solutions. Could not connect to the server.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
#endif
            else
                UploadSolutionsInDB();
#endif

            EnableAllItems();

            RetrieveControlStates();

            RetrieveMenuStatus();

            blnUploadingSolutions = false;

            ControlStatus = null;
            MenuStatus = null;
        }


        #region commented
        //		private void SaveDataInDB(bool bNotify)
        //		{
        //			if(GlobalData.HerbertMode != HMode.Tutorial)
        //			{
        //				//HaltHrbt_Click(null,null);
        //				//int count = arrLevels.Length-1;
        //
        //				int levelCount = 0;
        //
        //				arrLevels[currentLevelIndex].isLevelStatisticsChanged = true; 
        //
        //				for(int i=1; i < arrLevels.Length; i++)
        //				{
        //					if (arrLevels[i].isLevelStatisticsChanged)
        //					{
        //						levelCount++;
        //					}
        //				}
        //
        //
        //				/* Data */
        //				object[] arrLevelScoreId = new object[levelCount];
        //				object[] arrlvlpCurrently = new object[levelCount];
        //				object[] arrlvlp = new object[levelCount];
        //				object[] arrlvlscore = new object[levelCount];
        //				object[] arrbyteused = new object[levelCount];
        //				object[] arrlvlstatus = new object[levelCount];
        //				object[] arrdotspressed = new object[levelCount];
        //				object[] arrTotGoAttempted = new object[levelCount];
        //				object[] arrFristSolution = new object[levelCount];
        //				object[] arrFristSolutionBytes = new object[levelCount];
        //				object[] arrTotTimeSpend = new object[levelCount];
        //				object[] arrBestDate = new object[levelCount];
        //				object[] arrLastProgram = new object[levelCount];
        //				object[] arrLastBytes = new object[levelCount];
        //				object[] arrFirstScore = new object[levelCount];
        //
        //				/* Statistics */
        //				object[] arrlvltimespend = new object[levelCount];
        //				object[] arrLevelId  = new object[levelCount];				
        //				object[] arrNumGoAttempted = new object[levelCount];
        //				object[] arrNumTimesLevelVisited = new object[levelCount];
        //				object[] arrFirstSolutionDT = new object[levelCount];
        //				object[] arrNumCharTyped = new object[levelCount];
        //				object[] arrFirstCharTypedDT = new object[levelCount];
        //				object[] arrFirstGos = new object[levelCount];
        //				object[] arrFirstTimeSpent = new object[levelCount];
        //				object[] arrFirstCharsTyped = new object[levelCount];				
        //				object[] arrBestCharsTyped = new object[levelCount];
        //				object[] arrBestVisits = new object[levelCount];
        //				object[] arrLastDate = new object[levelCount];				
        //				object[] arrLastGos = new object[levelCount];
        //				object[] arrLastTimeSpent = new object[levelCount];
        //				object[] arrLastCharsTyped = new object[levelCount];
        //				object[] arrLastVisits = new object[levelCount];				
        //				object[] arrFirstVisits = new object[levelCount];
        //				object[] arrTotalCharsTyped = new object[levelCount];
        //
        //				object[] updatedLevelIndex = new object[levelCount];
        //				
        //				try
        //				{
        //					//deSelectError();
        //					arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
        //					//DisableAllItems(true);
        //					//lblClosing.Refresh();
        //					//this.Refresh();
        //					
        //#if(THREADSLEEP)					
        //					Thread.Sleep(300);
        //#endif
        //					
        //					//calculate the total time game is palyed in minutes.
        //					TotalGameTimeInMinSpent += ((TotalTimeInSecRemaining - GameInterval) / 60);
        //
        //				
        //
        //					int index = 0;
        //					//get all level data in arrays.
        //					for(int i = 1; i < arrLevels.Length; i++)
        //					{	
        //						if(arrLevels[i].isLevelStatisticsChanged)
        //						{
        //							
        //							try
        //							{
        //								if(isMismatchProbeOn)
        //								{
        //									//3 indicates that the check is done during save on exit
        //									ScoreMismatchCheck(i,3);
        //								}
        //							}
        //							catch
        //							{
        //							}
        //							arrLevelScoreId[index] = DisableMyMenu(arrLevels[i].LevelScoreId,GlobalData.GUID,2);
        //							arrlvlpCurrently[index] = DisableMyMenu(arrLevels[i].iCurrentProgram,GlobalData.GUID,2);
        //							arrlvlp[index] = DisableMyMenu(arrLevels[i].iBestProgram,GlobalData.GUID,2);
        //							arrlvlscore[index] = DisableMyMenu(arrLevels[i].levelScore,GlobalData.GUID,2);
        //							arrbyteused[index] = DisableMyMenu(arrLevels[i].iBestBytes,GlobalData.GUID,2);
        //							arrlvlstatus[index] = DisableMyMenu((arrLevels[i].IsLevelFinishedPersistant ? 1:0),GlobalData.GUID,2);
        //							arrlvltimespend[index] = DisableMyMenu(arrLevels[i].iBestTimeSpent,GlobalData.GUID,2);
        //							arrLevelId[index] = DisableMyMenu(Level.arrLevelId[i],GlobalData.GUID,2);
        //							arrdotspressed[index] = DisableMyMenu(arrLevels[i].numDotsPressed,GlobalData.GUID,2);
        //							arrNumGoAttempted[index] = DisableMyMenu(arrLevels[i].iBestGos,GlobalData.GUID,2);
        //							arrNumTimesLevelVisited[index] = DisableMyMenu(arrLevels[i].pNumVisits,GlobalData.GUID,2);
        //							arrFirstSolutionDT[index] = DisableMyMenu(arrLevels[i].iFirstDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //							arrNumCharTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped,GlobalData.GUID,2);
        //							arrFirstCharTypedDT[index] = DisableMyMenu(arrLevels[i].FirstCharTypedDT.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //							arrFristSolution[index] = DisableMyMenu(arrLevels[i].iFirstProgram,GlobalData.GUID,2);
        //							arrFristSolutionBytes[index] = DisableMyMenu(arrLevels[i].iFirstBytes,GlobalData.GUID,2);
        //							arrTotGoAttempted[index] = DisableMyMenu(arrLevels[i].iTotalGos,GlobalData.GUID,2);
        //							arrTotTimeSpend[index] = DisableMyMenu(arrLevels[i].iTotalTimeSpent,GlobalData.GUID,2);
        //
        //							arrFirstGos[index] = DisableMyMenu(arrLevels[i].iFirstGos,GlobalData.GUID,2);
        //							arrFirstTimeSpent[index] = DisableMyMenu(arrLevels[i].iFirstTimeSpent,GlobalData.GUID,2);
        //							arrFirstCharsTyped[index] = DisableMyMenu(arrLevels[i].iFirstCharsTyped,GlobalData.GUID,2);
        //							arrBestDate[index] = DisableMyMenu(arrLevels[i].iBestDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //							arrBestCharsTyped[index] = DisableMyMenu(arrLevels[i].iBestCharsTyped,GlobalData.GUID,2);
        //							arrBestVisits[index] = DisableMyMenu(arrLevels[i].iBestVisits,GlobalData.GUID,2);
        //							arrLastDate[index] = DisableMyMenu(arrLevels[i].iLastDate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //							arrLastProgram[index] = DisableMyMenu(arrLevels[i].iLastProgram,GlobalData.GUID,2);
        //							arrLastBytes[index] = DisableMyMenu(arrLevels[i].iLastBytes,GlobalData.GUID,2);
        //							arrLastGos[index] = DisableMyMenu(arrLevels[i].iLastGos,GlobalData.GUID,2);
        //							arrLastTimeSpent[index] = DisableMyMenu(arrLevels[i].iLastTimeSpent,GlobalData.GUID,2);
        //							arrLastCharsTyped[index] = DisableMyMenu(arrLevels[i].iLastCharsTyped,GlobalData.GUID,2);
        //							arrLastVisits[index] = DisableMyMenu(arrLevels[i].iLastVisits,GlobalData.GUID,2);
        //							arrFirstScore[index] = DisableMyMenu(arrLevels[i].iFirstLevelScore,GlobalData.GUID,2);
        //							arrFirstVisits[index] = DisableMyMenu(arrLevels[i].iFirstVisits,GlobalData.GUID,2);
        //							arrTotalCharsTyped[index] = DisableMyMenu(arrLevels[i].iTotalCharsTyped,GlobalData.GUID,2);
        //							updatedLevelIndex[index] = i;
        //							index++;
        //						}
        //					}//end of for loop
        //
        //					Object TraceOnOff = (mnuTrace.Checked)?1:0;
        //					Object PathOnOff = (mnuPath.Checked)?1:0;
        //					Object SmoothScrollOnOff = (mnuSmoothScroll.Checked)?1:0;
        //					TraceOnOff = DisableMyMenu(TraceOnOff,GlobalData.GUID,2);
        //					PathOnOff = DisableMyMenu(PathOnOff,GlobalData.GUID,2);
        //					SmoothScrollOnOff = DisableMyMenu(SmoothScrollOnOff,GlobalData.GUID,2);
        //					Object oper = EnableMyMenu(GlobalData.GUID);
        //					Object values = DisableMyMenu(plain,GlobalData.GUID,2);
        //#if(CONTEST)
        //					Object VersionNo = DisableMyMenu("1.0.3.43",GlobalData.GUID,2);
        //#endif
        //#if(DESIGNER)
        //					Object VersionNo = DisableMyMenu("1.0.2.193",GlobalData.GUID,2);
        //#endif
        //
        //					Object endTime = DisableMyMenu(InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval).ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //
        //					Object IdScore = DisableMyMenu(ScoreId,GlobalData.GUID,2);
        //					Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
        //					Object scoreTotal = DisableMyMenu(Level.totalScore,GlobalData.GUID,2);
        //					Object timeTotal = DisableMyMenu(TotalGameTimeInMinSpent,GlobalData.GUID,2);
        //					Object dateStart = DisableMyMenu(startdate.ToString(new CultureInfo("en-US")),GlobalData.GUID,2);
        //					Object indexCurrent = DisableMyMenu(currentLevelIndex,GlobalData.GUID,2);
        //					//uploadStatus = 1 in case of Saving solutions while exiting the app
        //					int uploadStatus = 1;
        //					Object reason = DisableMyMenu(uploadStatus,GlobalData.GUID,2);
        //					
        //					try
        //					{
        //						//GlobalData.initlizeWS();
        //						
        //
        //						while(true)
        //						{
        //#if(DLL)
        //						
        //							GlobalData.initlizeWS();
        //						
        //#else
        //							HSSaveOnExit = new Designer.HService.HDataService();
        //							HSSaveOnExit.Url = GlobalData.URL;
        //							HSSaveOnExit.Timeout = GlobalData.sessionTimeOut;
        //							HSSaveOnExit.PreAuthenticate=true;
        //							HSSaveOnExit.Proxy = GlobalData.GetProxy();
        //#endif
        //
        //							try
        //							{
        //#if(RTDEBUG)
        //						int z = (int)GlobalData.HS.VerifyData(oper, ScoreId, GlobalData.ContestantId,
        //							Level.totalScore, TotalGameTimeInMinSpent, startdate, endTime,arrLevelScoreId,
        //							arrlvlpCurrently,arrlvlp,arrlvlscore,arrMaxlvlScore,arrbyteused,arrlvlstatus,
        //							arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
        //							currentLevelIndex, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrNumCharTyped,
        //							arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,2,strDebugLog);
        //#else						
        //
        //#if(DLL)
        //		
        //								int z = (int)GlobalData.DS.VerifyData(oper, IdScore, IdContestant,
        //									scoreTotal, timeTotal, dateStart, endTime,arrLevelScoreId,
        //									arrlvlpCurrently,arrlvlp,arrlvlscore,arrbyteused,arrlvlstatus,
        //									arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
        //									indexCurrent, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
        //									arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,reason,arrTotGoAttempted,arrTotTimeSpend,
        //									arrFirstGos,arrFirstTimeSpent,arrBestDate,arrBestCharsTyped,arrBestVisits,
        //									arrLastDate,arrLastProgram,arrLastBytes,arrLastGos,arrLastTimeSpent,arrLastCharsTyped,
        //									arrLastVisits,arrFirstScore,arrFirstVisits,arrTotalCharsTyped,ScoreSaveDBRetryCount,SmoothScrollOnOff);
        //		
        //#else
        //
        //								int z = (int)HSSaveOnExit.VerifyData(oper, IdScore, IdContestant,
        //									scoreTotal, timeTotal, dateStart, endTime,arrLevelScoreId,
        //									arrlvlpCurrently,arrlvlp,arrlvlscore,arrbyteused,arrlvlstatus,
        //									arrlvltimespend,arrLevelId,arrdotspressed,arrNumGoAttempted, arrNumTimesLevelVisited,
        //									indexCurrent, TraceOnOff,values, PathOnOff, VersionNo, arrFirstSolutionDT, arrFirstCharsTyped,
        //									arrFirstCharTypedDT,arrFristSolution, arrFristSolutionBytes,reason,arrTotGoAttempted,arrTotTimeSpend,
        //									arrFirstGos,arrFirstTimeSpent,arrBestDate,arrBestCharsTyped,arrBestVisits,
        //									arrLastDate,arrLastProgram,arrLastBytes,arrLastGos,arrLastTimeSpent,arrLastCharsTyped,
        //									arrLastVisits,arrFirstScore,arrFirstVisits,arrTotalCharsTyped,ScoreSaveDBRetryCount,SmoothScrollOnOff);
        //#endif
        //								for(int i=0;i<levelCount;i++)
        //								{
        //									arrLevels[(int)updatedLevelIndex[i]].isLevelStatisticsChanged = false;
        //								}
        //#endif
        //								break;
        //							}//end of try block
        //							catch(Exception exp)
        //							{
        //						
        //								ScoreSaveDBRetryCount++;
        //								if(ScoreSaveDBRetryCount >= 3)
        //								{
        //									//							if(!TimeOver)
        //									//							{
        //									if(exp.Message.IndexOf("timed-out")>0)
        //									{
        //										YesNoCancel = bNotify?MessageBox.Show(this,"H0005: There was an error in uploading your solutions. Connection to the server timed-out.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error",MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning):DialogResult.No;
        //										if(YesNoCancel == DialogResult.Cancel)
        //										{
        //											ScoreSaveDBRetryCount = 0;
        //											//EnableAllItems();
        //											return;
        //										}
        //										else if(YesNoCancel == DialogResult.No)
        //										{
        //											YesNo = bNotify?MessageBox.Show(this,"If you exit Herbert without uploading, your solutions may be lost. Continue?","Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning):DialogResult.Yes;
        //											if(YesNo == DialogResult.Yes)
        //											{
        //												break;
        //											}
        //										}
        //									}
        //									else if(exp.Message.IndexOf("underlying connection was closed")>0)
        //									{
        //										YesNoCancel = bNotify?MessageBox.Show(this,"H0006: There was an error in uploading your solutions. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.", "Herbert - Error",MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error):DialogResult.No;
        //										if(YesNoCancel == DialogResult.Cancel)
        //										{
        //											ScoreSaveDBRetryCount = 0;
        //											//EnableAllItems();
        //											return;
        //										}
        //										else if(YesNoCancel == DialogResult.No)
        //										{
        //											YesNo = bNotify?MessageBox.Show(this,"If you exit Herbert without uploading, your solutions may be lost. Continue?","Herbert - warning", MessageBoxButtons.YesNo, MessageBoxIcon.Warning):DialogResult.Yes;
        //											if(YesNo == DialogResult.Yes)
        //											{
        //												break;
        //											}
        //										}
        //									}
        //									else
        //									{
        //										YesNoCancel = bNotify?MessageBox.Show(this,"H0007: There was an error in uploading your solutions. There was an error connecting to server.\nDo you want to retry the upload?\nPress Yes to retry, No to exit without uploading, or Cancel to return to Herbert.\n", "Herbert - Error",MessageBoxButtons.YesNoCancel, MessageBoxIcon.Error):DialogResult.No;
        //										
        //										if(YesNoCancel == DialogResult.Cancel)
        //										{
        //											//EnableAllItems();
        //											return;
        //										}
        //										else if(YesNoCancel == DialogResult.No)
        //										{
        //											YesNo = bNotify?MessageBox.Show(this,"If you exit Herbert without uploading, your solutions may be lost. Continue?","Herbert - warning",MessageBoxButtons.YesNo, MessageBoxIcon.Warning):DialogResult.Yes;
        //											if(YesNo == DialogResult.Yes)
        //											{
        //												break;
        //											}// end of if(YesNoCancel == DialogResult.No)
        //										}// end of else if(YesNoCancel == DialogResult.No)
        //									}// end of else							
        //								}// end of if(ScoreSaveDBRetryCount >= 3)
        //							}//end of catch
        //						}//end of while loop
        //					}//end of try block
        //					catch//(Exception exp)
        //					{
        //						
        //					}//end of catch block
        //				}//end of try
        //				catch
        //				{
        //#if(ERRORLOG)
        //					try
        //					{
        //						GlobalData.initlizeWS(); //try initializing and log error
        //						Object oper = EnableMyMenu(GlobalData.GUID);
        //						Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
        //						Object error = DisableMyMenu(exp.Message,GlobalData.GUID,2);
        //						GlobalData.HS.DisplayInfo(IdContestant,oper,error );
        //					}
        //					catch{}
        //#endif
        //				}
        //				finally
        //				{
        //					//set null all arrays.
        //					arrlvlp = null;
        //					arrlvlscore = null;
        //					arrbyteused = null;
        //					arrlvlstatus = null;
        //					arrlvltimespend = null;
        //					arrLevelId = null;
        //					arrdotspressed = null;
        //					arrNumGoAttempted = null;
        //#if(DLL)					
        //					if(GlobalData.DS != null) 
        //						GlobalData.DS.Dispose();
        //					GlobalData.DS = null;
        //					
        //#else
        //					if(HSSaveOnExit != null) 
        //						HSSaveOnExit.Dispose();
        //					HSSaveOnExit = null;
        //#endif
        //				}
        //			}
        //		}
        //
        //
        #endregion
#endif

        #endregion

        #region Options Menu Item's Event

        /// <summary>
        /// sound menu click event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>



        /// <summary>
        /// raised when trace menu is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TraceMenu_Click(object sender, System.EventArgs e)
        {
            mnuTrace.Enabled = false;
            mnuTrace.Checked = !mnuTrace.Checked;
            traceOn = !traceOn;
            if (traceOn)
                btTrace.FlatStyle = FlatStyle.Flat;
            else
                btTrace.FlatStyle = FlatStyle.Standard;
            if (traceOn && (arrLevels[currentLevelIndex].stepByStep || arrLevels[currentLevelIndex].goClicked))
            {
                lock (txtCodeEditor)
                {
                    txtCodeEditor.Visible = false;
                }
                SetupEditorTrace(0);
                EditorTrace(arrLevels[currentLevelIndex].tHState.curLine);
            }
            else
            {
                if (traceOn)
                {
                    SetupEditorTrace(0);
                    EditorTrace(arrLevels[currentLevelIndex].tHState.curLine);
                }
                txtCodeEditor.Visible = true;
            }
            //Added by Vivek Balagangadharan
            // Description : Added to solve the issue 3332 
            // Added On : 22-Aug-2006
            if (traceOn)
            {
                getTextForLTFrame();
            }
            //Added By Rajesh
            //Date: 11/09/06
            //Issue id: 3430
            if (arrLevels[currentLevelIndex].stepByStep || arrLevels[currentLevelIndex].goClicked)
                displayTrace();
            mnuTrace.Enabled = true;
#if(MODULAR_INTERPRETER)
            if (objHinterpreter != null)
            {
                objHinterpreter.SetTraceOn(traceOn);
            }
#endif
        }


        /// <summary>
        /// raised when path menu item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void PathMenu_Click(object sender, System.EventArgs e)
        {
            mnuPath.Checked = !mnuPath.Checked;
            PathOn = !PathOn;
            //Start//
            //Added By Rajesh
            //Date: 16/8/06
            //To fix issue : 3297
            if (!PathOn && herbertState != 0)
            {
                //To detect Path menu disable When herbert state is not 0
                blnPathChange = true;
            }
            else if (PathOn && herbertState != 1)
            {
                //To detect Path menu Enable When herbert state is not 0
                blnPathChange = true;
            }
            //End//
            if (PathOn)
                btPath.FlatStyle = FlatStyle.Flat;
            else
                btPath.FlatStyle = FlatStyle.Standard;
            //set the prePos$ to prePathPos$ so that path can be displayed from the
            //last small dot herbert has reached.
            arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].prePosX;
            arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].prePosY;
        }


        #endregion

        #region Interpreter and supporting functions

        /// <summary>
        /// checks for the syantax of the code written in the code editor.
        /// </summary>
        /// <returns>returns true if syntax is correct else false</returns>
        private bool CheckSyntax()/* called only from h-events once. */
        {
            /* don't forget
                no lines > 127
                max max #lines = 15
            */
            //int i;
            int iVerPC, iWorkPC, iNumParms = 0;
            bool sCorrect, sTemp;
            sCorrect = true;
            arrLevels[currentLevelIndex].iNumLines = 1;							/*save room for exec*/ /*executable line will be stored at 0 index */
            arrLevels[currentLevelIndex].atLineInfo[0].iStart = -1;
            iWorkPC = arrLevels[currentLevelIndex].tHState.PC = 0;                     //tHState( a structure defined in hvars.h)


            /* skip all those lines which are blank, means only enter is pressed. */
            char c = 'a';
            while (iWorkPC < arrLevels[currentLevelIndex].iProgLen && (c = arrLevels[currentLevelIndex].pcProg[iWorkPC]) == CR)
                iWorkPC++;
            iVerPC = iWorkPC;

            //Checking till the end of the program or till an error is reached

            while (sCorrect && iWorkPC < arrLevels[currentLevelIndex].iProgLen)
            { /* While loop A */
                sTemp = false;

                //Checking one line at a time, /*this looks whether this lines defines a function or not. */
                int iNumColns = 0;
                while (iWorkPC < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[iWorkPC] != CR)
                { /* while loop B */
                    if (arrLevels[currentLevelIndex].pcProg[iWorkPC] == ':')
                    {
                        iNumColns++;
                        if (iNumColns > 1)
                        {
                            DispMessage("Only one ':' allowed for one function.");
                            selectError(iWorkPC, 1);
                            sCorrect = false;
                            break;
                        }
                        sTemp = true;
                    }
                    iWorkPC++;
                } /* end of while loop B*/
                if (iNumColns > 1)
                    break;
                /* if sTemp is true this means that this line contains a function defination. */
                if (sTemp)
                { //If the char is a colon. Probably evaluating a function
                    if (sCorrect = CheckDef(ref iNumParms, iVerPC))
                    { /* iVerPC is the current char number where a function def starts */

                        //If the number of lines exceeds particular number then show error - Too many lines. MAXLINES = 16
                        if (arrLevels[currentLevelIndex].iNumLines < MAXLINES)
                        {
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].iStart = iVerPC; /*Starting point for the function in terms of char count in entire code. */
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].cFunc = arrLevels[currentLevelIndex].pcProg[iVerPC]; //The function name -> This is stored at the line info array
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].sNumParms = (short)iNumParms; // number of parameters for the function
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].sFlags = 0;			/*not yet used*/
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].iStartIndexLT = 0;
                            arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].iNumLines].iEndIndexLT = 0;
                            arrLevels[currentLevelIndex].actualVirtualLineNum[getActualLineNum(arrLevels[currentLevelIndex].iNumLines)] = arrLevels[currentLevelIndex].iNumLines;
                            arrLevels[currentLevelIndex].iNumLines++; /* increase this for next function defination. */
                        }
                        else
                        {
                            DispMessage("Too many lines");
                            //vijay
                            killThread();
                            //progClosing = true;
                            DisableMenu();
                            mnuResetHerbt.Enabled = true;
                            arrLevels[currentLevelIndex].blnResetState = true;
                            btStop.Enabled = true;
                            sCorrect = false;
                        }
                    }
                }
                else
                {
                    //Equivalent  to sCorrect = TRUE
                    /* checks whether too many executable lines are there. One and only one executable line is allowed*/
                    if (sCorrect = CheckExec(iVerPC))
                    {
                        if (arrLevels[currentLevelIndex].atLineInfo[0].iStart != -1)
                        { /* if iStart is not = -1 means we already have one exec line. */
                            DispMessage("Too many execution lines");
                            //vijay
                            killThread();
                            //progClosing = true;
                            DisableMenu();
                            mnuResetHerbt.Enabled = true;
                            arrLevels[currentLevelIndex].blnResetState = true;
                            btStop.Enabled = true;
                            sCorrect = false;
                        }
                        else
                        { /*store executable line here. and iStart will become none negative*/
                            arrLevels[currentLevelIndex].atLineInfo[0].iStart = iVerPC;
                            arrLevels[currentLevelIndex].atLineInfo[0].cFunc = ' ';
                            arrLevels[currentLevelIndex].atLineInfo[0].sNumParms = arrLevels[currentLevelIndex].atLineInfo[0].sFlags = 0;
                            arrLevels[currentLevelIndex].actualVirtualLineNum[getActualLineNum(0)] = 0;
                        }
                    }
                }


                /*reach to the end of line.*/
                while (iWorkPC < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[iWorkPC] == CR)
                    iWorkPC++;
                iVerPC = iWorkPC; /* starting point of new line. */
            } /* end of while loop A*/

            /* if no executable line is there, one and only one executable line is allowed. */
            if (sCorrect && arrLevels[currentLevelIndex].atLineInfo[0].iStart == -1)
            {
                DisableMenu();
                DispMessage("No execution line");
                //vijay
                killThread();
                //progClosing = true;
                mnuResetHerbt.Enabled = true;
                arrLevels[currentLevelIndex].blnResetState = true;
                btStop.Enabled = true;
                //HaltHrbt_Click(null,null);
                sCorrect = false;
            }
            if (arrLevels[currentLevelIndex].iNumLines > 15 && sCorrect)
            {
                DisableMenu();
                DispMessage("More than 15 lines of code is not allowed");
                //vijay
                killThread();
                //progClosing = true;
                mnuResetHerbt.Enabled = true;
                arrLevels[currentLevelIndex].blnResetState = true;
                btStop.Enabled = true;
                //HaltHrbt_Click(null,null);
                sCorrect = false;
            }
            if (sCorrect)
                sCorrect = checkInvalidChar();
            if (sCorrect)
                sCorrect = findDuplicateFunNames();
            if (sCorrect)
                sCorrect = findParametersAndTypes();
            if (sCorrect)
                sCorrect = CheckFunctionCalls();

            //Added by Sujith on 07/20/2005 for solving issue 1718
            //Start
            if (sCorrect)
                sCorrect = CheckProgram();
            //End

            //iPc is defined as 0

            //Therefore if sCorrect = TRUE THEN -1
            //ELSE iLine = 0


            arrLevels[currentLevelIndex].tHState.curLine = arrLevels[currentLevelIndex].tHState.PC = (sCorrect) ? 0 : -1;

            if (!sCorrect)
            {
                DisableMenu();
                mnuResetHerbt.Enabled = true;
                arrLevels[currentLevelIndex].blnResetState = true;
                btStop.Enabled = true;
            }

            arrLevels[currentLevelIndex].tHState.Flags |= HFNWLIN;
            //hunlock((**ahtTERecs[PLAYWIN]).htext);
            return (sCorrect);
        }


        /// <summary>
        /// checks the defination of function whether this is allowed or not.
        /// </summary>
        /// <param name="piNumParms">number of parameters of fucntion</param>
        /// <param name="iPC">current execution point.</param>
        /// <returns>returns true if defination is as per the rules else false.</returns>
        private bool CheckDef(ref int piNumParms, int iPC)
        {
            //int i;
            bool sCorrect;
            char c;

            sCorrect = true;
            piNumParms = 0;
            c = arrLevels[currentLevelIndex].pcProg[iPC++];
            /* function name is upper case letter */
            if (c == ':')
            {
                DispMessage("Missing function name");
                sCorrect = false;
            }
            else
                if (!Char.IsLetter(c))
                {
                    //begin added by piyush on 31 Mar 2005
                    if (Char.IsWhiteSpace(c))
                    {
                        DispMessage("Whitespace is not allowed");
                        selectError(iPC - 1, 1);
                        sCorrect = false;
                    }
                    //end added by piyush on 31 Mar 2005
                    else
                    {
                        DispMessage("Only lowercase letters allowed for function names");
                        sCorrect = false;
                    }
                }
                else
                    if (!Char.IsLower(c))
                    {
                        DispMessage("Use lowercase function names");
                        sCorrect = false;
                    }
            if (sCorrect)
            {
                switch (arrLevels[currentLevelIndex].pcProg[iPC++])
                {
                    case '(':
                        do
                        { /* navigate till you don't find char ',' */
                            c = arrLevels[currentLevelIndex].pcProg[iPC++];
                            if (!Char.IsUpper(c))
                            {
                                DispMessage("Illegal parameter name");
                                sCorrect = false;
                            }
                            (piNumParms)++;
                        } while (arrLevels[currentLevelIndex].pcProg[iPC++] == ',');
                        iPC--;
                        /* check to see if last char is ')' else give proper error msg. */
                        if (sCorrect && arrLevels[currentLevelIndex].pcProg[iPC++] != ')')
                        {
                            DispMessage("')' expected");
                            sCorrect = false;
                        }
                        /* check to see if last char is next to last char is ':' else give proper error msg. */
                        if (sCorrect && arrLevels[currentLevelIndex].pcProg[iPC++] != ':')
                        {
                            DispMessage("':' expected");
                            sCorrect = false;
                        }
                        break;
                    /* if function defined without any parameter */
                    case ':':
                        while (sCorrect && iPC < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[iPC] != CR)
                        {
                            sCorrect = CheckVStatement(ref iPC); /* always returns true and increments the parameter pointer by 1*/
                        }
                        break;
                    default:
                        DispMessage("':' or '(' expected");
                        sCorrect = false;
                        break;
                }
            }
            return (sCorrect);
        }


        private bool CheckFunctionCalls()
        {
            bool blnReturn = true;
            blnReturn = CheckExecutionLine();
            if (!blnReturn)
                return blnReturn;
            //			int totalLines = txtCodeEditor.Lines.Length;
            //			int refindex = 0;
            //			for(int i = 1; i < totalLines; i++)
            //			{
            //				char c = atLineInfo[i].cFunc;
            //				int charindex = 0;
            //				while(charindex < pcProg.Length)
            //				{
            //					if(pcProg[charindex] == c && charindex != atLineInfo[i].iStart)
            //					{
            //						if(charindex+1 < pcProg.Length)
            //						{
            //							if(pcProg[charindex + 1] != ':')
            //							{
            //								if(atLineInfo[i].sNumParms == 0 && pcProg[charindex+1] == '(')
            //								{
            //									DispMessage("No parameter required for function '" +pcProg[charindex].ToString() + "'");
            //									blnReturn = false;
            //									break;
            //								}
            //								else if(atLineInfo[i].sNumParms != 0)
            //								{
            //									refindex = charindex;
            //									blnReturn = CheckNumArgs(ref refindex, atLineInfo[i].sNumParms);
            //									if(!blnReturn)
            //										break;
            //								}
            //							}
            //						}
            //						else if(atLineInfo[i].sNumParms != 0)
            //						{
            //							DispMessage("Number of parameter for function '" + pcProg[charindex].ToString()+"' " + "not matching");
            //							blnReturn = false;
            //							break;
            //						}
            //
            //					}
            //					charindex++;
            //				}
            //			}
            blnReturn = parseForCheckNumArgs(0);
            return blnReturn;
        }


        //Added by Sujith on 07/20/2005 for solving issue 1718
        //Start
        private bool CheckProgram()
        {
            bool blnFuncName = false;
            for (int i = 0; i < arrLevels[currentLevelIndex].pcProg.Length; i++)
            {
                if (arrLevels[currentLevelIndex].pcProg[i] != ':' && arrLevels[currentLevelIndex].pcProg[i] != '|' && arrLevels[currentLevelIndex].pcProg[i] != ',' && arrLevels[currentLevelIndex].pcProg[i] != '-' && arrLevels[currentLevelIndex].pcProg[i] != '+' && arrLevels[currentLevelIndex].pcProg[i] != '(' && arrLevels[currentLevelIndex].pcProg[i] != ')' && !Char.IsDigit(arrLevels[currentLevelIndex].pcProg[i]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i]) && arrLevels[currentLevelIndex].pcProg[i] != 's' && arrLevels[currentLevelIndex].pcProg[i] != 'r' && arrLevels[currentLevelIndex].pcProg[i] != 'l' && arrLevels[currentLevelIndex].pcProg[i] != CR)
                {
                    for (int j = 0; j < arrLevels[currentLevelIndex].iNumLines; j++)
                    {

                        if (arrLevels[currentLevelIndex].atLineInfo[j].cFunc == arrLevels[currentLevelIndex].pcProg[i])
                        {
                            blnFuncName = true;
                        }
                    }
                    if (!blnFuncName)
                    {
                        DispMessage("No function definition found for '" + arrLevels[currentLevelIndex].pcProg[i] + "'");
                        selectError(i, 1);
                        return false;
                    }
                }

                blnFuncName = false;
            }
            return true;
        }


        // End

        private bool findParametersAndTypes()
        {
            int txtceNumLine = 0;

            txtceNumLine = txtTotalLines;

            for (int i = 1; i < arrLevels[currentLevelIndex].iNumLines; i++)
            {
                if (arrLevels[currentLevelIndex].atLineInfo[i].sNumParms > 15)
                {
                    DispMessage("Function '" + arrLevels[currentLevelIndex].pcProg[arrLevels[currentLevelIndex].atLineInfo[i].iStart].ToString() + "': More than 15 parameters are not allowed");
                    selectError(arrLevels[currentLevelIndex].atLineInfo[i].iStart, 1);
                    return false;
                }
                arrLevels[currentLevelIndex].atLineInfo[i].paramNames = new char[arrLevels[currentLevelIndex].atLineInfo[i].sNumParms, 2];
                int index = 0;
                if (arrLevels[currentLevelIndex].atLineInfo[i].sNumParms >= 0)
                {
                    int j = 0;
                    for (j = arrLevels[currentLevelIndex].atLineInfo[i].iStart; arrLevels[currentLevelIndex].pcProg[j] != ':' && j < arrLevels[currentLevelIndex].iProgLen; j++)
                    {
                        switch (arrLevels[currentLevelIndex].pcProg[j])
                        {
                            case ',':
                                break;
                            case '(':
                                break;
                            case ')':
                                break;
                            default:
                                if (Char.IsUpper(arrLevels[currentLevelIndex].pcProg[j]) && Char.IsLetter(arrLevels[currentLevelIndex].pcProg[j]) && arrLevels[currentLevelIndex].atLineInfo[i].sNumParms > 0)
                                {
                                    arrLevels[currentLevelIndex].atLineInfo[i].paramNames[index, 0] = arrLevels[currentLevelIndex].pcProg[j];
                                    arrLevels[currentLevelIndex].atLineInfo[i].paramNames[index, 1] = 'A';
                                    for (int y = index - 1; y >= 0; y--)
                                    {
                                        if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[y, 0] == arrLevels[currentLevelIndex].atLineInfo[i].paramNames[index, 0])
                                        {
                                            DispMessage("Duplicate parameter name for function'" + arrLevels[currentLevelIndex].atLineInfo[i].cFunc.ToString() + "'");
                                            selectError(j, 1);
                                            return false;
                                        }
                                    }
                                    index++;
                                }
                                break;
                        }
                    }
                    //begin added by piyush for limiting max chars on line to 127 on 31 Mar 2005
                    int charCountPerLine = 0;
                    //end added by piyush for limiting max chars on line to 127 on 31 Mar 2005
                    for (int k = j; k < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[k] != CR; k++)
                    {
                        charCountPerLine++;
                        if (Char.IsUpper(arrLevels[currentLevelIndex].pcProg[k]))
                        {
                            bool IsParamDefined = false;

                            for (int paramCount = 0; paramCount < arrLevels[currentLevelIndex].atLineInfo[i].sNumParms; paramCount++)
                            {
                                if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[paramCount, 0] == arrLevels[currentLevelIndex].pcProg[k])
                                {
                                    IsParamDefined = true;
                                    break;
                                }
                            }

                            if (IsParamDefined == false)
                            {
                                DispMessage("Parameter '" + arrLevels[currentLevelIndex].pcProg[k].ToString() + "' is not found in function definition");
                                selectError(k, 1);
                                return false;
                            }
                        }
                        for (int l = 0; l < arrLevels[currentLevelIndex].atLineInfo[i].sNumParms; l++)
                        {
                            if (arrLevels[currentLevelIndex].pcProg[k] == arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0])
                            {
                                if (k - 1 >= 0)
                                    switch (arrLevels[currentLevelIndex].pcProg[k - 1])
                                    {
                                        case '|':
                                            break;
                                        case ':':
                                            break;
                                        case ',':
                                            break;
                                        case '(':
                                            break;
                                        case ')':
                                            break;
                                        case '+':
                                            if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'S' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'I';
                                            else
                                            {
                                                DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "': procedural argument used as numeric");
                                                selectError(k, 1);
                                                return false;
                                            }
                                            break;
                                        case '-':
                                            if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'S' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'I';
                                            else
                                            {
                                                DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "': procedural argument used as numeric");
                                                selectError(k, 1);
                                                return false;
                                            }
                                            break;
                                        default:
                                            if (Char.IsLetter(arrLevels[currentLevelIndex].pcProg[k - 1]))
                                            {
                                                if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'I' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                    arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'S';
                                                else
                                                {
                                                    DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "' : procedural argument used as numeric");
                                                    selectError(k, 1);
                                                    return false;
                                                }
                                                break;
                                            }
                                            else if (arrLevels[currentLevelIndex].pcProg[k - 1] == ' ')
                                            {
                                                DispMessage("Whitespace is not allowed");
                                                selectError(k - 1, 1);
                                                return false;
                                            }
                                            else if ((arrLevels[currentLevelIndex].pcProg[k - 1] != CR))
                                            {
                                                //begin changed by piyush on 31 Mar 2005
                                                DispMessage("Invalid character");
                                                //end changed by piyush on 31 Mar 2005
                                                selectError(k - 1, 1);
                                                return false;
                                            }
                                            break;
                                    }
                                if (k + 1 < arrLevels[currentLevelIndex].iProgLen)
                                    switch (arrLevels[currentLevelIndex].pcProg[k + 1])
                                    {
                                        case '|':
                                            break;
                                        case ':':
                                            break;
                                        case ',':
                                            break;
                                        case '(':
                                            break;
                                        case ')':
                                            break;
                                        case '+':
                                            if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'S' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'I';
                                            else
                                            {
                                                DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "': procedural argument used as numeric");
                                                selectError(k, 1);
                                                return false;
                                            }
                                            break;
                                        case '-':
                                            if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'S' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'I';
                                            else
                                            {
                                                DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "': procedural argument used as numeric");
                                                selectError(k, 1);
                                                return false;
                                            }
                                            break;
                                        default:
                                            if (Char.IsLetter(arrLevels[currentLevelIndex].pcProg[k + 1]))
                                            {
                                                if (arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] != 'I' || arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] == 'A')
                                                    arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 1] = 'S';
                                                else
                                                {
                                                    DispMessage("Parameter '" + arrLevels[currentLevelIndex].atLineInfo[i].paramNames[l, 0].ToString() + "': procedural argument used as numeric");
                                                    selectError(k, 1);
                                                    return false;
                                                }
                                                break;
                                            }
                                            else if (Char.IsWhiteSpace(arrLevels[currentLevelIndex].pcProg[k - 1]))
                                            {
                                                DispMessage("Whitespace is not allowed");
                                                selectError(k + 1, 1);
                                                return false;
                                            }
                                            else if ((arrLevels[currentLevelIndex].pcProg[k + 1] != CR))
                                            {
                                                //begin changed by piyush on 31 Mar 2005
                                                DispMessage("Invalid character");
                                                //end changed by piyush on 31 Mar 2005
                                                selectError(k + 1, 1);
                                                return false;
                                            }
                                            break;
                                    }
                            }
                        }
                    }
                    //added by vivek
                    for (int k = j; k < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[k] != CR; k++)
                    {
                        if (arrLevels[currentLevelIndex].pcProg[k] == '(')
                        {
                            if ((k - 1 >= 0) && Char.IsUpper(arrLevels[currentLevelIndex].pcProg[k - 1]))
                            {
                                DispMessage("Function name expected.");
                                selectError(k - 1, 1);
                                return false;
                            }
                        }
                    }
                    //begin added by piyush for limiting max chars on line to 127 on 31 Mar 2005
                    charCountPerLine = charCountPerLine - 1;
                    if (charCountPerLine > MAXCHARSONLINE)
                    {
                        int actualLineNumber = getActualLineNum(i) + 1;
                        DispMessage("Number of characters on line " + actualLineNumber.ToString() + " exceeded maximum limit");
                        return false;
                    }
                    //end added by piyush for limiting max chars on line to 127 on 31 Mar 2005
                }
            }
            return true;
        }


        private bool findDuplicateFunNames()
        {
            bool blnReturn = true;
            int txtCENumLines = 0;
            txtCENumLines = txtTotalLines;
            for (int i = 1; i < txtCENumLines; i++)
            {
                for (int j = i + 1; j < txtCENumLines; j++)
                {
                    if (arrLevels[currentLevelIndex].atLineInfo[i].cFunc == arrLevels[currentLevelIndex].atLineInfo[j].cFunc && arrLevels[currentLevelIndex].atLineInfo[i].cFunc != '\0')
                    {
                        //selectError(getActualCharNum(atLineInfo[j].iStart), 1);
                        DispMessage("Duplicate function name '" + arrLevels[currentLevelIndex].atLineInfo[i].cFunc.ToString() + "'");
                        blnReturn = false;
                        break;
                    }
                }
                if (!blnReturn)
                    break;
            }
            for (int i = 0; i < txtCENumLines; i++)
            {
                if (txtLines[i].Length == 0)
                {
                    int x = i + 1;
                    DispMessage("Line no " + x.ToString() + ": Blank lines are not allowed");
                    blnReturn = false;
                    break;
                }
            }
            return blnReturn;
        }


        private bool parseForCheckNumArgs(int startIndex)
        {
            bool blnReturn = true;
            int totalLines = txtTotalLines;
            int refindex = 0;
            for (int i = 1; i < totalLines; i++)
            {
                char c = arrLevels[currentLevelIndex].atLineInfo[i].cFunc;
                if (c == 's' || c == 'l' || c == 'r' || c == '|')
                {
                    DispMessage("'" + c.ToString() + "' cannot be used as function name");
                    selectError(arrLevels[currentLevelIndex].atLineInfo[i].iStart, 1);
                    blnReturn = false;
                    break;
                }
                int charindex = startIndex;
                while (charindex < arrLevels[currentLevelIndex].pcProg.Length)
                {
                    if (arrLevels[currentLevelIndex].pcProg[charindex] == c && charindex != arrLevels[currentLevelIndex].atLineInfo[i].iStart)
                    {
                        if (charindex + 1 < arrLevels[currentLevelIndex].pcProg.Length)
                        {
                            if (arrLevels[currentLevelIndex].pcProg[charindex + 1] != ':')
                            {
                                if (arrLevels[currentLevelIndex].atLineInfo[i].sNumParms == 0 && arrLevels[currentLevelIndex].pcProg[charindex + 1] == '(')
                                {
                                    DispMessage("No parameters required for function '" + arrLevels[currentLevelIndex].pcProg[charindex].ToString() + "'");
                                    selectError(charindex, 1);
                                    blnReturn = false;
                                    break;
                                }
                                else if (arrLevels[currentLevelIndex].atLineInfo[i].sNumParms != 0)
                                {
                                    refindex = charindex;
                                    blnReturn = CheckNumArgs(ref refindex, i);
                                    if (!blnReturn)
                                        break;
                                }
                            }
                        }
                        else if (arrLevels[currentLevelIndex].atLineInfo[i].sNumParms != 0)
                        {
                            DispMessage("Incorrect number of arguments for function '" + arrLevels[currentLevelIndex].pcProg[charindex].ToString() + "' ");
                            selectError(charindex, 1);
                            blnReturn = false;
                            break;
                        }

                    }
                    charindex++;
                    if (!blnReturn)
                        break;
                }
            }
            return blnReturn;
        }


        private bool CheckExecutionLine()
        {
            if (txtLines[getActualLineNum(0)].Length > MAXCHARSONLINE)
            {
                int actualLineNumber = getActualLineNum(0) + 1;
                DispMessage("Number of characters on line " + actualLineNumber.ToString() + " exceeded maximum limit");
                return false;
            }
            else
                if (txtTotalLines == 1)
                {
                    for (int i = 0; i < arrLevels[currentLevelIndex].pcProg.Length; i++)
                    {
                        if (arrLevels[currentLevelIndex].pcProg[i] != '|')
                        {
                            //bc added + and - check
                            if (!Char.IsLetter(arrLevels[currentLevelIndex].pcProg[i]) && arrLevels[currentLevelIndex].pcProg[i] != '+' && arrLevels[currentLevelIndex].pcProg[i] != '-')
                            {
                                DispMessage("Invalid character '" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' in execution line");
                                selectError(i, 1);
                                return false;
                            }
                            else
                                if (Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i]))
                                {
                                    DispMessage("Uppercase letters only allowed for parameter names");
                                    selectError(i, 1);
                                    return false;
                                }
                                else if (!(arrLevels[currentLevelIndex].pcProg[i] == 's' || arrLevels[currentLevelIndex].pcProg[i] == 'r' || arrLevels[currentLevelIndex].pcProg[i] == 'l' || arrLevels[currentLevelIndex].pcProg[i] == '|'))
                                {
                                    DispMessage("No function definition found for '" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "'");
                                    selectError(i, 1);
                                    return false;
                                }
                        }
                    }
                }
                else
                {
                    for (int i = arrLevels[currentLevelIndex].atLineInfo[0].iStart; i < arrLevels[currentLevelIndex].atLineInfo[0].iStart + txtLines[getActualLineNum(0)].Length; i++)
                    {
                        if (arrLevels[currentLevelIndex].pcProg[i] != '|')
                        {
                            //bc added + and -
                            if (!Char.IsLetter(arrLevels[currentLevelIndex].pcProg[i]) && arrLevels[currentLevelIndex].pcProg[i] != '(' && arrLevels[currentLevelIndex].pcProg[i] != ')' && arrLevels[currentLevelIndex].pcProg[i] != '+' && arrLevels[currentLevelIndex].pcProg[i] != '-' && arrLevels[currentLevelIndex].pcProg[i] != ',' && !Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i]))
                            {
                                DispMessage("Invalid character '" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' in execution line");
                                selectError(i, 1);
                                return false;
                            }
                            else
                                if (Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i]))
                                {
                                    DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' is undefined");
                                    selectError(i, 1);
                                    return false;
                                }
                        }
                    }
                }
            //			else
            //			{
            //				CheckNumArgs(ref atLineInfo[0].iStart, 0);
            //			}
            return true;
        }


        private bool CheckNumArgs(ref int index, int iVirtualLineNum)
        {
            int i = index;
            int persistantIndex = index;
            int numComma = 0;
            bool openBracks = false, closeBracks = false;
            int iOpenParamLevel = 0, iCloseParamLevel = 0;
            while (i < arrLevels[currentLevelIndex].iProgLen && arrLevels[currentLevelIndex].pcProg[i] != CR)
            {
                bool refdone = false;
                switch (arrLevels[currentLevelIndex].pcProg[i])
                {
                    case '(': openBracks = true;
                        if (iOpenParamLevel == 1)
                        {
                            DispMessage("Too many '(' for function '" + arrLevels[currentLevelIndex].pcProg[persistantIndex].ToString() + "'");
                            selectError(i, 1);
                            return false;
                        }
                        iOpenParamLevel++;
                        break;
                    case ')': closeBracks = true;
                        if (iCloseParamLevel == 1)
                        {
                            DispMessage("Too many ')' for function '" + arrLevels[currentLevelIndex].pcProg[persistantIndex].ToString() + "'");
                            selectError(i, 1);
                            return false;
                        }
                        iCloseParamLevel++;
                        if (numComma < arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms && i - 1 >= 0)
                        {
                            if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].paramNames[numComma, 1] == 'I')
                            {
                                if (!Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i - 1]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i - 1]) && arrLevels[currentLevelIndex].pcProg[i - 1] != ')')
                                {
                                    DispMessage("Numeric argument expected ");
                                    selectError(i - 1, 1);
                                    return false;
                                }

                            }
                            else if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].paramNames[numComma, 1] == 'S')
                            {
                                if (Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i - 1]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i - 1]))
                                {
                                    DispMessage("Procedural argument expected");
                                    selectError(i - 1, 1);
                                    return false;
                                }

                            }
                        }
                        break;
                    case ',':
                        if (numComma < arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms && i - 1 >= 0)
                        {
                            if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].paramNames[numComma, 1] == 'I')
                            {
                                if (!Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i - 1]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i - 1]))
                                {
                                    DispMessage("Integer parameter expected");
                                    selectError(i - 1, 1);
                                    return false;
                                }

                            }
                            else if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].paramNames[numComma, 1] == 'S')
                            {
                                if (Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i - 1]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i - 1]))
                                {
                                    DispMessage("Character parameter expected");
                                    selectError(i - 1, 1);
                                    return false;
                                }

                            }
                        }
                        numComma++;
                        break;
                    default:
                        try
                        {
                            if (i > index && Char.IsLower(arrLevels[currentLevelIndex].pcProg[i]))
                            {
                                int txtCENumLine = 0;
                                //							lock(txtCodeEditor)
                                //							{
                                txtCENumLine = txtTotalLines;

                                //							}
                                bool functfound = false;
                                for (int z = 1; z < txtCENumLine; z++)
                                {
                                    if (arrLevels[currentLevelIndex].pcProg[i] == arrLevels[currentLevelIndex].atLineInfo[z].cFunc)
                                    {
                                        //begin changed by piyush
                                        //for Error:
                                        /*
                                        No function found error for following code
                                        a(A,B,C):ABa(Ass,BC,Cs)
                                        b:rslsr
                                        a(b,b,)
                                        */
                                        functfound = true;
                                        if (arrLevels[currentLevelIndex].atLineInfo[z].sNumParms > 0)
                                        {
                                            //end changed by piyush

                                            if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].paramNames[numComma, 1] == 'I')
                                            {
                                                if (!Char.IsNumber(arrLevels[currentLevelIndex].pcProg[i]) && !Char.IsUpper(arrLevels[currentLevelIndex].pcProg[i]))
                                                {
                                                    DispMessage("Integer parameter expected");
                                                    selectError(i, 1);
                                                    return false;
                                                }
                                            }
                                            functfound = true;
                                            bool blnRetrun = CheckNumArgs(ref i, z);
                                            if (!blnRetrun)
                                                return false;
                                            refdone = true;
                                            break;
                                        }
                                    }

                                }
                                if (arrLevels[currentLevelIndex].pcProg[i] != 's' && arrLevels[currentLevelIndex].pcProg[i] != 'l' && arrLevels[currentLevelIndex].pcProg[i] != 'r' && arrLevels[currentLevelIndex].pcProg[i] != '|' && !functfound)
                                {
                                    DispMessage("No function definition found for '" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "'");
                                    selectError(i, 1);
                                    return false;
                                }
                            }
                            else if (Char.IsWhiteSpace(arrLevels[currentLevelIndex].pcProg[i]))
                            {
                                DispMessage("Whitespace is not allowed");
                                selectError(i, 1);
                                return false;
                            }
                            else if (!(Char.IsLetterOrDigit(arrLevels[currentLevelIndex].pcProg[i]) || arrLevels[currentLevelIndex].pcProg[i] == '+' || arrLevels[currentLevelIndex].pcProg[i] == '-'))
                            {
                                if (arrLevels[currentLevelIndex].pcProg[i] == '&')
                                {
                                    DispMessage("'&&' is an invalid character");
                                    selectError(i, 1);
                                    return false;
                                }
                                else
                                {
                                    DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' is an invalid character");
                                    selectError(i, 1);
                                    return false;
                                }
                            }
                        }
                        catch
                        {

                            ////Console.WriteLine(exp.Message);
                        }
                        break;
                }
                if (i < arrLevels[currentLevelIndex].iProgLen)
                    if (arrLevels[currentLevelIndex].pcProg[i] == ')' && !refdone)
                    {
                        index = ++i;
                        break;
                    }
                if (!refdone)
                    i++;
                else
                    refdone = false;
            }
            if (!openBracks && arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms != 0)
            {
                DispMessage("No parameters passed to function '" + arrLevels[currentLevelIndex].pcProg[persistantIndex].ToString() + "'");
                selectError(persistantIndex, 1);
                return false;
            }
            else if (!closeBracks && arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms != 0)
            {
                DispMessage("')' missing for function '" + arrLevels[currentLevelIndex].pcProg[persistantIndex].ToString() + "'");
                selectError(persistantIndex, 1);
                return false;
            }
            else if (numComma + 1 != arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms && arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].sNumParms != 0)
            {
                DispMessage("Incorrect number of arguments for function '" + arrLevels[currentLevelIndex].pcProg[persistantIndex].ToString() + "' ");
                selectError(persistantIndex, 1);
                return false;
            }
            return true;
        }


        private bool checkInvalidChar()
        {
            //txtTotalLength;
            for (int i = 0; i < txtTotalLength; i++)
            {
                int ASCIIval = (int)arrLevels[currentLevelIndex].pcProg[i];
                switch (arrLevels[currentLevelIndex].pcProg[i])
                {
                    case (char)10:
                        break;
                    case ',':
                        break;
                    case ':':
                        break;
                    case ')':
                        //						//begin added by piyush
                        //						//for bugid 1329
                        //						if(pcProg[i - 1] == '+' || pcProg[i - 1] == '-')
                        //						{
                        //							DispMessage("'"+pcProg[i - 1] + "' is an invalid character");
                        //							selectError(i-1,1);
                        //							return false;
                        //						}
                        //						//end added by piyush
                        break;
                    case '(':
                        if (i - 1 >= 0)
                        {
                            if (arrLevels[currentLevelIndex].pcProg[i - 1] == 's' || arrLevels[currentLevelIndex].pcProg[i - 1] == 'r' || arrLevels[currentLevelIndex].pcProg[i - 1] == 'l')
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i - 1] + "' keywords cannot be used as function name");
                                selectError(i - 1, 1);
                                return false;
                            }
                        }
                        //begin added by piyush
                        //						//for bugid 1329
                        //						
                        //						if(i+1 < iProgLen && pcProg[i+1] != CR)
                        //						{
                        //							if(pcProg[i + 1] == '+' || pcProg[i + 1] == '-')
                        //							{
                        //								DispMessage("'"+pcProg[i + 1] + "' is an invalid character");
                        //								selectError(i+1,1);
                        //								return false;
                        //							}
                        //						}
                        //						//end added by piyush
                        break;
                    case '-':
                        //begin added by piyush on 31 Mar 2005
                        if (i + 1 < arrLevels[currentLevelIndex].iProgLen && i - 1 >= 0)
                        {
                            if (arrLevels[currentLevelIndex].pcProg[i - 1] == '(' && arrLevels[currentLevelIndex].pcProg[i + 1] == ')')
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                            else if (arrLevels[currentLevelIndex].pcProg[i + 1] == ')')
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }//added condition for more than 1 consecutive -
                            else if (arrLevels[currentLevelIndex].pcProg[i - 1] != '(' && !Char.IsLetterOrDigit(arrLevels[currentLevelIndex].pcProg[i - 1]))
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                        }
                        //end added by piyush on 31 Mar 2005
                        //						if(i+1 < iProgLen)
                        //							if(Char.IsNumber(pcProg[i-1]) && Char.IsNumber(pcProg[i+1]))
                        //							{
                        ////bc								DispMessage("Subtraction of numbers is not allowed");
                        ////bc								selectError(i,1);
                        ////bc								return false;
                        //							}
                        break;
                    case '+':
                        //begin added by piyush on 31 Mar 2005
                        if (i + 1 < arrLevels[currentLevelIndex].iProgLen && i - 1 >= 0)
                        {
                            if (arrLevels[currentLevelIndex].pcProg[i - 1] == '(' && arrLevels[currentLevelIndex].pcProg[i + 1] == ')')
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                            else if (arrLevels[currentLevelIndex].pcProg[i + 1] == ')')
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }	//added condition for more than 1 consecutive +
                            else if (arrLevels[currentLevelIndex].pcProg[i - 1] != '(' && !Char.IsLetterOrDigit(arrLevels[currentLevelIndex].pcProg[i - 1]))
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i] + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                        }
                        //end added by piyush on 31 Mar 2005
                        //						if(i+1 < iProgLen)
                        //							if(Char.IsNumber(pcProg[i-1]) && Char.IsNumber(pcProg[i+1]))
                        //							{
                        ////bc								DispMessage("Addition of numbers is not allowed");
                        ////bc								selectError(i,1);
                        ////bc								return false;
                        //							}
                        break;
                    case '|':
                        break;
                    default:
                        int z = i;
                        if (Char.IsDigit(arrLevels[currentLevelIndex].pcProg[i]))
                        {
                            StringBuilder sbNumber = new StringBuilder();
                            while (Char.IsDigit(arrLevels[currentLevelIndex].pcProg[i]))
                            {
                                sbNumber.Append(arrLevels[currentLevelIndex].pcProg[i]);
                                i++;
                                if (i == arrLevels[currentLevelIndex].iProgLen)
                                    break;
                            }

                            i--;

                            /*Added by Vivek to set range of numeric values between -255 and 256*/

                            try
                            {
                                short tmpNum = 0;
                                if (z - 1 > 0)
                                {
                                    if (arrLevels[currentLevelIndex].pcProg[z - 1] == '-')
                                    {
                                        tmpNum = System.Int16.Parse(sbNumber.Insert(0, "-").ToString());
                                    }
                                    else
                                        tmpNum = System.Int16.Parse(sbNumber.ToString());
                                }
                                if (tmpNum < -256)
                                {
                                    DispMessage("Number should not be less than -256");
                                    selectError(i - sbNumber.Length + 1, sbNumber.Length);
                                    return false;
                                }
                                else if (tmpNum > 255)
                                {
                                    DispMessage("Number should not be greater than 255");
                                    selectError(i - sbNumber.Length + 1, sbNumber.Length);
                                    return false;
                                }

                            }
                            catch (OverflowException)
                            {
                                if (z - 1 > 0)
                                {
                                    if (arrLevels[currentLevelIndex].pcProg[z - 1] == '-')
                                    {
                                        DispMessage("Number should not be less than -256");
                                        selectError(i - sbNumber.Length + 1, sbNumber.Length);
                                        return false;
                                    }
                                    else
                                    {
                                        DispMessage("Number should not be greater than 255");
                                        selectError(i - sbNumber.Length + 1, sbNumber.Length);
                                        return false;
                                    }
                                }
                            }
                        }
                        else if (!Char.IsLetterOrDigit(arrLevels[currentLevelIndex].pcProg[i]))
                        {
                            if (Char.IsWhiteSpace(arrLevels[currentLevelIndex].pcProg[i]))
                            {
                                DispMessage("Whitespace is not allowed");
                                selectError(i, 1);
                                return false;
                            }
                            else if (arrLevels[currentLevelIndex].pcProg[i] == '&')
                            {
                                DispMessage("'&&' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                            else
                            {
                                DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' is an invalid character");
                                selectError(i, 1);
                                return false;
                            }
                        }
                        else if ((ASCIIval < 65) || (ASCIIval > 122))
                        {
                            DispMessage("'" + arrLevels[currentLevelIndex].pcProg[i].ToString() + "' is an invalid character");
                            selectError(i, 1);
                            return false;
                        }
                        break;
                }
            }
            return true;
        }


        /// <summary>
        /// dummy function.
        /// </summary>
        /// <param name="iPC"></param>
        /// <returns></returns>
        private bool CheckExec(int iPC)
        {
            return (true);
        }


        /// <summary>
        /// checks number of args in the function call should be equal to num args in the function defination.
        /// </summary>
        /// <param name="message">error message</param>
        /// <returns>returns true if no error.</returns>
        //		private bool CheckNumArgs(out string message)
        //		{
        ////			int numLines = txtCodeEditor.Lines.Length;
        ////			int iStartIndex = 1; // because index 0 in atLineInfo structure is reserved for execution line only.
        ////			for(iStartIndex; iStartIndex < numLines; iStartIndex++)
        ////			{
        ////				if(atLineInfo[iStartIndex].sNumParms > 0)
        ////				{
        ////
        ////				}
        ////			}
        //			message="";
        //			return true;
        //		}


        /// <summary>
        /// increases the current execution point by 1.
        /// </summary>
        /// <param name="piPC">current execution point.</param>
        /// <returns>always true</returns>
        private bool CheckVStatement(ref int piPC)
        {
            (piPC)++;
            return (true);
        }


        /// <summary>
        /// checks for stack frame if it is valid.
        /// </summary>
        /// <param name="iSP">current stack point</param>
        /// <returns>true or false</returns>
        private bool ValidFrame(int iSP)
        {
            int iNextFrame;
            /* argument stack contains 0*/
            if (arrLevels[currentLevelIndex].aiStack[iSP] == 0)
                return (false);
            else
            {
                iNextFrame = (int)(iSP + 1 + (((uint)arrLevels[currentLevelIndex].aiStack[iSP] & 0xf000) >> 12)) % STACKSIZE;	/*+box info*/ /*??????????*/

                bool a = arrLevels[currentLevelIndex].iTrashedSP >= iNextFrame && arrLevels[currentLevelIndex].iTrashedSP <= iSP;

                if (iNextFrame > iSP)
                    return (arrLevels[currentLevelIndex].iTrashedSP >= iNextFrame || arrLevels[currentLevelIndex].iTrashedSP <= iSP);
                else
                    return (arrLevels[currentLevelIndex].iTrashedSP >= iNextFrame && arrLevels[currentLevelIndex].iTrashedSP <= iSP);
            }
        }


        /// <summary>
        /// inserts the frame in stack.
        /// </summary>
        /// <param name="iSize">size of the frame.</param>
        /// <returns>new stack pointer.</returns>
        private int PushFrame(int iSize)
        {
            int iNewSP;
            /* i need to check for trashing of currentargframe */

            if ((iNewSP = arrLevels[currentLevelIndex].iSP - iSize) < 0)
            {
                iNewSP += STACKSIZE;
                if (arrLevels[currentLevelIndex].iTrashedSP > iNewSP || arrLevels[currentLevelIndex].iTrashedSP <= arrLevels[currentLevelIndex].iSP)
                {
                    arrLevels[currentLevelIndex].iTrashedSP = iNewSP;
                    arrLevels[currentLevelIndex].sStackTrashed = true;
                    arrLevels[currentLevelIndex].stackInitialisationCounter++;
                    /*if(arrLevels[currentLevelIndex].stackInitialisationCounter > 1)
                    {
                        DispMessage("Program too complex (stack overflow)");
                        InternalError(-1);
                        arrLevels[currentLevelIndex].stackInitialisationCounter = 0;
                    }*/
                    //arrLevels[currentLevelIndex].sStackInitialised = !(arrLevels[currentLevelIndex].sStackInitialised) ; 
                }
            }
            else
            {
                if (arrLevels[currentLevelIndex].iTrashedSP > iNewSP || arrLevels[currentLevelIndex].iTrashedSP <= arrLevels[currentLevelIndex].iSP)
                {
                    arrLevels[currentLevelIndex].iTrashedSP = iNewSP;
                }
            }
            return (iNewSP);
        }


        /// <summary>
        /// returns the frame.
        /// </summary>
        /// <returns>new stack pointer.</returns>
        private int PopFrame()/*result must be assigned to iSP - trashes old frame*/
        {
            //			int iNextFrame;
            //
            //			iNextFrame=(int)(iSP+1+(((uint)(aiStack[iSP]&0xf000))>>12))%STACKSIZE; /*?????????????*/
            //			if (iSP == iTrashedSP)
            //				aiStack[iSP]=0;
            //			return(iNextFrame);
            int iNextFrame;
#if(DESIGNER)
            if ((arrLevels[currentLevelIndex].iSP != 0) && (arrLevels[currentLevelIndex].MaxStackLength > arrLevels[currentLevelIndex].iSP))
            {
                if (!arrLevels[currentLevelIndex].isLevelSolutionValid)
                {
                    arrLevels[currentLevelIndex].MaxStackLength = (STACKSIZE) - arrLevels[currentLevelIndex].iSP;
                    if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                        arrLevels[currentLevelIndex].MaxStackLengthPersistent = arrLevels[currentLevelIndex].MaxStackLength;
                }
            }
#endif
            iNextFrame = (int)(arrLevels[currentLevelIndex].iSP + 1 + (((uint)(arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] & 0xf000)) >> 12)) % STACKSIZE; /*?????????????*/
            if (arrLevels[currentLevelIndex].iSP == arrLevels[currentLevelIndex].iTrashedSP)
                arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] = 0;
            //bc1280 start - added to check for popping a frame into a trashed portion of stack
            if (((iNextFrame > arrLevels[currentLevelIndex].iSP && (arrLevels[currentLevelIndex].iSP < arrLevels[currentLevelIndex].iTrashedSP && iNextFrame >= arrLevels[currentLevelIndex].iTrashedSP))
                || (iNextFrame < arrLevels[currentLevelIndex].iSP && (arrLevels[currentLevelIndex].iSP < arrLevels[currentLevelIndex].iTrashedSP || iNextFrame >= arrLevels[currentLevelIndex].iTrashedSP))))
            {
                DispMessage("Program too complex (stack overflow)");
                InternalError(-1);
            }
            //bc1280 end

            return (iNextFrame);
        }


        /// <summary>
        /// returns the current argument frame.
        /// </summary>
        /// <param name="iValFrame">valid frame number.</param>
        /// <returns>valid frame number</returns>
        private int CurrentArgFrame(int iValFrame)
        {
            int iArgFrame;

            //bc1311			iArgFrame=aiStack[(iValFrame+1)%STACKSIZE];
            //bc1311			/* not able to understand */
            //bc1311			return((((iArgFrame&0xc000)^0x4000) == 0)?(iArgFrame&0x07ff):iValFrame); /*?????????*/
            for (iArgFrame = iValFrame; ((arrLevels[currentLevelIndex].aiStack[(iArgFrame + 1) % STACKSIZE] & 0xc000) ^ 0x4000) == 0; iArgFrame = arrLevels[currentLevelIndex].aiStack[((iArgFrame & 0x3fff) + 1) % STACKSIZE])
            {
                //bc1280 start
                if (arrLevels[currentLevelIndex].sStackTrashed && arrLevels[currentLevelIndex].iTrashedSP > arrLevels[currentLevelIndex].iSP && arrLevels[currentLevelIndex].iTrashedSP < (iArgFrame & 0x3fff))
                {
                    DispMessage("Program too complex (stack overflow)");
                    InternalError(-1);
                }
            }

            iArgFrame &= 0x3fff;

            if (arrLevels[currentLevelIndex].sStackTrashed && arrLevels[currentLevelIndex].iTrashedSP > arrLevels[currentLevelIndex].iSP && arrLevels[currentLevelIndex].iTrashedSP < (iArgFrame))
            {
                DispMessage("Program too complex (stack overflow)");
                InternalError(-1);
            }
            //bc1280 end
            //			if (arrLevels[currentLevelIndex].sStackTrashed && iTrashedSP > iSP && iTrashedSP < iArgFrame) 
            //			{
            //				DispMessage("Program too complex (stack overflow)");
            //				InternalError(-1);
            //			}
            return (iArgFrame);

        }


        /// <summary>
        /// skips the current execution pointer to end of argument.
        /// </summary>
        /// <param name="piPC">current execution point</param>
        private void PSkipToArgEnd(ref int piPC)
        {
            int iParenLevel;

            iParenLevel = 0;
            while (iParenLevel != 0 || (arrLevels[currentLevelIndex].pcProg[piPC] != ',' && arrLevels[currentLevelIndex].pcProg[piPC] != ')'))
            {
                if (piPC == arrLevels[currentLevelIndex].iProgLen - 1)
                    break;
                switch (arrLevels[currentLevelIndex].pcProg[(piPC)++])
                {
                    case '(':
                        iParenLevel++;
                        break;
                    case ')':
                        iParenLevel--;
                        break;
                    default:
                        break;
                }
            }
        }


        /// <summary>
        /// skips the current execution pointer to end of argument.
        /// </summary>
        /// <param name="piPC">current execution point</param>
        private void CSkipToArgEnd(ref int piPC)
        {
            int iParenLevel;
            char c;

            iParenLevel = 0;
            for (c = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + (piPC)++];
                iParenLevel != 0 || (c != ',' && c != ')');
                c = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + (piPC)++])
            {
                if (arrLevels[currentLevelIndex].tCurLine.iFirstCmd + (piPC) == arrLevels[currentLevelIndex].iProgLen - 1)
                    break;
                switch (c)
                {
                    case '(':
                        iParenLevel++;
                        break;
                    case ')':
                        iParenLevel--;
                        break;
                    default:
                        break;
                }
            }
            (piPC)--;
        }


        /// <summary>
        /// evaluates the arguments and replaces it with it's values.
        /// </summary>
        /// <param name="psAllPos"></param>
        /// <param name="piPC"></param>
        /// <returns>returns the value of argument</returns>
        private int EvalArg(ref short psAllPos, ref int piPC)
        {
            int iTemp;
            char c;

            c = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + piPC];
            if (c == ',' || c == ')')
                return ((arrLevels[currentLevelIndex].tCurLine.iLineNum << 7) + (piPC & 0x007f));
            else if (c == '-' || c == '0' || c == '*')
            {
                CSkipToArgEnd(ref piPC);
                psAllPos = FALSE;
                return (0);
            }
            else if (Char.IsDigit(c))
            {
                iTemp = c - '0';
                for (c = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + (++(piPC))];
                    Char.IsDigit(c);
                    c = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + (++(piPC))])
                    iTemp = 10 * iTemp + (c - '0');
                return (-iTemp);
            }
            else
            {
                iTemp = (arrLevels[currentLevelIndex].tCurLine.iLineNum << 7) + (piPC & 0x007f);
                CSkipToArgEnd(ref piPC);
                return (iTemp);
            }
        }


        bool displayEdTraceOnce = true;
        /// <summary>
        /// this is the main execution function which takes care of 
        /// interpreting program.
        /// </summary>
        private void Interpreter()
        {
            //			if(!progClosing)
            //			{
            int iFirstChar, iLastChar, i, iLine, iVal, iArgFrame;
            char cOp;
            short sNewLine = 0;
            short sAllPos, sStop;
            if (displayEdTraceOnce)
            {
                displayEdTraceOnce = false;
                //iStartIndexLT = iEndIndexLT = iFrameLT = 0;
                if (traceOn)
                    EditorTrace(0);
            }

            // evaluates current line and sets the value to memebers of tCurLine structure
            //////////* now program error may be here. *//////////
            ///
            if ((arrLevels[currentLevelIndex].tHState.Flags & HFNWLIN) > 0)
            {     //tHState defined structure HFWLIN is defined in hvars.h

                //if(!progClosing)
                EvalCurLine(arrLevels[currentLevelIndex].tHState.curLine); /* this contains 0 if code is correct else -1 this is set in CheckSyntax(), this case
				it will be 0. */
                if (traceOn)
                    getTextForLTFrame();

                if (arrLevels[currentLevelIndex].tHState.PC >= arrLevels[currentLevelIndex].tCurLine.iLength)
                {

                    if (isInternalErrorLogged)
                    {
                        sbErrorLog.Append("\n Internal Error 20 raised in Interpreter()");
                    }
                    InternalError(20);
                }
            }


            // set the value of sStop
            sStop = FALSE;           // local variable (short data type)

            // Probably to change the frame size, frame number and changing rectangle and process characters of particular line
            // Transfer no. of byte used etc
            for (cOp = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + arrLevels[currentLevelIndex].tHState.PC];  // acCurrentLine array of type char of size MAXLINE
                (cOp == '\0' || cOp == CR || cOp == ',' || cOp == ')') && !(sStop > 0); // check the condition depend on the syntax of code
                cOp = arrLevels[currentLevelIndex].acCurrentLine[arrLevels[currentLevelIndex].tCurLine.iFirstCmd + arrLevels[currentLevelIndex].tHState.PC])
            { // get the next character of line

                if (ValidFrame(arrLevels[currentLevelIndex].iSP))
                {
                    if ((arrLevels[currentLevelIndex].tHState.curLine = (arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] & 0x0780) >> 7) >= arrLevels[currentLevelIndex].iNumLines)  // iNumLines is integer variable define
                    {
                        //in vars.h..... aiStack[]-> data type int, defined in hvars.h of size 1024
                        if (isInternalErrorLogged)
                        {
                            sbErrorLog.Append("\n Internal Error 22 raised in Interpreter()");
                        }
                        InternalError(22);
                    }
                    arrLevels[currentLevelIndex].tHState.PC = arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] & 0x007f; // tHState structure

                    arrLevels[currentLevelIndex].iSP = PopFrame(); //PopFrame-> Method define hint.h.. I guess that its for iterating through frames
                    // frmaes--> either its layers of different level or frames or grid points

                    arrLevels[currentLevelIndex].tHState.Flags |= HFNWLIN;

                    EvalCurLine(arrLevels[currentLevelIndex].tHState.curLine);
                    if (traceOn)
                        getTextForLTFrame();
                    if ((arrLevels[currentLevelIndex].tCurLine.iFirstCmd + arrLevels[currentLevelIndex].tHState.PC) >= arrLevels[currentLevelIndex].tCurLine.iLength)
                    {

                        if (isInternalErrorLogged)
                        {
                            sbErrorLog.Append("\n Internal Error 24 raised in Interpreter()");
                        }
                        InternalError(24);
                    }
                }
                else
                {
                    sStop = TRUE;
                    if (!arrLevels[currentLevelIndex].sStackTrashed)
                    {
                        //vijay
                        killThreadNoWait();
                        //progClosing = true;
                        lock (arrLevels[currentLevelIndex].EndofProg)
                        {
                            arrLevels[currentLevelIndex].EndofProg = true;
                        }
                        //displayBox = false; commented by karthikeyan 16/03
                        TraceWidth = 0;
                        //curLevel[currentLevelId].chkLevelFinished(currentLevelId);
# if(CONTEST)
                        if (currentLevelIndex > 0)
                            lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                        else
                            lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + currentLevelIndex.ToString();
#endif
#if(DESIGNER)
						if(currentLevelIndex > 0)
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
						else
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
# if(CONTEST)
                        lblTotalScore.Text = Level.totalScore.ToString() + "/" + iSumOfAllLevelPoints.ToString();
#endif
                        lblLineTracing.Text = "";
                        TraceX = 0;
                        TraceWidth = 0;
                        //By:Rajesh
                        //Date:8/8/06
                        //To resolve issue: 3514
                        //if(traceOn)
                        displayTrace();
                        //Debug(herbtSpeed.ToString());
                        DispMessage("End of program reached");

                        // Fix issue of Herbert stopping at 45 degrees.


                        EnableMenu();
                        mnuGoHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnGoState = false;
                        mnuStepHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnStepState = false;
                        mnuResumeHrtb.Enabled = false;
                        arrLevels[currentLevelIndex].blnResumeState = false;
                        mnuHaltHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnHaltState = false;
                        mnuResetHerbt.Enabled = true;
                        arrLevels[currentLevelIndex].blnResetState = true;
                        btGoPause.Enabled = false;
                        btStop.Enabled = true;
                        btStep.Enabled = false;

                        // commented by karthikeyan 25072005
                        //						if(arrLevels[currentLevelIndex].IsLevelFinished)
                        //							lblLevelSolved.Text = "(Solved!)";
                        //						else
                        //							lblLevelSolved.Text = "(Unsolved)";
                        lock (txtCodeEditor)
                        {
                            txtCodeEditor.Visible = true;
                        }
                        getImages();
                        RotateImages(arrLevels[currentLevelIndex].CurDir);
                        //lock(arrHrbtImage[stateArray[0]])
                        {
#if (INVOKER)

                            if (this.herbertPicBox.InvokeRequired)
                            {
                                try
                                {
                                    if (herbtSpeed == 0)
                                        //										lock(imgForPicBox)
                                        //										{
                                        imgForPicBox = arrHrbtImage[stateArray[0]];
                                    //										}
                                    else
                                        imgForPicBox = arrHrbtImage[stateArray[0]];
                                }
                                catch
                                { }
                                try
                                {
                                    t.Abort();
                                }
                                catch
                                { }
                                this.herbertPicBox.Invoke(mi);
                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];

#endif
                        }
                        //herbertPicBox.Invalidate();
                        //txtCodeEditor.Focus();
                    }
                    else
                    {
                        //vijay
                        killThreadNoWait();
                        //progClosing = true;
                        lock (arrLevels[currentLevelIndex].EndofProg)
                        {
                            arrLevels[currentLevelIndex].EndofProg = true;
                        }
                        //TraceWidth = 0;						
                        //curLevel[currentLevelId].chkLevelFinished(currentLevelId);
# if(CONTEST)
                        if (currentLevelIndex > 0)
                            lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                        else
                            lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + currentLevelIndex.ToString();
#endif
#if(DESIGNER)
						if(currentLevelIndex > 0)
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
						else
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
# if(CONTEST)
                        lblTotalScore.Text = Level.totalScore.ToString() + "/" + iSumOfAllLevelPoints.ToString();
#endif
                        lblLineTracing.Text = "";
                        TraceX = 0;
                        TraceWidth = 0;
                        //By:Rajesh
                        //Date:8/8/06
                        //To resolve issue: 3514
                        //if(traceOn)
                        displayTrace();
                        //Debug(herbtSpeed.ToString());
                        DispMessage("End of program reached");

                        EnableMenu();
                        mnuGoHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnGoState = false;
                        mnuStepHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnStepState = false;
                        mnuResumeHrtb.Enabled = false;
                        arrLevels[currentLevelIndex].blnResumeState = false;
                        mnuHaltHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnHaltState = false;
                        mnuResetHerbt.Enabled = true;
                        arrLevels[currentLevelIndex].blnResetState = true;
                        btGoPause.Enabled = false;
                        btStep.Enabled = false;
                        btStop.Enabled = true;
                        if (arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                            lblLevelSolved.Text = "(Solved!)";
                        else
                            lblLevelSolved.Text = "(Unsolved)";


                        // added by Nikhil Kardale on 07/01/2007 to fix issue id. 3230
                        if (lblLevelNo.Text == "0")
                            lblLevelSolved.Visible = false;
                        else
                            lblLevelSolved.Visible = true;


                        lock (txtCodeEditor)
                        {
                            txtCodeEditor.Visible = true;
                        }


                        getImages();
                        RotateImages(arrLevels[currentLevelIndex].CurDir);
                        //						lock(arrHrbtImage[stateArray[0]])
                        {
#if (INVOKER)

                            if (this.herbertPicBox.InvokeRequired && herbtSpeed != 0)
                            {
                                try
                                {
                                    if (herbtSpeed == 0)
                                    {
                                        Thread.Sleep(200);
                                        imgForPicBox = arrHrbtImage[stateArray[0]];
                                        Thread.Sleep(200);
                                    }
                                    else
                                        imgForPicBox = arrHrbtImage[stateArray[0]];
                                }
                                catch
                                {
                                }
                                Thread.Sleep(200);
                                try
                                {
                                    t.Abort();
                                }
                                catch
                                { }
                                this.herbertPicBox.Invoke(mi);
                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[stateArray[0]];

#endif
                        }
                        herbertPicBox.Invalidate();

                        //txtCodeEditor.Focus();
                    }
                }
            } /* end of for loop */

            // inbuilt function of MAC, set the current graphics port (basic or color) takes
            //parameter as pointer to structure

            //setport(&atWindows[PLAYWIN]);  // defined above

            //
            if (sTraceDisplayed > 0)
            { //sTraceDisplayed-> short data type defined in hvars.h
                //ToggleCurBox(); //functon defined in hint.h
                if ((sStop > 0) || ((sNewLine = (short)(arrLevels[currentLevelIndex].tHState.Flags & HFNWLIN))) > 0)
                {
                    arrLevels[currentLevelIndex].tHState.Flags &= ~HFNWLIN;
                    //ToggleLineBox();  // funtion defined in hint.h
                    //eraserect(&tCurRect); // graphics function of Mac.. erases rectangle
                    // tCurRect is rect type define in hvars.h
                }
            }
            //Added by Vivek Balagangadharan
            // Description : Added the condition for checking levelindex. Levelindex 0 was giving exception.
            // Added On : 01-Aug-2005
            if (currentLevelIndex > 0)
            {
                if (sNewLine > 0 || arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tHState.curLine].cFunc == cOp)
                {
                    //reset Line tracing vairables.
                    if (traceOn)
                        getTextForLTFrame();
                    arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tHState.curLine].iStartIndexLT = arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tHState.curLine].iEndIndexLT = iStartIndexLT = iEndIndexLT = 0;
                    TraceX = 0;
                    //EditorTrace(tCurLine.iLineNum);
                }
            }
            //Probably change the line
            if (sTraceDisplayed != asOptions[2])
            {
                if (sTraceDisplayed > 0)
                {
                    if (!(sStop > 0 || sNewLine > 0))
                    {
                        int txtCENumLine = 0;
                        txtCENumLine = txtTotalLines;
                        for (int j = 1; j < txtCENumLine; j++)
                        {
                            if ((arrLevels[currentLevelIndex].atLineInfo[j].cFunc == cOp && arrLevels[currentLevelIndex].atLineInfo[j].sNumParms == 0) || cOp == 's' || cOp == 'r' || cOp == 'l' || cOp == '|')
                            {
                                TraceX = arrLevels[currentLevelIndex].tHState.PC + arrLevels[currentLevelIndex].tCurLine.iFirstCmd;
                                //TraceWidth = -3+charWidth(acCurrentLine,tHState.iPC  + tCurLine.iFirstCmd, (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font);
                                //TraceWidth = charWidth(acCurrentLine, 0, tHState.iPC  + tCurLine.iFirstCmd + (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font) - TraceX;
                                TraceWidth = 1;//Math.Abs(iLastChar - iFirstChar);
                                //By:Rajesh
                                //Date:8/8/06
                                //To resolve issue: 3514
                                //if(traceOn)
                                displayTrace();
                                arrLevels[currentLevelIndex].OneStepDone = false;
                            }
                        }
                        //ToggleLineBox();
                        //eraserect(&tCurRect);
                    }
                }
                else
                {
                    if (!((sStop > 0) || (sNewLine > 0)))
                    {
                        if (traceOn)
                            EditorTrace(arrLevels[currentLevelIndex].tCurLine.iLineNum); // function define in hint.h which take integer as parameter
                        //DrawCurrentLine();  // Did not get it in files
                    }
                }
            }
            for (int m = 0; m < arrLevels[currentLevelIndex].tCurLine.iLength - 1; m++)
            {
                if (m - 1 >= 0 && m + 1 < arrLevels[currentLevelIndex].tCurLine.iLength - 1)
                    if (arrLevels[currentLevelIndex].acCurrentLine[m - 1] == '(' && arrLevels[currentLevelIndex].acCurrentLine[m + 1] == ')' && arrLevels[currentLevelIndex].acCurrentLine[m] == '*')
                    {
                        DispMessage("Unable to evaluate parameter");
                        InternalError(-1);
                    }
            }
            if (cOp == '*')
            {
                DispMessage("");
            }
            // check for the syntax which have been converted in either 's', 'r', 'l' or '|'
            //and process it accordingly

            iFirstChar = iLastChar = arrLevels[currentLevelIndex].tHState.PC;

            if (!(sStop > 0))
            {
#if(DESIGNER)
				//Rajesh
				//To calculate no. of program steps.
				//Date 3/5/06

                arrLevels[currentLevelIndex].NumProgramSteps++;
                if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                    arrLevels[currentLevelIndex].NumProgramStepsPersistent = arrLevels[currentLevelIndex].NumProgramSteps;
#endif
                //if(!progClosing)
                switch (cOp)
                {
                    case '|':
                        //vijay
                        killThreadNoWait();
                        //progClosing = true;
                        arrLevels[currentLevelIndex].tHState.CurrentOp = cOp;
                        //displayBox = true;		commented by karthikeyan 16/03 
                        EnableMenu();
                        mnuHaltHrbt.Enabled = false;
                        arrLevels[currentLevelIndex].blnHaltState = false;
                        arrLevels[currentLevelIndex].goPauseState = 0;
                        btGoPause.Image = pbRun.Image;
                        this.hTooltip.SetToolTip(this.btGoPause, "Resume");
                        //hrbthalted = true; commented by karthikeyan 16/03
                        arrLevels[currentLevelIndex].tHState.PC++;
                        TraceX = arrLevels[currentLevelIndex].tHState.PC + arrLevels[currentLevelIndex].tCurLine.iFirstCmd;
                        TraceWidth = 1;
                        //By:Rajesh
                        //Date:8/8/06
                        //To resolve issue: 3514
                        //if(traceOn)
                        displayTrace();
                        break;
                    case 's':
                    case 'r':
                    case 'l':

                        arrLevels[currentLevelIndex].tHState.CurrentOp = cOp;

                        //displayBox = true;				commented by karthikeyan 16/03

                        TraceX = arrLevels[currentLevelIndex].tHState.PC + arrLevels[currentLevelIndex].tCurLine.iFirstCmd;

                        TraceWidth = 1;
                        //By:Rajesh
                        //Date:8/8/06
                        //To resolve issue: 3514
                        //if(traceOn)
                        displayTrace();
                        if ((cOp == 'r' || cOp == 'l'))
                            hrbtRedrawn = true;
                        //							StepCharRorL = cOp;
                        if (arrLevels[currentLevelIndex].stepByStep && (cOp == 'r' || cOp == 'l') && !arrLevels[currentLevelIndex].goClicked)
                        {
                            arrLevels[currentLevelIndex].StepCharRorL = cOp;
                            arrLevels[currentLevelIndex].blnRorLStep = true;
                        }
                        else
                        {
                            //blnRorLStep = false;
                            Command = cOp.ToString().ToUpper();
                        }
                        arrLevels[currentLevelIndex].tHState.PC++;
                        arrLevels[currentLevelIndex].OneStepDone = false;

                        break;
                    // to throw the errors depend on the other or default characters(other than r, s, l)
                    default:
                        arrLevels[currentLevelIndex].tHState.CurrentOp = 'i';

                        //
                        if (Char.IsLower(cOp))
                        {
                            //	displayBox = true; commented by karthikeyan 16/03

                            for (iLine = 1; iLine < arrLevels[currentLevelIndex].iNumLines && arrLevels[currentLevelIndex].atLineInfo[iLine].cFunc != cOp; iLine++) ;

                            if (iLine >= arrLevels[currentLevelIndex].iNumLines)
                            {
                                blnSystemError = true;
                                txtCodeEditor.Visible = true;
                                int iY = getActualLineNum(arrLevels[currentLevelIndex].tHState.curLine);
                                int charno = 0;
                                charno = arrLevels[currentLevelIndex].tHState.PC + txtLines[iY].IndexOf(":") + 2;
                                charno += getActualCharNum(iY);
                                DispMessage("No function definition found for '" + cOp.ToString() + "'");
                                selectError(charno + iY - 1, 1);
                                InternalError(-1);
                                //InternalError(26);
                            }
                            arrLevels[currentLevelIndex].iSP = PushFrame(1 + arrLevels[currentLevelIndex].atLineInfo[iLine].sNumParms);
#if(DESIGNER)
                            ///Rajesh
                            ///To set maxstacklength
                            ///Date 3/5/06
                            if (((STACKSIZE) - arrLevels[currentLevelIndex].iSP) > arrLevels[currentLevelIndex].MaxStackLength)
                            {
                                arrLevels[currentLevelIndex].MaxStackLength = (STACKSIZE) - arrLevels[currentLevelIndex].iSP;
                                if (!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
                                    arrLevels[currentLevelIndex].MaxStackLengthPersistent = arrLevels[currentLevelIndex].MaxStackLength;
                            }
                            ///end
#endif
                            iLastChar++;
                            sAllPos = TRUE;
                            if (arrLevels[currentLevelIndex].atLineInfo[iLine].sNumParms > 0)
                            {
                                iLastChar++;
                                for (i = 0; i < arrLevels[currentLevelIndex].atLineInfo[iLine].sNumParms; i++)
                                {
                                    arrLevels[currentLevelIndex].aiStack[(arrLevels[currentLevelIndex].iSP + 1 + i) % STACKSIZE] = EvalArg(ref sAllPos, ref iLastChar);
                                    iLastChar++;
                                }

                                //displayBox = true;				commented by karthikeyan 16/03
                                //TraceX = charWidth(acCurrentLine,0,tHState.iPC  + tCurLine.iFirstCmd,ExecLbl.Font);
                                TraceX = arrLevels[currentLevelIndex].tHState.PC + arrLevels[currentLevelIndex].tCurLine.iFirstCmd;
                                //TraceWidth = -3+charWidth(acCurrentLine,tHState.iPC  + tCurLine.iFirstCmd, (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font);
                                //TraceWidth = charWidth(acCurrentLine, 0, tHState.iPC  + tCurLine.iFirstCmd + (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font) - TraceX;
                                TraceWidth = Math.Abs(iLastChar - iFirstChar);
                                //								TraceX = 0;
                                //								for(int i2 = 0; i2 <= (tHState.iPC  + tCurLine.iFirstCmd); i2++)
                                //									TraceX += charWidth(acCurrentLine[i2],ExecLbl.Font);
                                //
                                //By:Rajesh
                                //Date:8/8/06
                                //To resolve issue: 3514
                                //if(traceOn)
                                displayTrace();
                                //checking if program is closed or end of program is reached
                                //then thread should not sleep.
                                //if(!progClosing && !EndofProg)
                                if (!(bool)arrLevels[currentLevelIndex].EndofProg && herbtSpeed != 0)
                                    Thread.Sleep(herbtSpeed);
                                arrLevels[currentLevelIndex].OneStepDone = false;
                            }



                            arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] = (arrLevels[currentLevelIndex].atLineInfo[iLine].sNumParms << 12)
                                | (arrLevels[currentLevelIndex].tHState.curLine << 7) | (iLastChar & 0x007f);
                            if ((sAllPos > 0))
                            {
                                arrLevels[currentLevelIndex].tHState.curLine = iLine;
                                arrLevels[currentLevelIndex].tHState.PC = 0;
                                arrLevels[currentLevelIndex].tHState.Flags |= HFNWLIN;
                            }
                            else
                            {
                                arrLevels[currentLevelIndex].iSP = PopFrame();
                                arrLevels[currentLevelIndex].tHState.PC = iLastChar;
                            }
                            iLastChar--;


                        }

                            // evaluates the character case. isupper returns true if character is Upper Case
                        else if (Char.IsUpper(cOp))
                        {

                            if (((iVal = GetVal(arrLevels[currentLevelIndex].tCurLine.iLineNum, cOp, arrLevels[currentLevelIndex].iSP)) & 0xf000) > 0)
                            {
                                blnSystemError = true;
                                txtCodeEditor.Visible = true;
                                int iY = getActualLineNum(arrLevels[currentLevelIndex].tHState.curLine);
                                int charno = 0;
                                charno = arrLevels[currentLevelIndex].tHState.PC + txtLines[iY].IndexOf(":") + 2;
                                charno += getActualCharNum(iY);
                                DispMessage("Recursive parameter definition");
                                selectError(charno + iY - 1, 1);
                                InternalError(-1);
                                //InternalError(28);
                            }
                            iArgFrame = CurrentArgFrame(arrLevels[currentLevelIndex].iSP);
                            iArgFrame = (int)(iArgFrame + 1 + (((uint)arrLevels[currentLevelIndex].aiStack[iArgFrame] & 0xf000) >> 12)) % STACKSIZE;
                            //bc1280 start added 2005-03-30
                            if (arrLevels[currentLevelIndex].sStackTrashed && arrLevels[currentLevelIndex].iTrashedSP > arrLevels[currentLevelIndex].iSP && arrLevels[currentLevelIndex].iTrashedSP < iArgFrame)
                            {
                                DispMessage("Program too complex (stack overflow)");
                                InternalError(-1);
                            }
                            //bc1280 end
                            //								//bc 2005-03-30
                            //								if (arrLevels[currentLevelIndex].sStackTrashed && iTrashedSP > iSP && iTrashedSP < iArgFrame) 
                            //								{
                            //									DispMessage("Program too complex (stack overflow)");
                            //									InternalError(-1);
                            //								}
                            arrLevels[currentLevelIndex].iSP = PushFrame(2);
                            arrLevels[currentLevelIndex].aiStack[(arrLevels[currentLevelIndex].iSP + 1) % STACKSIZE] = iArgFrame | 0x4000;
                            arrLevels[currentLevelIndex].aiStack[arrLevels[currentLevelIndex].iSP] = 0x1000 | (arrLevels[currentLevelIndex].tHState.curLine << 7) | ((arrLevels[currentLevelIndex].tHState.PC + 1) & 0x007f);
                            arrLevels[currentLevelIndex].tHState.curLine = (iVal >> 7) & 0x000f;
                            arrLevels[currentLevelIndex].tHState.PC = iVal & 0x007f;
                            arrLevels[currentLevelIndex].tHState.Flags |= HFNWLIN;
                        }
                        else
                        {
                            //for proper error messages.
                            int iActualLineNum = getActualLineNum(arrLevels[currentLevelIndex].tHState.curLine);
                            DispMessage("Invalid character");
                            selectError(getActualCharNum(iActualLineNum) + iActualLineNum, txtLines[iActualLineNum].Length);
                            InternalError(-1);
                            //InternalError(29);
                        }
                        break;
                }

                //				ExecLbl.Text = new string(acCurrentLine);
                //				displayBox = true;				
                //				TraceX = iFirstChar * 7 + tCurLine.iFirstCmd*7;
                //				TraceWidth = (Math.Abs(iLastChar - iFirstChar) +1)*7;
                //				//ExecLbl.Text = new string(acCurrentLine);



                // draw line depends on the option choosen
                if ((sTraceDisplayed = asOptions[1]) > 0)
                {
                    if (sNewLine > 0)
                    {
                        if (traceOn)
                            EditorTrace(arrLevels[currentLevelIndex].tCurLine.iLineNum);
                        //reset Line tracing vairables.
                        //iStartIndexLT = iEndIndexLT = 0;
                        //DrawCurrentLine();
                    }
                    //DrawCurBox(iFirstChar,iLastChar);
                }
                if (sNewLine > 0)
                {
                    //EditorTrace(tCurLine.iLineNum);
                    //reset Line tracing vairables.
                    //iStartIndexLT = iEndIndexLT = iFrameLT = 0;
                    //TraceX = 0;
                    //DrawCurrentLine();
                }
            }

                // If character is not interpreted correctly, It halts Herbie and set rect position
            else
            {
                //HaltHerbie(FALSE);
                arrLevels[currentLevelIndex].tHState.RunState = 'e';
                //EnableRunMenu(0x0010);			/*10000*/
                //setrect(&tCurBox,0,0,0,0);
                ///setrect(&tLineBox,0,0,0,0);
                //acCurrentLine[0]=0;
                //sTraceDisplayed=FALSE;
            }

            /*if(movechars == true)
                    Command = cOp.ToString().ToUpper();*/
            //Inbuilt function of MAC. Sets the size, pattern, and pattern mode of the graphics pen in the current graphics port
            //to their initial values.
            //pennormal();
            //hunlock((**ahtTERecs[PLAYWIN]).htext);
            //			}
        }


        /// <summary>
        /// gets the actual line number of the line in the structure tHState which is used in interperter.
        /// both line numbers are different.
        /// </summary>
        /// <param name="iVirtualLineNum">line of tHstate struct.</param>
        /// <returns>actual line number.</returns>
        private int getActualLineNum(int iVirtualLineNum)
        {
            //for proper error messages.
            int iY = 0;
            //get line number from top iY will contain line number.
            for (int k = 0; k < arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].iStart; k++)
            {
                if (arrLevels[currentLevelIndex].pcProg[k] == CR)
                    iY += 1;
            }
            return iY;
        }


        /// <summary>
        /// this returns the number of chars before the starting char of the an actual line in txt code editor.
        /// </summary>
        /// <param name="iActualLineNum">actual line number got from function getActualLineNum(int iVirtualLineNum)</param>
        /// <returns>num chars before any lines start point excluding '\n'</returns>
        private int getActualCharNum(int iActualLineNum)
        {
            //for proper error messages.
            int numChars = 0;
            //			lock(txtCodeEditor)
            //			{
            for (int k = 0; k < iActualLineNum; k++)
            {
                numChars += txtLines[k].Length;
            }
            //			}
            return numChars;
        }


        private void selectErrorMethod()
        {
            int curindex = 0;
            try
            {
                if (txtCodeEditor.Text.IndexOf("[") == -1 && txtCodeEditor.Text.IndexOf("]") == -1)
                {
                    errorShown = true;
                    //string str = txtCodeEditor.Text.Replace("\n","\r\n");
                    string str = txtCodeEditor.Text.Replace("\r", "");
                    char[] data = str.ToCharArray();
                    int count = iStartChar;

                    //					for(int i = 0; i <= count; i++)
                    //					{
                    //						
                    ////						if(((int)data[i]) == 13  || ((int)data[i]) == 10 )
                    //							
                    //						if((int)data[i] == 10 )
                    //							iStartChar++;
                    //					}


                    str = str.Insert(iStartChar, "[");
                    str = str.Insert(iStartChar + iSelectionLength + 1, "]");
                    txtCodeEditor.Text = str.Replace("\n", "\r\n");
                    str = null;
                }
                DisableMenu();
                mnuResetHerbt.Enabled = true;
                arrLevels[currentLevelIndex].blnResetState = true;
                btStop.Enabled = true;
            }
            catch
            {
                txtCodeEditor.SelectionStart = curindex;
                txtCodeEditor.SelectionLength = 0;
                errorShown = true;
            }
        }


        private int iStartChar, iSelectionLength;

        /// <summary>
        /// select the line which is having error.
        /// </summary>
        /// <param name="iStartChar">startindex of the startign char of the line which is having
        /// error + number of lines before that line. Or the starting index of the char which is the error
        /// char + number of lines before the line which is containing the erroronus code.</param>
        /// <param name="iEndChar">selection length.</param>
        private void selectError(int ipStartChar, int ipSelectionLength)
        {
            int curindex = 0;
            this.iStartChar = ipStartChar; this.iSelectionLength = ipSelectionLength;
            try
            {
                MethodInvoker mis = new MethodInvoker(selectErrorMethod);
                this.Invoke(mis, null);
                //				if(txtCodeEditor.Text.IndexOf("[") == -1 && txtCodeEditor.Text.IndexOf("]") == -1)
                //				{
                //					errorShown = true;
                //					string str = txtCodeEditor.Text;
                //					str = str.Insert(iStartChar, "[");
                //					str = str.Insert(iStartChar+iSelectionLength+1,"]");
                //					txtCodeEditor.Text = str;
                //					str = null;
                //				}
                //				DisableMenu();
                //				//mnuHaltHrbt.Enabled = true;
                //				mnuResetHerbt.Enabled = true;
                //				blnResetState = true;
                //				curindex = txtCodeEditor.SelectionStart;
                //				Font f = new Font("Verdana",8,FontStyle.Underline|FontStyle.Bold);
                //				txtCodeEditor.Visible = true;
                //				txtCodeEditor.SelectionStart = iStartChar;
                //				txtCodeEditor.SelectionLength = iSelectionLength;
                //				txtCodeEditor.SelectionColor = Color.Red;
                //				txtCodeEditor.SelectionFont = f;
                //				txtCodeEditor.Select();
                //				txtCodeEditor.SelectionStart = curindex;
                //				txtCodeEditor.SelectionLength = 0;
                //				errorShown = true;
            }
            catch
            {
                txtCodeEditor.SelectionStart = curindex;
                txtCodeEditor.SelectionLength = 0;
                errorShown = true;
            }

        }


        private void deSelectErrorMethod()
        {
            if (errorShown)
            {
                errorShown = false;
                string str = txtCodeEditor.Text;
                str = str.Replace("[", "");
                str = str.Replace("]", "");
                txtCodeEditor.Text = str;
                DispMessage("");
            }
        }


        private void deSelectError()
        {
            if (errorShown)
            {
                try
                {
                    MethodInvoker mis = new MethodInvoker(deSelectErrorMethod);
                    this.Invoke(mis, null);
                }
                catch
                {
                }
            }
        }


        //		private void deSelectError2()
        //		{
        //			if(errorShown)
        //			{
        //				txtCodeEditor.Font = new Font("Verdana", 8, FontStyle.Bold);
        //				txtCodeEditor.ForeColor = Color.Black;
        //				string pText = txtCodeEditor.Text;
        //				txtCodeEditor.ClearUndo();
        //				txtCodeEditor.Clear();
        //				int curindex = txtCodeEditor.SelectionStart;
        //				txtCodeEditor.Text = pText;
        //				txtCodeEditor.SelectionStart = curindex;
        //				errorShown = false;
        //			}	
        //		}

        /// <summary>
        /// displays the internal error message.
        /// </summary>
        /// <param name="a">error number.</param>
        private void InternalError(int a)
        {
            //vinay 04/01/2005
            killThreadNoWait();
            if (a != -1)
            {
                DispMessage("Internal Error " + a.ToString());
            }
            DisableMenu();
            mnuHaltHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnHaltState = false;
            mnuResetHerbt.Enabled = true;
            arrLevels[currentLevelIndex].blnResetState = true;
            btStop.Enabled = true;
            blnSystemError = true;
            arrLevels[currentLevelIndex].SyntaxError = true;
            arrLevels[currentLevelIndex].stepByStep = false;
            if ((isUserErrorLogged && a == -1) || (isInternalErrorLogged && a != -1))
            {
                try
                {
                    sbErrorLog.Append("\n ===================== Herbert Internal Error ===============================");
                    sbErrorLog.Append("\n Contestant Id: " + GlobalData.ContestantId.ToString());
                    sbErrorLog.Append("\n Internal Error: " + a.ToString());
                    sbErrorLog.Append("\n Current Level: " + currentLevelIndex.ToString());
                    sbErrorLog.Append("\n Current Program: " + arrLevels[currentLevelIndex].iCurrentProgram);
                    sbErrorLog.Append("\n Interpreter Values: ");
                    sbErrorLog.Append("\n Current Line(tHState.curLine): " + arrLevels[currentLevelIndex].tHState.curLine.ToString());
                    sbErrorLog.Append("\n Current Operator(tHState.CurrentOp): " + arrLevels[currentLevelIndex].tHState.CurrentOp.ToString());
                    sbErrorLog.Append("\n Run State(tHState.RunState): " + arrLevels[currentLevelIndex].tHState.RunState.ToString());
                    sbErrorLog.Append("\n Program Counter(tHState.PC): " + arrLevels[currentLevelIndex].tHState.PC.ToString());
                    sbErrorLog.Append("\n Flag Status(tHState.Flags): " + arrLevels[currentLevelIndex].tHState.Flags.ToString());
                    sbErrorLog.Append("\n Current Stack Pointer(iSP): " + arrLevels[currentLevelIndex].iSP.ToString());
                    sbErrorLog.Append("\n Stack Values: ");
                    int startStackIndex = 0, endStackIndex = 16384;
                    if (arrLevels[currentLevelIndex].iSP > 32)
                    {
                        startStackIndex = arrLevels[currentLevelIndex].iSP - 32;
                    }
                    if (arrLevels[currentLevelIndex].iSP < 16351)
                    {
                        endStackIndex = arrLevels[currentLevelIndex].iSP + 32;
                    }
                    for (int i = startStackIndex; i < endStackIndex; i++)
                    {
                        sbErrorLog.Append("\n aiStack[" + i.ToString() + "]: " + arrLevels[currentLevelIndex].aiStack[i].ToString());
                    }
                    sbErrorLog.Append("\n =============================================================================");
                    LogErrors();
                }
                catch
                {
                }
            }

        }


        /// <summary>
        /// calculates the value of parameter in function defination.
        /// </summary>
        /// <param name="iLine">line number of function defination</param>
        /// <param name="piS">start point of the function.</param>
        /// <param name="piD">end point of the fucntion.</param>
        /// <param name="cSep1">char to be ignored</param>
        /// <param name="cSep2">char to be ignored</param>
        private void TransferNumber(int iLine, ref int piS, ref int piD, char cSep1, char cSep2)
        {
            //			if(!progClosing)
            //			{
            char cBinOp, c;
            int iResult, iTemp;
            short sValid;

            cBinOp = '+';
            iResult = 0;
            /* true if code doesnot contains any errors */
            sValid = TRUE;
            /* if code is valid AND next char is not one of cSep1 AND cSep2 and current pointer is not more than program length */
            for (c = arrLevels[currentLevelIndex].pcProg[piS]; (sValid > 0) && c != cSep1 && c != cSep2 && piS < arrLevels[currentLevelIndex].iProgLen; c = arrLevels[currentLevelIndex].pcProg[piS])
            {
                if (c == '-' || c == '+')
                {
                    cBinOp = c; /* Binary Operator type */
                    (piS)++;
                }
                /*if argument is a number */
                else if (Char.IsDigit(c))
                {
                    /* c-'0' is integer value of char in c */
                    for (iTemp = c - '0', (piS)++; Char.IsDigit(arrLevels[currentLevelIndex].pcProg[piS]); (piS)++)
                        /* if number is > 9 get all digits */
                        iTemp = 10 * iTemp + (arrLevels[currentLevelIndex].pcProg[piS] - '0');
                    /* if + than make number positive otherwise negative */
                    iResult += ((cBinOp == '+') ? iTemp : -iTemp);
                    //bc /* added brian 2005-03-30 */
                    if (iResult > MAXNUM || iResult < MINNUM)
                    {
                        //begin added by piyush on 31 Mar 2005
                        DispMessage("Number " + iResult + " is out of range of valid values.");
                        sValid = FALSE;
                        InternalError(-1);
                        //end added by piyush on 31 Mar 2005
                    }
                    /*char[] chariResult = iResult.ToString().ToCharArray();
                        for(int i = 0; i < chariResult.Length; i++)
                            acCurrentLine[piD++] = chariResult[i];*/
                }
                /* if argument is a lower case letter than set error */
                else if (Char.IsLower(c))
                    sValid = FALSE;
                /* if Argument is a upper char.*/
                else if (Char.IsUpper(c))
                {
                    if ((iTemp = GetVal(iLine, c, arrLevels[currentLevelIndex].iSP)) > 0)
                        sValid = FALSE;
                    else
                    {
                        //iResult = 0;
                        iResult += ((cBinOp == '+') ? -iTemp : iTemp);
                        (piS)++;
                        //bc /* added brian 2005-03-30 */
                        if (iResult > MAXNUM || iResult < MINNUM)
                        {
                            //begin added by piyush on 31 Mar 2005
                            DispMessage("Number " + iResult + " is out of range of valid values.");
                            sValid = FALSE;
                            InternalError(-1);
                            //end added by piyush on 31 Mar 2005
                        }
                    }
                }
                else
                    sValid = FALSE;
                /*if(piS == iProgLen)
                    {
                        piS--;
                        break;
                    }*/
            }
            if ((sValid > 0))
            {
                char[] chariResult = iResult.ToString().ToCharArray();
                for (int i = 0; i < chariResult.Length; i++)
                    arrLevels[currentLevelIndex].acCurrentLine[piD++] = chariResult[i];
                //piD+=sprintf(&acCurrentLine[piD],"%d",iResult); //sprintf always returns 0! */
                //sprintf(&acCurrentLine[piD],"%d",iResult);
                //while (acCurrentLine[++(piD)].CompareTo('\0') == 0) /* navigate to end of line*/
                ;
            }
            else
            {
                arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = '*'; /* add error char at the end of execution line.*/
                PSkipToArgEnd(ref piS); /* skips to char ')'*/
            }
            //}
        }


        /// <summary>
        /// replaces the fucntion call by function defination in currently
        /// executing line.
        /// </summary>
        /// <param name="iLine">ine number of function defination</param>
        /// <param name="piS">start point of the function</param>
        /// <param name="piD">end point of the fucntion</param>
        /// <param name="cSep1">char to be ignored</param>
        /// <param name="cSep2">char to be ignored</param>
        private void TransferFunc(int iLine, ref int piS, ref int piD, char cSep1, char cSep2)
        {
            //			if(!progClosing)
            //			{
            short sValid;
            int iOrigD;
            char c;

            /* true if code doesnot contains any errors */
            sValid = TRUE;
            iOrigD = piD;
            /* if code is valid AND next char is not one of cSep1 AND cSep2 and current pointer is not more than program length */
            for (c = arrLevels[currentLevelIndex].pcProg[piS]; (sValid > 0) && c != cSep1 && c != cSep2 && piS < arrLevels[currentLevelIndex].iProgLen; c = arrLevels[currentLevelIndex].pcProg[piS])
            {

                if (Char.IsLower(c) || c == '|')
                {
                    arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = arrLevels[currentLevelIndex].pcProg[(piS)++];
                }
                else if (Char.IsUpper(c))
                {/* Upper case means it's a parameter */
                    if (GetVal(iLine, c, arrLevels[currentLevelIndex].iSP) > 0)
                    { /* returns the parameter value */
                        arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = c;
                        (piS)++;
                    }
                    else
                        sValid = FALSE; /* argument value is not valid */
                }
                else if (c == '(')
                { /* if opening braces */
                    arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = '(';
                    (piS)++;
                    /* add value of all arguments to the execution line. */
                    do
                    {
                        if (piS < arrLevels[currentLevelIndex].iProgLen)
                        {
                            TransferArg(iLine, ref piS, ref piD, ',', ')');
                            arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = arrLevels[currentLevelIndex].pcProg[(piS)++];
                        }
                    } while (arrLevels[currentLevelIndex].pcProg[(piS) - 1] != ')' && piS != arrLevels[currentLevelIndex].iProgLen); /* till closing braces */
                }
                else /* if not opening '(' set code is invalid */
                    sValid = FALSE;
                if (piS == arrLevels[currentLevelIndex].iProgLen)
                {
                    piS--;
                    break;
                }
            }
            if (!(sValid > 0))
            {
                arrLevels[currentLevelIndex].acCurrentLine[(piD) = iOrigD] = '*';
                (piD)++;
                PSkipToArgEnd(ref piS); /* if code is not valid move and a * is inserted to the execution line then skip to end of arg list */
            }
            //}
        }


        /// <summary>
        /// replaces the fucntion call by function defination in currently
        /// executing line.
        /// </summary>
        /// <param name="iLine">ine number of function defination</param>
        /// <param name="piS">start point of the function</param>
        /// <param name="piD">end point of the fucntion</param>
        /// <param name="cSep1">char to be ignored</param>
        /// <param name="cSep2">char to be ignored</param>
        private void TransferArg(int iLine, ref int piS, ref int piD, char cSep1, char cSep2)
        {
            //			if(!progClosing)
            //			{
            char c = ' ';
            if (piS < arrLevels[currentLevelIndex].iProgLen)
                c = arrLevels[currentLevelIndex].pcProg[piS];
            /* if char is one of the argument that we should ignore than return*/
            if (c == cSep1 || c == cSep2 || piS >= arrLevels[currentLevelIndex].iProgLen)
                return;
            /* if char is - or + than transfer that number ignoring the cSep1, cSep2 chars */
            if (c == '-' || c == '+' || Char.IsDigit(c))
                TransferNumber(iLine, ref piS, ref piD, cSep1, cSep2);
            /* function call in another function eg. a(A):sf(A) */
            else if (Char.IsLower(c) || c == '|')
                TransferFunc(iLine, ref piS, ref piD, cSep1, cSep2);
            /* if uppercase letter than replace it with value*/
            else if (Char.IsUpper(c))
                if (GetVal(iLine, c, arrLevels[currentLevelIndex].iSP) < 0)
                    TransferNumber(iLine, ref piS, ref piD, cSep1, cSep2);
                else
                    TransferFunc(iLine, ref piS, ref piD, cSep1, cSep2);
            else
            {
                arrLevels[currentLevelIndex].acCurrentLine[(piD)++] = '*';
                PSkipToArgEnd(ref piS); /* if code is not valid move and a * is inserted to the execution line then skip to end of arg list */
            }
            //}
        }


        /// <summary>
        /// evaluate the current line of code.
        /// </summary>
        /// <param name="iLine">line number of currently executing line.</param>
        private void EvalCurLine(int iLine)/*assumes pcprog set up*/
        {
            //			if(!progClosing)
            //			{
            int iS, iD;

            iD = 0; /* temp program line number*/
            iS = arrLevels[currentLevelIndex].atLineInfo[iLine].iStart; /* this is the start point for this function in hole code. */
            arrLevels[currentLevelIndex].tCurLine.iFirstCmd = 0;
            TransferFunc(iLine, ref iS, ref iD, ':', CR); // transfer function by it's defination. CR is constant and it's value is '\n'*/
            if (arrLevels[currentLevelIndex].pcProg[iS] == ':' && iS < arrLevels[currentLevelIndex].iProgLen)
            { /* see if the next program char is ':' and current counter is not more than program lenght*/
                arrLevels[currentLevelIndex].acCurrentLine[iD++] = ':'; /* add current char to execution line. */
                arrLevels[currentLevelIndex].tCurLine.iFirstCmd = iD;   /* set the next execution point */
                iS++;					/* increase the program counter */
                TransferFunc(iLine, ref iS, ref iD, CR, CR); /* call this function with skip able char both as '\n' */
            }
            arrLevels[currentLevelIndex].acCurrentLine[iD] = '\0';
            arrLevels[currentLevelIndex].tCurLine.iLineNum = iLine;
            arrLevels[currentLevelIndex].tCurLine.iLength = iD + 1;
            //EditorTrace(tCurLine.iLineNum);
            if (arrLevels[currentLevelIndex].tHState.curLine == 0)
            {
                arrLevels[currentLevelIndex].OneStepDone = false;
                //displayBox = true;		commented by karthikeyan 16/03
                //TraceX = charWidth(acCurrentLine,0,tHState.iPC  + tCurLine.iFirstCmd,ExecLbl.Font);
                TraceX = arrLevels[currentLevelIndex].tHState.PC + arrLevels[currentLevelIndex].tCurLine.iFirstCmd;
                //				TraceX = 0;
                //				for(int i = 0; i <= (tHState.iPC  + tCurLine.iFirstCmd); i++)
                //					TraceX += charWidth(acCurrentLine[i],ExecLbl.Font);
                //TraceWidth = charWidth(acCurrentLine,0,tHState.iPC  + tCurLine.iFirstCmd + 1,ExecLbl.Font) - TraceX;
                //TraceWidth = 1;
                //TraceWidth = -3+charWidth(acCurrentLine[tHState.iPC  + tCurLine.iFirstCmd],ExecLbl.Font);// (Math.Abs(iLastChar - iFirstChar) +1)*7;
                //iStartIndexLT = iEndIndexLT = iFrameLT = 0;
                //TraceX = 0;
                int txtCENumLine = 0;
                //				lock(txtCodeEditor)
                //				{
                txtCENumLine = txtTotalLines;
                //				}
                for (int j = 1; j < txtCENumLine; j++)
                {
                    if ((arrLevels[currentLevelIndex].atLineInfo[j].cFunc == arrLevels[currentLevelIndex].pcProg[TraceX] && arrLevels[currentLevelIndex].atLineInfo[j].sNumParms == 0))
                    {
                        //TraceX =  tHState.iPC  + tCurLine.iFirstCmd;
                        //TraceWidth = -3+charWidth(acCurrentLine,tHState.iPC  + tCurLine.iFirstCmd, (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font);							
                        //TraceWidth = charWidth(acCurrentLine, 0, tHState.iPC  + tCurLine.iFirstCmd + (Math.Abs(iLastChar - iFirstChar)),ExecLbl.Font) - TraceX;							
                        TraceWidth = 1;//Math.Abs(iLastChar - iFirstChar);
                        if (traceOn)
                        {
                            getTextForLTFrame();
                            displayTrace();
                        }
                        break;
                        //OneStepDone = false;
                    }
                }
                //displayTrace();
#if (EXCEPTION)
                try
                {
#endif
                    int delay = 0;
                    bool closed = false;

                    if (hrbtRedrawn && herbtSpeed > 10)
                    {
                        // set hrbtRedrawn to false so that currently executing 
                        //thread can't change the location of herbert picture box.
                        hrbtRedrawn = false;
                        while (delay < herbtSpeed)
                        {
                            if (!closed)
                            //lock(this.herbertPicBox)
                            {
#if (OLDCODE)
					this.herbertPicBox.Image = imgEyeClose;
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}

#endif
                                //lock(imgEyeClose)
                                {
#if (INVOKER)
                                    //this.herbertPicBox.Image = imgEyeClose;	
                                    if (this.herbertPicBox.InvokeRequired)
                                    {
                                        if (herbtSpeed == 0)
                                            lock (imgForPicBox)
                                            {
                                                imgForPicBox = imgEyeClose;
                                            }
                                        else
                                            imgForPicBox = imgEyeClose;
                                        this.herbertPicBox.Invoke(mi);
                                        ////Console.WriteLine("if block : invoker for closed");
                                    }
                                    else
                                    {
#endif
                                        ////Console.WriteLine("else block : closed");
                                        this.herbertPicBox.Image = imgEyeClose;
                                        herbertPicBox.Invalidate();
#if (INVOKER)
                                    }

                                    //this.herbertPicBox.Image = imgEyeClose;

#endif
                                }
                                //herbertPicBox.Invalidate();
                                //Application.DoEvents();
#endif
                            }
                            else
                            //lock(this.herbertPicBox)
                            {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                                //lock(arrHrbtImage[0])
                                {
#if (INVOKER)
                                    //this.herbertPicBox.Image = arrHrbtImage[0];	
                                    if (this.herbertPicBox.InvokeRequired)
                                    {
                                        if (herbtSpeed == 0)
                                            lock (imgForPicBox)
                                            {
                                                imgForPicBox = arrHrbtImage[0];
                                            }
                                        else
                                            imgForPicBox = arrHrbtImage[0];
                                        this.herbertPicBox.Invoke(mi);
                                        ////Console.WriteLine("if block : invoker for open");
                                    }
                                    else
                                    {
#endif
                                        ////Console.WriteLine("else block : open");
                                        this.herbertPicBox.Image = arrHrbtImage[0];
                                        herbertPicBox.Invalidate();
#if (INVOKER)
                                    }

                                    //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                                }
                                //herbertPicBox.Invalidate();
                                //Application.DoEvents();
#endif
                            }
                            closed = !closed;
                            delay += herbtSpeed / 3 - 1;
                            if (herbtSpeed != 0)
                                Thread.Sleep(herbtSpeed / 3);
                        }
                    }
                    //lock(this.herbertPicBox)
                    {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                        //lock(arrHrbtImage[0])
                        {
#if (INVOKER)

                            if (this.herbertPicBox.InvokeRequired)
                            {
                                if (herbtSpeed == 0)
                                    lock (imgForPicBox)
                                    {
                                        imgForPicBox = arrHrbtImage[0];
                                    }
                                else
                                    imgForPicBox = arrHrbtImage[0];
                                this.herbertPicBox.Invoke(mi);
                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[0];
                                herbertPicBox.Invalidate();
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                        }
                        //herbertPicBox.Invalidate();
                        //Application.DoEvents();
#endif
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(e.Message + ", EvalCurLine, 11");
                }
#endif
            }
            //}
        }


        /// <summary>
        /// return the value of parameter.
        /// </summary>
        /// <param name="iLine">currently executing line</param>
        /// <param name="cParm">parameter whose value to be calculated.</param>
        /// <param name="iValFrame"></param>
        /// <returns></returns>
        private int GetVal(int iLine, char cParm, int iValFrame)
        {
            int i, iLineStart;

            iLineStart = arrLevels[currentLevelIndex].atLineInfo[iLine].iStart;
            /* increment is by 2 because we are skipping ',' char*/
            for (i = 2; Char.IsUpper(arrLevels[currentLevelIndex].pcProg[iLineStart + i]) && arrLevels[currentLevelIndex].pcProg[iLineStart + i] != cParm; i += 2)
                if (i == arrLevels[currentLevelIndex].iProgLen - 1)
                    break;
            /* if lower case parameter */
            if (!Char.IsUpper(arrLevels[currentLevelIndex].pcProg[iLineStart + i]))
            {
                if (isInternalErrorLogged)
                {
                    sbErrorLog.Append("\n Internal Error 25 raised in GetVal(" + iLine.ToString() + "," + cParm.ToString() + "," + iValFrame.ToString() + ")");
                }
                InternalError(25);
            }
            /*return the arguments from stack*/
            return (arrLevels[currentLevelIndex].aiStack[(CurrentArgFrame(iValFrame) + (i >> 1)) % STACKSIZE]); /* i >> 1 ==== devide i by 2*/
        }


        /// <summary>
        /// checks to see if herbert is hitting a wall.
        /// </summary>
        /// <returns>returns true if herbert is hitting a wall else false.</returns>
        private bool isWall()
        {
            bool wall = false;
            switch (arrLevels[currentLevelIndex].CurDir)
            {
                //4 and 12 used here are used on the basis of hit and trial.
                case 0:
                    wall = ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) <= 4 * GlobalData.ZoomInZoomOut ? true : false);
                    break;
                case 1:
                    wall = (-arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut - 12 * GlobalData.ZoomInZoomOut + BoardWidth <= 0 ? true : false);
                    break;
                case 2:
                    wall = (-arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut - 12 * GlobalData.ZoomInZoomOut + BoardHeight <= 0 ? true : false);
                    break;
                case 3:
                    wall = (arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut <= 4 * GlobalData.ZoomInZoomOut ? true : false);
                    break;
                default:
                    wall = false;
                    break;
            }
            return wall;
        }

        #endregion

        #region Design Menu Item Events and functions
#if(DESIGNER)

		private void txtLevelPoints_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
		{	
			
		/*	if(!txtLevelPoints.ReadOnly)
			{				
				if(!arrLevels[currentLevelIndex].IsLevelUpdate)
				{
					//Note This variable will be made true under function getLevelDataToUpdate(currentLevelId)
					//arrLevels[currentLevelId].IsLevelUpdate = true;
			
					arrLevels[currentLevelIndex].getLevelDataToUpdate(currentLevelId);
				}
				lvlPointTxt = txtLevelPoints.Text;
				if((e.KeyChar >=65 && e.KeyChar <=90) || (e.KeyChar >= 97 && e.KeyChar <=127))
				{				
					MessageBox.Show(this,"Only integer values are accepted as Level Points.","Designer-Error",MessageBoxButtons.OK,MessageBoxIcon.Warning);
					blnNotValidDesignerPoints = true;
				}
				else if((e.KeyChar < 48 || e.KeyChar >57) && (e.KeyChar != 8) && (e.KeyChar != 127)) 
				{
					//ASCII 48 - 57 : Digits 0 -9
					//ASCII 8 : Backspace Key
					//ASCII 127 : Delete key
					blnNotValidDesignerPoints = true;
				}
				else
				{				
					blnNotValidDesignerPoints = false;
				}
			}*/
			
		}

		private void txtLevelPoints_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
		{
			if(!txtLevelPoints.ReadOnly)
			{				
				if(!arrLevels[currentLevelIndex].IsLevelUpdate)
				{
					//Note This variable will be made true under function getLevelDataToUpdate(currentLevelId)
					//arrLevels[currentLevelId].IsLevelUpdate = true;
			
					arrLevels[currentLevelIndex].getLevelDataToUpdate(currentLevelId);
				}
				lvlPointTxt = txtLevelPoints.Text;
				//if (  ((Char)e.KeyCode)  >=65 && ((Char)e.KeyCode <=90) || ((Char)e.KeyCode >= 97) && ((Char)e.KeyCode <=127))
				if( (char.IsDigit((char)e.KeyCode)) 
					||(e.KeyCode >= Keys.NumPad0 && e.KeyCode <= Keys.NumPad9||e.KeyCode == Keys.Delete || e.KeyCode==Keys.Back))
				{	
					blnNotValidDesignerPoints = false;
					if(e.KeyCode == Keys.Delete)
					{
						
						txtLevelPoints.Text = "0";						
					}
				}
				else if(e.KeyCode==Keys.Alt|| e.KeyCode==Keys.ControlKey || e.KeyCode==Keys.Home||e.KeyCode==Keys.End||e.KeyCode==Keys.End||e.KeyCode==Keys.Left||e.KeyCode==Keys.Right||e.KeyCode==Keys.Insert || e.KeyCode==Keys.Enter)
				{
					blnNotValidDesignerPoints = false;

				}
					//				else if(((Char)e.KeyCode < 48 || (Char)e.KeyCode >57) && ((Char)e.KeyCode != 8) && ((Char)e.KeyCode != 127)) 
					//				{
					//					//ASCII 48 - 57 : Digits 0 -9
					//					//ASCII 8 : Backspace Key
					//					//ASCII 127 : Delete key
					//					if(e.KeyCode == Keys.Delete)
					//					{
					//						blnNotValidDesignerPoints = false;
					//						txtLevelPoints.ReadOnly = true;
					//						txtLevelPoints.Text = "0";						
					//						txtLevelPoints.ReadOnly = false;
					//					}
					//					else
					//					{
					//						blnNotValidDesignerPoints = true;
					//					}
					//				}
				else
				{
					blnNotValidDesignerPoints = true;
					MessageBox.Show(this,"Only integer values are accepted as Level Points.","Designer-Error",MessageBoxButtons.OK,MessageBoxIcon.Warning);
				
				}
			}
			
		}

		private void txtLevelPoints_TextChanged(object sender, EventArgs e)
		{
			if(!txtLevelPoints.ReadOnly)
			{
				if(!isLevelChanging)
				{
					arrLevels[currentLevelIndex].IsLevelChanged = true;
				}
				//arrLevels[currentLevelIndex].IsLevelUpdate = true;
				///Added by Rajesh
#if(DESIGNER)
				mnuSaveLevel.Enabled=true;
#endif
				///End
				if(blnNotValidDesignerPoints)
				{
					blnNotValidDesignerPoints = false;
					txtLevelPoints.Text = lvlPointTxt;
				}
				if(txtLevelPoints.Text.Trim() != "")
				{
					//Regular expression to check if the value in the textbox is integer or not
					///Changed by Rajesh
					///
					//Regex reg = new Regex(@"^[+]?[1-9]\d*$");
					Regex reg = new Regex("0*[1-9][0-9]*");  
					///end
                    try
                    {
                        Match mat = reg.Match(txtLevelPoints.Text);
                        if (mat.Success)
                        {
                            lvlpoints = int.Parse(txtLevelPoints.Text);
                            arrLevels[currentLevelIndex].IsLevelUpdate = true;
                        }
                        else
                        {
                            lvlpoints = 0;
                            arrLevels[currentLevelIndex].IsLevelUpdate = true;
                        }
                    }
                    catch
                    {

                    }
				}
				else
				{
					lvlpoints = 0;
					arrLevels[currentLevelIndex].IsLevelUpdate = true;
				}
				//			try
				//			{
				//				lvlpoints = int.Parse(txtLevelPoints.Text);
				//			}
				//			catch
				//			{	
				//				txtLevelPoints.Text = txtLevelPoints.Text.Remove(txtLevelPoints.Text.Length-1,1);
				////				lvlpoints = 0;
				//				lvlpoints = int.Parse(txtLevelPoints.Text);
				//			}

				try
				{
			
					Level.totalScore = 0;
					arrLevels[currentLevelIndex].levelScore = 0;
					arrLevels[currentLevelIndex].BestLevelScore = 0;
					GlobalData.DeginerLevelPoints = lvlpoints;
					Level.saveLevelPoints(currentLevelIndex, lvlpoints);
					lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();			
				}
				catch
				{
					GlobalData.DeginerLevelPoints = Level.getLevelPoints(currentLevelIndex);
					lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
				}
				try
				{					
					if(lvlpoints != Level.getLevelPoints(currentLevelIndex))
					{
						Level.totalScore -= arrLevels[currentLevelIndex].levelScore;
						arrLevels[currentLevelIndex].levelScore  = 0;
						if(currentLevelIndex > 0)
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + Level.getLevelPoints(currentLevelIndex).ToString();	
						else
							lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString()+"/" + lvlpoints.ToString();	
# if(CONTEST)
										lblTotalScore.Text = Level.totalScore.ToString();
#endif
					}			
				}
				catch
				{
					//				//Console.WriteLine(exp.Message + ", TxtLevelPoints_TextChanged, 11");
				}	
			}
		}


		/// <summary>
		/// this is the event which sets a bool variable to true
		/// which indicates that herbert's position can be changed 
		/// if we level is 0 and user is admin for the game.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void herbertPicBox_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
		{
			
			if(GlobalData.HerbertMode == HMode.Designer && mnuHerbie.Checked == true)
			{
				resetHrtbPos = true;
			}
			
		}
		

		/// <summary>
		/// clear menu.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void mnuClearAll_Click(object sender, System.EventArgs e)
		{
			System.Windows.Forms.DialogResult YesClear = MessageBox.Show(this,"Do you want to clear the design?","Herbert - Question",System.Windows.Forms.MessageBoxButtons.YesNo,System.Windows.Forms.MessageBoxIcon.Question);
			if(YesClear == System.Windows.Forms.DialogResult.Yes)
			{
				Level.LevelDesignData();
				txtCodeEditor.Text = "";
				txtLevelPoints.Text = "0";
				GlobalData.DeginerLevelPoints = 0;
				if(GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
					InitialOrResetHrbt = new Point(BoardWidth/2+(4-8)*GlobalData.ZoomInZoomOut+(GlobalData.ZoomInZoomOut-1),BoardHeight/2+(4-8)*GlobalData.ZoomInZoomOut+2*(GlobalData.ZoomInZoomOut-1));
				else
					InitialOrResetHrbt = new Point(BoardWidth/2+(4-8)*GlobalData.ZoomInZoomOut+(GlobalData.ZoomInZoomOut-1)-1,BoardHeight/2+(4-8)*GlobalData.ZoomInZoomOut+2*(GlobalData.ZoomInZoomOut-1)-2);
				arrLevels[currentLevelIndex].HerbertX = InitialOrResetHrbt.X/GlobalData.ZoomInZoomOut;
				arrLevels[currentLevelIndex].HerbertY = InitialOrResetHrbt.Y/GlobalData.ZoomInZoomOut;
				//resets the herbert's position variables like prePos$, destPos$ etc.
				arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X;
				arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y;

				//lock(this.herbertPicBox)
				{
					if(GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
						if(arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir ==3 || arrLevels[currentLevelIndex].CurDir ==2)
						{
							this.herbertPicBox.Location = new System.Drawing.Point((arrLevels[currentLevelIndex].curPosX-2*GlobalData.ZoomInZoomOut-1), (arrLevels[currentLevelIndex].curPosY-2*GlobalData.ZoomInZoomOut-1));
						}
						else
							this.herbertPicBox.Location = new System.Drawing.Point((arrLevels[currentLevelIndex].curPosX-2*GlobalData.ZoomInZoomOut-1), (arrLevels[currentLevelIndex].curPosY-2*GlobalData.ZoomInZoomOut-1+2));
					else
						herbertPicBox.Location = new System.Drawing.Point((arrLevels[currentLevelIndex].curPosX-2), (arrLevels[currentLevelIndex].curPosY-2));
				}
				Level.saveLevelPoints(currentLevelIndex, 0);
				arrLevels[currentLevelIndex].IsLevelFinished = false;
				arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;
				if(arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
					lblLevelSolved.Text = "(Solved!)";
				else
					lblLevelSolved.Text = "(Unsolved)";	
				arrLevels[currentLevelIndex].MaxChars = 0;
				lblMaxChars.Text = "(Max " + arrLevels[currentLevelIndex].getMaxChar(currentLevelId).ToString() +")";
				herbertPicBox.Refresh();
				arrLevels[currentLevelIndex].IsNewLevelDotsPopulated = false;
#if(PATTERN_GENERATER)
                if (GlobalData.iPatternId != "-1")
                {
                    arrLevels[currentLevelIndex].IsPatternEnabled = false;
                    this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                    btShowPattern.FlatStyle = FlatStyle.Standard;
                    // added by Nikhil Kardale on 20/03/2008 to resolve issue id. 10919
                    mnuShowPattern.Checked = false;
                    mnuShowPattern.Text = "Show Pattern";
                }
#endif
				arrLevels[currentLevelIndex].ClearLevel(currentLevelId);

				arrLevels[currentLevelIndex].IsLevelUpdate = true;
///Added by Rajesh
#if(DESIGNER)
				mnuSaveLevel.Enabled=true;
#endif
///End
				arrLevels[currentLevelIndex].IsClearAllChecked  = true;

				HerbertBoard.Refresh();
			}			
			
		}
		

		/// <summary>
		/// saves the level data designed at level 0.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void mnuSaveLevel_Click(object sender, System.EventArgs e)
		{
            DialogResult SaveMessageYesNo = MessageBox.Show(this,"Do you want to save this level?", "Herbert - Question", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
            if (SaveMessageYesNo == DialogResult.Yes)
            {
                try
                {
                    //for (int cnt = 0; cnt < arrLevels.Length; cnt++)
                    //{
                    //    arrLevels[cnt].getNonSavedDesignData(cnt);
                    //}
                    int levelPoints = Level.getLevelPoints(currentLevelIndex);
                    int currentLevelPoints;
                    if (txtLevelPoints.Text != "")
                        currentLevelPoints = int.Parse(txtLevelPoints.Text);
                    else
                        currentLevelPoints = -1;


                    if (currentLevelPoints <= 0)
                    {
                        MessageBox.Show(this, "Please check Level Points. Level Points can not be 0.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        return;
                    }
                    else
                        if (txtCodeEditor.Text.Length <= 0 || lblBytesUsed.Text == "0")
                        {
                            ///Rajesh
                            ///As per Change Request
                            //MessageBox.Show(this,"Please check bytes. Bytes can not be 0. It will be saved as max bytes.", "Warning",MessageBoxButtons.OK, MessageBoxIcon.Warning);						
                            MessageBox.Show(this, "You must include a valid level solution.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            ///end
                            return;
                        }
                        else
                            if (arrLevels[currentLevelIndex].IsLevelChanged || currentLevelPoints != arrLevels[currentLevelIndex].getSavedLevelPoints(currentLevelId) || arrLevels[currentLevelIndex].getMaxChar(currentLevelId) != CountChars(txtCodeEditor.Text) || arrLevels[currentLevelIndex].IsClearAllChecked)
                            {
                                if (!arrLevels[currentLevelIndex].CheckAtLeastOneDot(currentLevelIndex))
                                {
                                    MessageBox.Show(this, "This level has no white buttons.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                    return;
                                }
                                else if (arrLevels[currentLevelIndex].IsLevelChanged)
                                {
                                    /*==============================================================================
                                    *  Added By : Vivek Balagangadharan
                                    *  Description : Added to make sure that the level is run before saving a level design
                                    *  Added On : 14-Apr-2006
                                    * ==============================================================================*/
                                    if (!arrLevels[currentLevelIndex].IsLevelRun)
                                    {
                                        MessageBox.Show(this, "Please run a valid solution before attempting to save this level.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                        return;
                                    }
                                    else if (!arrLevels[currentLevelIndex].isLevelSolutionValid)
                                    {
                                        MessageBox.Show(this, "Please enter a valid solution which solves this level.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                        return;
                                    }
                                    /*End */
                                }
                                else if (!arrLevels[currentLevelIndex].IsLevelChanged)
                                {
                                    MessageBox.Show(this, "This level has not been changed.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                    return;
                                }
                            }
                            else
                            {
                                MessageBox.Show(this, "This level has not been changed.", "Warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                                return;
                            }


                    if (arrLevels[currentLevelIndex].IsLevelUpdate || int.Parse(txtLevelPoints.Text) != levelPoints || arrLevels[currentLevelIndex].getMaxChar(currentLevelId) != CountChars(txtCodeEditor.Text))
                    {
                        Level.setMaxBytes(CountChars(txtCodeEditor.Text));
                        System.Windows.Forms.DialogResult SaveYesNo = System.Windows.Forms.DialogResult.No;
                        ///Ramoved By Rajesh
                        //SaveYesNo = MessageBox.Show(this,"Do you want to save this level?", "Herbert - Question", MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
                        //if(SaveYesNo == DialogResult.Yes)
                        //{
                        ///	
                        DisableAllItems(false);
                        txtLevelPoints.ReadOnly = true;

                        lvlpoints = int.Parse(txtLevelPoints.Text);
                        txtLevelPoints.Text = lvlpoints.ToString();


                        lblClosing.Visible = true;
                        lblClosing.Left = this.Width / 2 - lblClosing.Width / 2;
                        lblClosing.Top = this.Height / 2 - lblClosing.Height / 2;
                        lblClosing.Text = "Saving level...";
                        Cursor.Current = Cursors.WaitCursor;
                        lblClosing.Refresh();
                        this.Refresh();
                        Thread.Sleep(200);
                        Object oper = EnableMyMenu(GlobalData.GUID);
                        Object values = DisableMyMenu(plain, GlobalData.GUID, 1);
                        bool blnSavingDone = false;
                        isCurrentLevelSaved = false;
                        while (true)
                        {
                            try
                            {
                                string strLeveltype = cmbxLevelType.Text;
                                arrLevels[currentLevelIndex].LevelType = strLeveltype;
                                if (currentLevelId == 0)
                                {
                                    if (currentLevelIndex == 0)
                                    {
                                        arrLevels[currentLevelIndex].SaveNewLevel(currentLevelId, LevelChangeBar.Maximum / 10, values, oper, txtCodeEditor.Text, strLeveltype);
                                    }
                                    else
                                    {
                                        arrLevels[currentLevelIndex].SaveNewLevel(currentLevelId, currentLevelIndex, values, oper, txtCodeEditor.Text, strLeveltype);
                                    }
                                }
                                //Level.SaveNewLevel(currentLevelId, LevelChangeBar.Maximum/10,values, oper,txtCodeEditor.Text);
                                else
                                    arrLevels[currentLevelIndex].SaveNewLevel(currentLevelId, arrLevels[currentLevelIndex].getLevelNumber(currentLevelId), values, oper, txtCodeEditor.Text, strLeveltype);

                                //Level.SaveNewLevel(currentLevelId, arrLevels[currentLevelIndex].getLevelNumber(currentLevelId),values, oper,txtCodeEditor.Text);
                                blnSavingDone = true;
                                isCurrentLevelSaved = true;
                                arrLevels[currentLevelIndex].IsLevelUpdate = false;
                                arrLevels[0].HerbertX = (BoardWidth / 2 + HOFFSET - HConstants.DOTSPACE) / GlobalData.ZoomInZoomOut;
                                arrLevels[0].HerbertY = (BoardHeight / 2 + HOFFSET - HConstants.DOTSPACE) / GlobalData.ZoomInZoomOut;
                                break;
                            }
                            catch (Exception exp)
                            {
                                //MessageBox.Show(this,exp.Message);
                                if (exp.Message.IndexOf("timed-out") > 0)
                                {
                                    SaveYesNo = MessageBox.Show(this, "There was an error in saving your level. Connection to the server timed-out.\nDo you want to retry the upload?\nPress Yes to retry or No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                                    if (SaveYesNo == DialogResult.No)
                                    {
                                        break;
                                    }
                                }
                                else if (exp.Message.IndexOf("underlying connection was closed") > 0)
                                {
                                    SaveYesNo = MessageBox.Show(this, "There was an error in saving your level. Please check your network connection.\nDo you want to retry the upload?\nPress Yes to retry or No to return to Herbert.", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error);
                                    if (SaveYesNo == DialogResult.No)
                                    {
                                        break;
                                    }
                                }
                                else
                                {
                                    SaveYesNo = MessageBox.Show(this, "There was an error in saving your level. There was an error connecting to server.\nDo you want to retry the upload?\nPress Yes to retry or No to return to Herbert.\n" + exp.Message, "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Error);
                                    if (SaveYesNo == DialogResult.No)
                                    {
                                        break;
                                    }
                                }
                            }
                        }
                        if (blnSavingDone)
                        {



                            arrLevels = Level.BuildAllLevelData();
                            Level.LevelDesignData();
                            //Start//By Rajesh,21/8/06,3885
                            //for (int cnt = 0; cnt < arrLevels.Length; cnt++)
                            //{
                            //    arrLevels[cnt].setIsLevelChanged();
                            //}                            
                            //arrLevels[currentLevelIndex].blnNewHerdleBufferChanged = false;
                            //arrLevels[currentLevelIndex].blnNewHerdleBufferChanged = false;
                            //arrLevels[currentLevelIndex].clearNonSavedData();
                            //End//

                            lblTotalLevels.Text = (arrLevels.Length - 1).ToString();//rename. add  prefix lbl.
                            lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
                            lblMaxChars.Text = "(Max " + arrLevels[currentLevelIndex].getMaxChar(currentLevelId).ToString() + ")";
                            lblLevelNo.Text = currentLevelIndex.ToString();
# if(CONTEST)
							lblTotalScore.Text = Level.totalScore.ToString();
#endif
                            lblScoreCurrent.Text = arrLevels[currentLevelIndex].levelScore.ToString() + "/" + Level.getLevelPoints(currentLevelIndex).ToString();
                            lblLevelSolved.Text = "Unsolved";
                            LevelChangeBar.Maximum = arrLevels.Length * 10;
                            currentLevelId = Level.GetLevelId(currentLevelIndex);
                            resetHerbert();
                            txtLevelPoints.ReadOnly = false;
                            HerbertBoard.Refresh();


                            if (currentLevelIndex == 0)
                            {
                                txtCodeEditor.Clear();
                                txtLevelPoints.Text = "0";
                            }
                            arrLevels[currentLevelIndex].IsClearAllChecked = false;
                            arrLevels[currentLevelIndex].IsLevelChanged = false;
                            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                                InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                            else
                                InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
                            arrLevels[0].HerbertX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut;
                            arrLevels[0].HerbertY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut;

                        }
                        ///Rajesh
                        ///To display Saving meassge
                        lblClosing.Visible = false;

                        Cursor.Current = Cursors.Default;
                        ///To Disable Save level menu after saving the level
#if(DESIGNER)
                        mnuSaveLevel.Enabled = false;
                        ///To enable only for o'th level 
                        if (currentLevelIndex == 0)
                        {
                            UncheckAllDH();
                            mnuWhitebttn.Checked = true;
                        }
#endif

                        ///end
                        EnableAllItems();
                        IniOrResetRunMenu();
                        //}
                    }
                }
                catch
                {
                    //				//Console.WriteLine(exp.Message + ", mnuSaveLevel_Click, 11");
                    //MessageBox.Show(this,exp.Message);
                    EnableAllItems();
                    txtLevelPoints.ReadOnly = false;
                }

                /*==============================================================================
                         *  Commented By : Vivek Balagangadharan
                         *  Description : This was an old implementation which was to make sure that 
                         *				  level 0 does not load with single level designer.
                         *  Added On : 10-Apr-2006
                         *  Special Comments : 
                 ==============================================================================*/
                //			if(GlobalData.iLevelId > 0)
                //			{
                //				LevelChangeBar.Value = 10;
                //				LevelChangeBar.Enabled = false;
                //			}
                /* End */
            }
            else
            {
                // added by Nikhil Kardale on 19/03/2008 to resolve issue id. 10902 
                if (GlobalData.IsDesignerClosed)
                    Application.Exit();
            }
		}
		

		/// <summary>
		/// this menu event is used to set a bool variable to true to indicate
		/// that herbert is clicked at level 0 in designer mode and is ready
		/// to be placed somewhere else.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>

		private void mnuHerbie_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuHerbie.Checked = true;
		}
				

		/// <summary>
		/// eraser menu event.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		/// 

		private void mnuEraser_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuEraser.Checked = true;
			//HerbertBoard.Cursor = System.Windows.Forms.Cursors.NoMove2D;
#if(PATTERN_GENERATER)
            if (GlobalData.iPatternId != "-1")
            {
                try
                {
                    if (arrLevels[currentLevelIndex].IsValidPatternImage)
                    {
                        arrLevels[currentLevelIndex].drawLevel(Level.GetLevelId(currentLevelIndex));
                        arrLevels[currentLevelIndex].IsValidPatternImage = false;
                    }
                }
                catch { }
            }
#endif
			
		}



		/// <summary>
		/// menu walldown event.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void mnuWallDown_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuWallDown.Checked = true;
#if(PATTERN_GENERATER)
            if (GlobalData.iPatternId != "-1")
            {
                try
                {
                    if (arrLevels[currentLevelIndex].IsValidPatternImage)
                    {
                        arrLevels[currentLevelIndex].drawLevel(Level.GetLevelId(currentLevelIndex));
                        arrLevels[currentLevelIndex].IsValidPatternImage = false;
                    }
                }
                catch { }
            }
#endif
		}


		/// <summary>
		/// menu wallright event.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void mnuWallRight_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuWallRight.Checked = true;
		}


		/// <summary>
		/// menu greybttn event.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void munGreybttn_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuGreybttn.Checked = true;
#if(PATTERN_GENERATER)
            if (GlobalData.iPatternId != "-1")
            {
                try
                {
                    if (arrLevels[currentLevelIndex].IsValidPatternImage)
                    {
                        arrLevels[currentLevelIndex].drawLevel(Level.GetLevelId(currentLevelIndex));
                        arrLevels[currentLevelIndex].IsValidPatternImage = false;
                    }
                }
                catch { }
            }
#endif
		}


		/// <summary>
		/// menu white bttn event.
		/// </summary>
		/// <param name="sender"></param>
		/// <param name="e"></param>
		private void mnuWhitebttn_Click(object sender, System.EventArgs e)
		{
			UncheckAllDH();
			mnuWhitebttn.Checked = true;
			arrLevels[currentLevelIndex].WhiteButtonCount++;
#if(PATTERN_GENERATER)
            if (GlobalData.iPatternId != "-1")
            {
                try
                {
                    if (arrLevels[currentLevelIndex].IsValidPatternImage)
                    {
                        arrLevels[currentLevelIndex].drawLevel(Level.GetLevelId(currentLevelIndex));
                        arrLevels[currentLevelIndex].IsValidPatternImage = false;
                    }
                }
                catch { }
            }
#endif
		}
		/// <summary>
		/// for unckecking some menu items under design menu.
		/// </summary>
		private void UncheckAllDH()
		{
			mnuWhitebttn.Checked = false;
			mnuGreybttn.Checked = false;
			mnuWallRight.Checked = false;
			mnuWallDown.Checked = false;
			mnuEraser.Checked = false;
			mnuHerbie.Checked = false;

			resetHrtbPos = false;

		}

		private int iLineX1, iLineY1;
		private int iLineX2, iLineY2;
		private bool drawWall = false;
		private bool eraseWall = false;
		
		/// <summary>
		/// Variable indicates whether to draw a white button on mouse drag.
		/// </summary>
		private bool drawWhiteBtn = false;
		
		/// <summary>
		/// Variable indicates whether to draw a gray button on mouse drag.
		/// </summary>
		private bool drawGrayBtn = false;

        /// <summary>
        /// this event is used in designer mode to create a new level design.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>

        private void HerbertBoard_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            /*check if user is admin and level is 0*/
            //removed, Vijay
            //if(GlobalData.IsDesigner == 1 && !blnTutorial)

            bool isBorardUpdated = false;

            if (GlobalData.HerbertMode == HMode.Designer)
            {

                if (e.Button == MouseButtons.Left)
                {
                    /*calculate the x and y points on the scale of 8 picsal per point.*/
                    int rem = 0;
                    int X = Math.DivRem(e.X, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem);
                    if (rem <= 4 * GlobalData.ZoomInZoomOut)
                    {
                        X--;
                    }
                    int rem1 = 0;
                    int Y = Math.DivRem(e.Y, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem1);
                    if (rem1 <= 4 * GlobalData.ZoomInZoomOut)
                    {
                        Y--;
                    }
                    Xdn = X;
                    Ydn = Y;
                    if (!arrLevels[currentLevelIndex].IsLevelUpdate)
                    {
                        //Note This variable will be made true under function getLevelDataToUpdate(currentLevelId)
                        //arrLevels[currentLevelId].IsLevelUpdate = true;

                        arrLevels[currentLevelIndex].getLevelDataToUpdate(currentLevelId);
                    }
                    //if X and Y is not equal to -1 then only draw any item.
                    //here X and Y is not absolute picsal but 8 picsal constituts 
                    //1 increament of X or Y.
                    if (X != -1 && Y != -1)
                    {
                        if (mnuWhitebttn.Checked == true && X < 25 && Y < 25)
                        {
                            arrLevels[currentLevelIndex].DesignDot(X, Y, 0);
                            isBorardUpdated = true;
                        }
                        if (mnuWallRight.Checked == true && X < 24 && Y < 25)
                        {
                            arrLevels[currentLevelIndex].DesignHurdle(X, Y, X + 1, Y);
                            isBorardUpdated = true;
                        }
                        if (mnuWallDown.Checked == true && X < 25 && Y < 24)
                        {
                            arrLevels[currentLevelIndex].DesignHurdle(X, Y, X, Y + 1);
                            isBorardUpdated = true;
                        }
                        if (mnuWallDown.Checked || mnuWallRight.Checked && X < 25 && Y < 25)
                        {
                            iLineX1 = iLineX2 = X;
                            iLineY1 = iLineY2 = Y;
                            drawWall = true;
                        }
                        /*==============================================================================
                        *  Added By : Vivek Balagangadharan
                        *  Description : setting variables to draw buttons on mouse move
                        *  Added On : 17-Apr-2006
                        *  Special Comments : 
                        * ==============================================================================*/
                        if (mnuWhitebttn.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25)
                        {
                            drawWhiteBtn = true;
                        }
                        if (mnuGreybttn.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25)
                        {
                            drawGrayBtn = true;
                        }
                        /*End*/

                        /*==============================================================================
                         *  Added By: Vivek Balagangadharan
                         *  Description: Check for 'resetHrtbPos = true' removed.
                         *  Added On: 17-Apr-2006
                         *  Special Comments: Brian:when you select "Herbert", it seems that all clicks are 
                         *							ignored until you click on his current posiution once - then 
                         *							each click after that moves herbert. i don't think it should 
                         *							be requiured to click on herbert once.
                         * ==============================================================================*/
                        //						if(mnuHerbie.Checked == true && resetHrtbPos == true && X < 25 && Y < 25)
                        if (mnuHerbie.Checked == true && X < 25 && Y < 25)
                        {
                            if (Level.CheckLineButton(X, Y))
                            {

                                arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X = X * HConstants.DOTSPACE + HOFFSET;
                                arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y = Y * HConstants.DOTSPACE + HOFFSET;
                                try
                                {
                                    //change the change the location of herbert.
                                    //change the location of herbert picture box and 2 is used 
                                    //because we can't specify the center point of a picture box
                                    //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                                    // and (curPosX, curPosY) is center point where this picture 
                                    //box should be displayed.
                                    //lock(this.herbertPicBox)
                                    {
                                        arrLevels[currentLevelIndex].IsLevelChanged = true;
                                        isBorardUpdated = true;
                                        arrLevels[currentLevelIndex].IsLevelRun = false;
                                        arrLevels[currentLevelIndex].isLevelSolutionValid = false;
                                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                            herbertPicBox.Location = new System.Drawing.Point(GlobalData.ZoomInZoomOut * (arrLevels[currentLevelIndex].curPosX - 2) - 1, GlobalData.ZoomInZoomOut * (arrLevels[currentLevelIndex].curPosY - 2));
                                        else
                                            herbertPicBox.Location = new System.Drawing.Point(arrLevels[currentLevelIndex].curPosX - 2, arrLevels[currentLevelIndex].curPosY - 2);
                                    }
                                }
                                catch
                                {
                                    ////Console.WriteLine(e2.Message + ", HerbertBoard_MouseDown, 11");
                                }

                                //<Changed by vinay on 2005/07/11>
                                arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                                arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
                                //</Changed by vinay on 2005/07/11>
                                //Level.SetRoboPos(curPosX/GlobalData.ZoomInZoomOut, curPosY/GlobalData.ZoomInZoomOut);
                                arrLevels[currentLevelIndex].HerbertX = arrLevels[currentLevelIndex].curPosX;
                                arrLevels[currentLevelIndex].HerbertY = arrLevels[currentLevelIndex].curPosY;
                            }
                            else
                                MessageBox.Show(this, "You can't place Herbert here.", "Warning");
                        }
                        if (mnuEraser.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25)
                        {
                            //2 is for removing vertical line and 1 is for horizontal.
                            eraseWall = true;
                            isBorardUpdated = true;
                            if (rem < rem1)
                                arrLevels[currentLevelIndex].Erase(X, Y, 1);
                            else
                                arrLevels[currentLevelIndex].Erase(X, Y, 2);
                            if (GlobalData.iPatternId != "-1" || arrLevels[currentLevelIndex].IsPatternEnabled)
                            {
                                arrLevels[currentLevelIndex].drawLevelAfterErase();
                            }
                            this.HerbertBoard.Refresh();

                        }
                        if (mnuGreybttn.Checked == true && X < 25 && Y < 25)
                        {
                            isBorardUpdated = true;
                            arrLevels[currentLevelIndex].DesignDot(X, Y, 1);
                        }
                        if (isBorardUpdated == true)
                        {
                            mnuSaveLevel.Enabled = true;
                        }

                        HerbertBoard.Refresh();
                    }
                }
            }
        }

        //vinay02/09/05HerbertBoard.Refresh();;


        /// <summary>
        /// Event of text change.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void HerbertBoard_MouseMove(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //removed, Vijay
            //if(GlobalData.IsDesigner == 1 && !blnTutorial && drawWall)
            if (mnuEraser.Checked)
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                {
                    //HerbertBoard.Cursor = new Cursor("..\\..\\BigEraser.cur");
                }
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                {
                    //HerbertBoard.Cursor = new Cursor("..\\..\\SmallEraser.cur");
                }
            }
            else
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                {
                    HerbertBoard.Cursor = System.Windows.Forms.Cursors.Default;
                }
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                {
                    HerbertBoard.Cursor = System.Windows.Forms.Cursors.Default;
                }
            }
            if (GlobalData.HerbertMode == HMode.Designer && drawWall)
            {
                int rem = 0;
                int X = Math.DivRem(e.X, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem);
                if (rem <= 4 * GlobalData.ZoomInZoomOut)
                {
                    X--;
                }
                int rem1 = 0;
                int Y = Math.DivRem(e.Y, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem1);
                if (rem1 <= 4 * GlobalData.ZoomInZoomOut)
                {
                    Y--;
                }
                if (drawWall && (X <= 24 && X >= 0) && (Y <= 24 && Y >= 0))
                {
                    //				//Console.WriteLine("inside drawWall");
                    //				if(rem != 0 || rem1 != 0)
                    //				{
                    //					//Console.WriteLine("Inside rem");
                    if ((mnuWallDown.Checked && Y != iLineY2) || (mnuWallRight.Checked && X != iLineX2))
                    {
                        //						iLineX1 = iLineX2;
                        //						iLineY1 = iLineY2;
                        //						//Console.WriteLine("X"+X);
                        //						//Console.WriteLine("Y"+Y);
                        iLineX2 = X;
                        iLineY2 = Y;
                        //base.OnPaint(e);
                        //vinay02/09/05HerbertBoard.Refresh();;	
                        HerbertBoard.Invalidate();
                    }
                    //				}
                }
            }
            if (GlobalData.HerbertMode == HMode.Designer && eraseWall)
            {
                int rem = 0;
                int X = Math.DivRem(e.X, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem);
                if (rem <= 4 * GlobalData.ZoomInZoomOut)
                {
                    X--;
                }
                int rem1 = 0;
                int Y = Math.DivRem(e.Y, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem1);
                if (rem1 <= 4 * GlobalData.ZoomInZoomOut)
                {
                    Y--;
                }
                Yup = Y;
                Xup = X;
                //				if(eraseWall && (X <= 24 && X >=0) && (Y <= 24 && Y >=0))
                //				{
                //					//				//Console.WriteLine("inside drawWall");
                //					//				if(rem != 0 || rem1 != 0)
                //					//				{
                //					//					//Console.WriteLine("Inside rem");
                //					if((mnuEraser.Checked && Y != iLineY2) || (mnuEraser.Checked && X != iLineX2))
                //					{
                //						//						iLineX1 = iLineX2;
                //						//						iLineY1 = iLineY2;
                //						//						//Console.WriteLine("X"+X);
                //						//						//Console.WriteLine("Y"+Y);
                //						iLineX2 = X;
                //						iLineY2 = Y;
                //						//base.OnPaint(e);
                //						//vinay02/09/05HerbertBoard.Refresh();;	
                //						HerbertBoard.Invalidate();
                //					}
                //					//				}
                //				}
                if (mnuEraser.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25)
                {
                    if (rem < rem1)
                    {
                        arrLevels[currentLevelIndex].Erase(X, Y, 1);
                    }
                    else
                    {
                        arrLevels[currentLevelIndex].Erase(X, Y, 2);
                    }
                    if (GlobalData.iPatternId != "-1" || arrLevels[currentLevelIndex].IsPatternEnabled)
                    {
                        arrLevels[currentLevelIndex].drawLevelAfterErase();
                    }
                    HerbertBoard.Invalidate();
                }
            }
            /*==============================================================================
            *  Added By : Vivek Balagangadharan
            *  Description : to add buttons on mouse move
            *  Added On : 17-Apr-2006
            *  Special Comments : 
            * ==============================================================================*/
            if (GlobalData.HerbertMode == HMode.Designer && (drawWhiteBtn || drawGrayBtn))
            {
                int rem = 0;
                int X = Math.DivRem(e.X, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem);
                if (rem <= 4 * GlobalData.ZoomInZoomOut)
                {
                    X--;
                }
                int rem1 = 0;
                int Y = Math.DivRem(e.Y, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem1);
                if (rem1 <= 4 * GlobalData.ZoomInZoomOut)
                {
                    Y--;
                }
                if (mnuWhitebttn.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25 && drawWhiteBtn)
                {
                    arrLevels[currentLevelIndex].DesignDot(X, Y, 0);
                }
                if (mnuGreybttn.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25 && drawGrayBtn)
                {
                    arrLevels[currentLevelIndex].DesignDot(X, Y, 1);
                }
                HerbertBoard.Invalidate();
            }
            /*End*/
        }

        private void HerbertBoard_MouseUp(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //removed, Vijay
            //if(GlobalData.IsDesigner == 1 && !blnTutorial)
            if (GlobalData.HerbertMode == HMode.Designer && eraseWall)
            {
                eraseWall = false;
                int rem = 0;
                int X = Math.DivRem(e.X, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem);
                if (rem <= 4 * GlobalData.ZoomInZoomOut)
                {
                    X--;
                }
                int rem1 = 0;
                int Y = Math.DivRem(e.Y, HConstants.DOTSPACE * GlobalData.ZoomInZoomOut, out rem1);
                if (rem1 <= 4 * GlobalData.ZoomInZoomOut)
                {
                    Y--;
                }
                Xup = X;
                Yup = Y;

                if (mnuEraser.Checked == true && X < 25 && X >= 0 && Y >= 0 && Y < 25)
                {
                    if (rem < rem1)
                    {
                        arrLevels[currentLevelIndex].Erase(X, Y, 1);
                    }
                    else
                    {
                        arrLevels[currentLevelIndex].Erase(X, Y, 2);
                    }
                    //					if(Ydn==Yup)
                    //					{			
                    //						if(Xdn < Xup )
                    //							for(int i = Xdn; i < Xup; i++)
                    //							{
                    //								if(Level.CheckRoboXY(i,Ydn) && Level.CheckRoboXY(i+1,Ydn))
                    //									arrLevels[currentLevelIndex].Erase(i,Ydn,1);
                    //							}
                    //						else
                    //							for(int i = Xup; i < Xdn; i++)
                    //							{
                    //								if(Level.CheckRoboXY(i,Ydn) && Level.CheckRoboXY(i+1,Ydn))
                    //									arrLevels[currentLevelIndex].Erase(i,Ydn,1);
                    //							}
                    //					}			
                    //				
                    //					if ( Xdn==Xup )
                    //					{
                    //						if(Ydn < Yup)
                    //							for(int i = Ydn; i < Yup; i++)
                    //							{
                    //								if(Level.CheckRoboXY(Xdn,i) && Level.CheckRoboXY(Xdn, i+1))
                    //									arrLevels[currentLevelIndex].Erase(Xdn,i,2);
                    //							}
                    //						else
                    //							for(int i = Yup; i < Ydn; i++)
                    //							{
                    //								if(Level.CheckRoboXY(Xdn,i) && Level.CheckRoboXY(Xdn, i+1))
                    //									arrLevels[currentLevelIndex].Erase(Xdn,i,2);
                    //							}
                    //					}  
                    HerbertBoard.Invalidate();
                }
            }
            if (GlobalData.HerbertMode == HMode.Designer)
            {
                drawWall = false;

                /*==============================================================================
                *  Added By : Vivek Balagangadharan
                *  Description : reset boolean variables so that the buttons are not drawn after 
                                 mouse_up event
                *  Added On : 17-Apr-2006
                * ==============================================================================*/
                drawWhiteBtn = false;
                drawGrayBtn = false;
                /*End*/

                if (mnuWallRight.Checked == true)
                {
                    if (iLineX1 < iLineX2)
                        for (int i = iLineX1; i < iLineX2; i++)
                        {
                            if (Level.CheckRoboXY(i, iLineY1) && Level.CheckRoboXY(i + 1, iLineY1))
                                arrLevels[currentLevelIndex].DesignHurdle(i, iLineY1, i + 1, iLineY1);
                        }
                    else
                        for (int i = iLineX2; i < iLineX1; i++)
                        {
                            if (Level.CheckRoboXY(i, iLineY1) && Level.CheckRoboXY(i + 1, iLineY1))
                                arrLevels[currentLevelIndex].DesignHurdle(i, iLineY1, i + 1, iLineY1);
                        }

                }
                else
                    if (mnuWallDown.Checked == true)
                    {
                        if (iLineY1 < iLineY2)
                            for (int i = iLineY1; i < iLineY2; i++)
                            {
                                if (Level.CheckRoboXY(iLineX1, i) && Level.CheckRoboXY(iLineX1, i + 1))
                                    arrLevels[currentLevelIndex].DesignHurdle(iLineX1, i, iLineX1, i + 1);
                            }
                        else
                            for (int i = iLineY2; i < iLineY1; i++)
                                if (Level.CheckRoboXY(iLineX1, i) && Level.CheckRoboXY(iLineX1, i + 1))
                                    arrLevels[currentLevelIndex].DesignHurdle(iLineX1, i, iLineX1, i + 1);
                    }
                //vinay02/09/05HerbertBoard.Refresh();;
                HerbertBoard.Invalidate();
            }

        }

		private void NullGuid()
		{
			Object oper = EnableMyMenu(GlobalData.GUID);
			DisableAllItems(false);
			lblClosing.Text = "Closing designer...";
			lblClosing.Refresh();
			this.Refresh();
			//Object IdContestant = DisableMyMenu(GlobalData.ContestantId,GlobalData.GUID,2);
			int iCloseRetry = 0;
			while(true)
			{
				try
				{
					GlobalData.initlizeWS();
					int z = (int)GlobalData.HS.MakeGuidNull(oper);
					break;
				}
				catch(Exception exp)
				{
					iCloseRetry++;
					if(iCloseRetry >= 3)
						break;
					//MessageBox.Show(this,exp.Message);
				}
				finally
				{
					if(GlobalData.HS !=null)
						GlobalData.HS.Dispose();
					GlobalData.HS=null;
				}
			}
		}

#endif
        #endregion

        #region Tracing Related functions

        /// <summary>
        /// click event of panelTxtCodeEidtor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void PanalTxtCodeEdit_Click(object sender, System.EventArgs e)
        {
            //set codeeditor to visible
            lock (txtCodeEditor)
            {
                txtCodeEditor.Visible = true;
            }
        }


        //variables for displaying line trace boxes
        private int lineX = 1, lineY = 0, lineWidth = 0, LineHeight = 13;

        /// <summary>
        /// get the line length to be displayed on bottom trace.
        /// </summary>
        //		private void getIndexsToDispLT()
        //		{
        ////			//Console.WriteLine("getIndexsToDispLT(): start");
        ////			//Console.WriteLine("1o, iStartIndexLT = " +iStartIndexLT);
        ////			//Console.WriteLine("1o, iEndIndexLT = " +iEndIndexLT);
        ////			#if (EXCEPTION)
        ////			try
        ////			{
        ////#endif
        ////			//Console.WriteLine("1o, tCurLine.iLength = " +tCurLine.iLength.ToString());
        ////			for(int i=0;i<tCurLine.iLength-1;i++)
        ////				//Console.WriteLine("1o, acCurrentLine["+i+"] = " +acCurrentLine[i].ToString());
        ////			//Console.WriteLine("1o, acCurrentLine[tCurLine.iLength-2] = " +acCurrentLine[tCurLine.iLength-2].ToString());
        ////			//Console.WriteLine("1o, acCurrentLine[tCurLine.iLength-3] = " +acCurrentLine[tCurLine.iLength-3].ToString());
        //			//string str = new string(acCurrentLine,0,tCurLine.iLength);
        //			string str = "";
        //			for(int i=0;i<tCurLine.iLength-1;i++)
        //						str = str + acCurrentLine[i].ToString();
        //			////Console.WriteLine("1o, str = " +str);
        //#if (EXCEPTION)
        //				try
        //				{
        //#endif
        //					//assign text to buffer label from endindex of last displayed text to the end.
        //					string str1 = str.Substring(iEndIndexLT,tCurLine.iLength-1-iEndIndexLT);
        //					
        //					////Console.WriteLine("1o, str1 = " +str1);
        ////					//lblLT.Text = str.Substring(iEndIndexLT,tCurLine.iLength-iEndIndexLT);
        //					////Console.WriteLine("karthikeyan1");
        //					////Console.WriteLine("str1 = " +str1.ToString());
        //					////Console.WriteLine("karthikeyan2");
        //					lblLT.Text = str1;
        //					////Console.WriteLine("karthikeyan3");
        //					str1 = null;
        //					////Console.WriteLine("karthikeyan4 lblLT.Text = " +lblLT.Text);
        //#if (EXCEPTION)
        //				}
        //				catch
        //				{
        //					////Console.WriteLine(exp1.Message + ", getIndexsToDispLT, 11");
        //					GC.Collect();
        //				}
        //#endif
        //				//check if buffer's width is less than the lblLineTracing's width else
        //				//decrease text by one char each time and check again.
        //				////Console.WriteLine(lblLT.Width.ToString()+", "+WIDTHOFFSET.ToString()+", " +lblLineTracing.Width.ToString());
        //				////Console.WriteLine(lblLT.Width.ToString());
        //				////Console.WriteLine(WIDTHOFFSET.ToString());
        //				////Console.WriteLine("karthikeyan5");
        //				if(lblLT.Width+WIDTHOFFSET < lblLineTracing.Width)
        //				{
        //					iStartIndexLT = iEndIndexLT;
        //					iEndIndexLT = tCurLine.iLength-1;
        //					////Console.WriteLine("1b, iStartIndexLT = " +iStartIndexLT);
        //					while(lblLT.Width+WIDTHOFFSET <= lblLineTracing.Width)
        //					{
        //						if(iStartIndexLT ==0)
        //							break;
        //						iStartIndexLT--;
        //						lblLT.Text = str.Substring(iStartIndexLT,tCurLine.iLength-1 - iStartIndexLT);
        //					}
        //					////Console.WriteLine("1a, iStartIndexLT = " +iStartIndexLT);
        //				}					
        //				else if(lblLT.Width+WIDTHOFFSET >= lblLineTracing.Width)
        //				{
        //					iStartIndexLT = iEndIndexLT;
        //					iEndIndexLT = tCurLine.iLength-2;
        //					////Console.WriteLine("2b, iStartIndexLT = " +iStartIndexLT);
        //					////Console.WriteLine("2b, iEndIndexLT = " +iEndIndexLT);
        //					while(lblLT.Width+WIDTHOFFSET >= lblLineTracing.Width)
        //					{
        //						////Console.WriteLine("lblLT iEndIndexLT=" +iEndIndexLT+ " TraceX="+TraceX);
        //						if(iEndIndexLT == 0 || iEndIndexLT <= TraceX+TraceWidth)
        //							break;
        //						iEndIndexLT--;
        //						lblLT.Text = str.Substring(iStartIndexLT,iEndIndexLT-iStartIndexLT);
        //					}
        //					////Console.WriteLine("2a, iEndIndexLT = " +iEndIndexLT);
        //					while(lblLT.Width+WIDTHOFFSET >= lblLineTracing.Width)
        //					{
        //						if(iStartIndexLT == iEndIndexLT)
        //							break;
        //						iStartIndexLT++;
        //						lblLT.Text = str.Substring(iStartIndexLT,iEndIndexLT-iStartIndexLT);
        //					}
        //					////Console.WriteLine("2a, iStartIndexLT = " +iStartIndexLT);
        //				}
        ////				lblLT.Text = str.Substring(0, iEndIndexLT);
        ////				iFrameLT = lblLT.Width/lblLineTracing.Width;
        //				str = null;
        ////#if (EXCEPTION)
        ////			}
        ////			catch(Exception exp)
        ////			{
        ////				////Console.WriteLine(exp.Message + ", getIndexsToDispLT, 21");
        ////			}	
        ////			finally
        ////			{
        //////				str = null;
        //////				str1 = null;
        ////			}
        ////			#endif
        //			////Console.WriteLine("getIndexsToDispLT(): end");
        //		}


        /// <summary>
        /// get the line length to be displayed on Editor trace.
        /// </summary>
        /// <param name="iLine">int</param>
        /// <returns>string</returns>
        /* commented by karthikeyan 16/03
        private string getTextForET(int iLine)
        {
            //			int iLineLnth = txtCodeEditor.Lines[iLine].Length;
            //			int iStartIndex = 0;
            //			int iStrLn = 0;
            //			if(iLineLnth < 24 && iFrameLT != 0)
            //				return "";
            //
            //			for(int i = 0; i < iFrameLT; i++)
            //			{	
            //				if(iLineLnth <= iStartIndex)
            //					return "";
            //				lbl2.Text = txtCodeEditor.Lines[iLine].Substring(iStartIndex,iStrLn);
            //				while(lbl2.Width+15 < PanalTxtCodeEdit.Width)
            //				{
            //					if(iLineLnth-1 == iStrLn+iStartIndex)
            //						break;
            //					lbl2.Text = txtCodeEditor.Lines[iLine].Substring(iStartIndex,++iStrLn);
            //				}
            //				if(iLineLnth-1 == iStrLn+iStartIndex)
            //					break;
            //				iStartIndex+=iStrLn;
            //				iStrLn = 0;
            //			}
            //			lbl2.Text = txtCodeEditor.Lines[iLine].Substring(iStartIndex,iEndIndex);
            return "";
        }
          */
        private void getTextForETFrame(int iLine)
        {
            ////Console.WriteLine("This is for i = " + iLine.ToString());
            int actualLineNo = getActualLineNum(iLine);
            ////Console.WriteLine("actualLineNo : " + actualLineNo.ToString());
            int[] CharNo = new int[100];
            int iLineLnth = 0;
            //			lock(txtCodeEditor)
            //			{
            iLineLnth = txtLines[actualLineNo].Length;
            ////Console.WriteLine("iLineLnth :" + iLineLnth.ToString());
            //}
            int numframes = 1;
            int index = 0;
            int icharno = 0;
            try
            {
                //				lock(txtCodeEditor)
                //				{
                lbl2.Text = txtLines[actualLineNo];

                ////Console.WriteLine("initial value stored in lbl2 (txtLines["+actualLineNo+"] : " + lbl2.Text);
                ////Console.WriteLine("lbl2.Width : " + lbl2.Width.ToString());
                ////Console.WriteLine("WIDTHOFFSET : " + WIDTHOFFSET.ToString());
                ////Console.WriteLine("lbl2.Width+WIDTHOFFSET : " + (lbl2.Width+WIDTHOFFSET).ToString());
                ////Console.WriteLine("PanalTxtCodeEdit.Width" + PanalTxtCodeEdit.Width.ToString());
                ////Console.WriteLine("iLineLnth : " + iLineLnth.ToString());
                if (lbl2.Width + WIDTHOFFSET < PanalTxtCodeEdit.Width || iLineLnth <= 10)
                {
                    //numframes++;
                    ////Console.WriteLine("Entered if block");
                    ////Console.WriteLine("index : " + index.ToString());
                    CharNo[index++] = 0;
                    ////Console.WriteLine("index(incremented) : " + index.ToString());
                    ////Console.WriteLine("CharNo[index++] : " + CharNo[index++].ToString());
                    CharNo[index] = iLineLnth - 1;
                    ////Console.WriteLine("index : " + index.ToString());
                    ////Console.WriteLine("CharNo[index] : " + CharNo[index].ToString());
                    ////Console.WriteLine("Exited if block");
                }
                else
                {
                    string str = "";
                    CharNo[index++] = 0;
                    ////Console.WriteLine("Entered else block");
                    ////Console.WriteLine("Set str to blank and CharNo[index++] to zero");
                    for (int i = 11; i < iLineLnth; i++)
                    {
                        //						lock(txtCodeEditor)
                        //						{
                        ////Console.WriteLine("Entered for loop, i = " + i.ToString());

                        str = txtLines[actualLineNo].Substring(icharno, i - icharno);
                        ////Console.WriteLine("str(txtLines[actualLineNo].Substring("+icharno.ToString() + "," + (i - icharno).ToString() + ")) : " + str); 

                        //						}
                        lbl2.Text = str;

                        ////Console.WriteLine("lbl2.Text(str) : " + lbl2.Text);
                        ////Console.WriteLine("lbl2.Width : " + lbl2.Width.ToString());
                        ////Console.WriteLine("WIDTHOFFSET : " + WIDTHOFFSET.ToString());
                        ////Console.WriteLine("lbl2.Width+WIDTHOFFSET : " + (lbl2.Width+WIDTHOFFSET).ToString());
                        ////Console.WriteLine("PanalTxtCodeEdit.Width" + PanalTxtCodeEdit.Width.ToString());

                        if (lbl2.Width + WIDTHOFFSET >= PanalTxtCodeEdit.Width)
                        {
                            numframes++;
                            ////Console.WriteLine("numframes (after incrementation) : " + numframes.ToString());
                            ////Console.WriteLine("index : " + index.ToString());
                            CharNo[index++] = i;
                            ////Console.WriteLine("index(incremented) : " + index.ToString());
                            ////Console.WriteLine("CharNo[index++](i) : " + CharNo[index++].ToString());

                            icharno = i;
                            ////Console.WriteLine("icharno (i) : "+icharno.ToString());

                        }
                    }

                    ////Console.WriteLine("Exited for loop");

                    str = null;
                    //numframes++;
                    ////Console.WriteLine("index : " + index.ToString());
                    CharNo[index] = iLineLnth - 1;
                    ////Console.WriteLine("CharNo[index] : " + CharNo[index].ToString());
                    ////Console.WriteLine("Exited else block");
                }
                arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo = new int[numframes + 1];
                for (int x = 0; x < numframes + 1; x++)
                    arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[x] = CharNo[x];
            }
            catch
            {

            }
            //return "";
        }


        int[] CharNoLT;
        private void getTextForLTFrame()
        {
            int[] CharNo = new int[100];
            int iLineLnth = 0;
            string str = "";
            for (int i = 0; i < arrLevels[currentLevelIndex].tCurLine.iLength - 1; i++)
                str = str + arrLevels[currentLevelIndex].acCurrentLine[i].ToString();

            iLineLnth = str.Length;

            int numframes = 1;
            int index = 0;
            int icharno = 0;
            try
            {
                //				lock(txtCodeEditor)
                //				{
                lbl2.Text = str;
                //}
                if (lbl2.Width + WIDTHOFFSET + 4 < PanalTxtCodeEdit.Width || iLineLnth <= 10)
                {
                    //numframes++;
                    CharNo[index++] = 0;
                    CharNo[index] = iLineLnth - 1;
                }
                else
                {
                    string str1 = "";
                    CharNo[index++] = 0;
                    for (int i = 11; i < iLineLnth; i++)
                    {
                        //						lock(txtCodeEditor)
                        //						{
                        str1 = str.Substring(icharno, i - icharno);
                        //						}
                        lbl2.Text = str1;
                        if (lbl2.Width + WIDTHOFFSET + 4 >= PanalTxtCodeEdit.Width)
                        {
                            numframes++;
                            CharNo[index++] = i;
                            icharno = i;
                        }
                    }
                    str1 = null;
                    //numframes++;
                    CharNo[index] = iLineLnth - 1;
                }
                CharNoLT = new int[numframes + 1];
                for (int x = 0; x < numframes + 1; x++)
                    CharNoLT[x] = CharNo[x];
            }
            catch
            {

            }
            //return "";
        }
        /// <summary>
        /// Check length of all lines. retrun false if anyone is
        /// more than editor width. true if all are less than editor
        /// width.
        /// </summary>
        /// <returns>returns true if any line's width is grater than the width of code editor.</returns>


        private bool chkAllLineLength()
        {
            try
            {
                for (int i = 0; i < arrLevels[currentLevelIndex].lineCount; i++)
                {

                    //assign line i of code editor to buffer label.

                    lbl3.Text = txtLines[i];

                    if (lbl3.Width + WIDTHOFFSET >= PanalTxtCodeEdit.Width)
                        return true;
                }
            }
            catch
            {
                ////Console.WriteLine(exp.Message);
            }
            return false;
        }


        /// <summary>
        /// initial Set up for editor tracing.
        /// </summary>
        /// <param name="iFrameNo">frame number of current frame</param>
        private void SetupEditorTrace(int iFrameNo)
        {
            //get total number of lines.
            //			lock(txtCodeEditor)
            //			{
            arrLevels[currentLevelIndex].lineCount = txtTotalLines;
            //			}
            //check that if total lines in code editor can be displayed on panelCodeEditor.
            //			if(lineCount >(PanalTxtCodeEdit.Height/PanalTxtCodeEdit.Font.Height))
            //				blnVScroll = true;
            try
            {
                blnHScroll = chkAllLineLength();
                for (int i = 0; i < arrLevels[currentLevelIndex].lineCount; i++)
                {
                    getTextForETFrame(i);
                }
                FindNDisplayTxt(0, iFrameLT);
            }
            catch
            {
                ////Console.WriteLine(exp.Message);
            }
        }

        /// <summary>
        /// displays editor tracing. on editor pannel.
        /// </summary>
        /// <param name="iLine">Line Number over which the box should be displayed.</param>
        private void EditorTrace(int iLine)
        {
#if (EXCEPTION)
            try
            {
#endif
                int iY = 0;
                //get line number from top iY will contain line number.
                for (int i = 0; i < arrLevels[currentLevelIndex].atLineInfo[iLine].iStart; i++)
                {
                    if (arrLevels[currentLevelIndex].pcProg[i] == CR)
                        iY += 1;
                }
                for (int k = 0; k < arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo.Length - 1; k++)
                {
                    if (TraceX >= arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[k] && TraceX <= arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[k + 1])
                    {
                        iFrameLT = k;
                        ////Console.WriteLine("iFrameLT = " + iFrameLT);
                        break;
                    }
                }
                ////Console.WriteLine("FindNDisplayTxt("+iY+", "+iFrameLT+")");				
                FindNDisplayTxt(iY, iFrameLT);
                int j = 0, numchars = 0;
                //count number of chars in this line.
                ////Console.WriteLine("for(j = atLineInfo[iLine].frameCharNo[iFrameLT]; pcProg[j] != CR && j < iProgLen-1; j++)" + atLineInfo[iLine].frameCharNo[iFrameLT]);
                if (iFrameLT + 1 < arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo.Length)
                    numchars = arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[iFrameLT + 1] - arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[iFrameLT];//+1;
                //				for(j = atLineInfo[iLine].frameCharNo[iFrameLT]; pcProg[j] != CR && j < iProgLen-1; j++)
                //					numchars++;
                //				//increament num chars by 1 because in above for loop condition (j < iProgLen-1)
                //				//skeeps one char
                numchars++;
                //this all code is implemented for frames on Editor Trace but this part is not complete.

                if (j == arrLevels[currentLevelIndex].iProgLen - 1)
                {
                    //string str = new string(pcProg,atLineInfo[iLine].iStart,numchars);
                    string str = new string(arrLevels[currentLevelIndex].pcProg, arrLevels[currentLevelIndex].atLineInfo[iLine].iStart + arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[iFrameLT], numchars);
                    lbl2.Text = str;
                    str = null;
                }
                else
                {
                    //string str = new string(pcProg,atLineInfo[iLine].iStart,numchars-1);
                    string str = new string(arrLevels[currentLevelIndex].pcProg, arrLevels[currentLevelIndex].atLineInfo[iLine].iStart + arrLevels[currentLevelIndex].atLineInfo[iLine].frameCharNo[iFrameLT], numchars);
                    ////Console.WriteLine("str "+str);
                    lbl2.Text = str;
                    ////Console.WriteLine("lbl2.Text "+lbl2.Text.Replace("\n",""));
                    str = null;
                }

                lineWidth = lbl2.Width - 2;
                lineY = iY * LineHeight - iStartIndexET * LineHeight;
                PanalTxtCodeEdit.Invalidate();
                lbl2.Text = "";
#if (EXCEPTION)
            }
            catch
            {
                //				//Console.WriteLine(exp.Message);
            }
#endif
        }


        /// <summary>
        /// check to see if line length is more than editors width.
        /// </summary>
        /// <param name="iLine">Line number whose Length needs to be calculated.</param>
        /// <returns>returns false if line is longer than editor width else true</returns>
        private bool chkLineLength(int iLine)
        {
#if (EXCEPTION)
            try
            {
#endif
                //assign text to buffer label to check whether its with is greater than or less than 
                //the width of panalTxtCodeEditor.
                //				lock(txtCodeEditor)
                //				{
                lbl2.Text = txtLines[iLine];
                //				}
                //return true if buffer's width is less than PanalTxtCodeEdit's width after assigning the
                //text to buffer label.
                if (lbl2.Width + WIDTHOFFSET <= PanalTxtCodeEdit.Width)
                    return true;
#if (EXCEPTION)
            }
            catch
            {
            }
#endif
            return false;
        }


        /// <summary>
        /// Starting indexe of lines to be displayed on editor trace.
        /// </summary>
        private int iStartIndexET = 0, iEndIndexET = 0;

        /// <summary>
        /// buffer bitmap image for editor trace
        /// </summary>
        private Bitmap EditorImg = new Bitmap(248, 184);

        /// <summary>
        /// find txt to be displayed on Editor Tracing.
        /// </summary>
        /// <param name="iLine">currently executing line.</param>
        /// <param name="iFrame">currently active frame.</param>
        private void FindNDisplayTxt(int iLine, int iFrame)
        {
            Graphics gEI = Graphics.FromImage(EditorImg);
            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
            {
                gEI.Clear(System.Drawing.Color.White);
                gEI.FillRectangle(System.Drawing.Brushes.White, 1, 1, 246, 182);
            }
            else
            {
                gEI.Clear(System.Drawing.Color.White);
                gEI.FillRectangle(System.Drawing.Brushes.White, 1, 1, 327, 388);
            }
#if (EXCEPTION)
            try
            {
#endif
                int iDISPLINES = 0;
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                    iDISPLINES = 20;
                else
                    iDISPLINES = DISPLINES;
                //				//Console.WriteLine("1a iFrame = "+ iFrame);
                //				//Console.WriteLine((!(iLine >= iStartIndexET && iLine <= iEndIndexET)));
                //				//Console.WriteLine((iEndIndexET == 0));
                //				//Console.WriteLine((!(iLine >= iStartIndexET && iLine <= iEndIndexET) || iEndIndexET == 0));
                //				//Console.WriteLine("!("+iLine+ ">="+ iStartIndexET+" && "+iLine+" <= "+iEndIndexET+") || "+iEndIndexET+" == 0)");
                if (!(iLine >= iStartIndexET && iLine <= iEndIndexET) || iEndIndexET == 0)
                {
                    ////Console.WriteLine("1b iFrame = "+ iFrame);

                    if (arrLevels[currentLevelIndex].lineCount <= iDISPLINES)
                    {
                        iStartIndexET = 0;
                        iEndIndexET = arrLevels[currentLevelIndex].lineCount - 1;
                    }
                    else if (arrLevels[currentLevelIndex].lineCount > iDISPLINES && iLine > iDISPLINES)
                    {
                        iEndIndexET = iLine;
                        iStartIndexET = iLine - iDISPLINES + 1;
                    }
                    else if (arrLevels[currentLevelIndex].lineCount > iDISPLINES && iLine <= iDISPLINES - 1)
                    {
                        iStartIndexET = 0;
                        iEndIndexET = iDISPLINES - 1;
                    }

                    //PanalTxtCodeEdit.Invalidate();
                }
                for (int i = iStartIndexET; i <= iEndIndexET; i++)
                {
                    int iVirtualLineNum = 0;
                    iVirtualLineNum = arrLevels[currentLevelIndex].actualVirtualLineNum[i];
                    if (arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].frameCharNo.Length > iFrame + 1)
                    {
                        int ist = arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].frameCharNo[iFrame];
                        int ln = arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].frameCharNo[iFrame + 1] - arrLevels[currentLevelIndex].atLineInfo[iVirtualLineNum].frameCharNo[iFrame] + 1;
                        //						lock(txtCodeEditor)
                        //						{
                        gEI.DrawString(txtLines[i].Substring(ist, ln), PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 0.0f, (i - iStartIndexET) * 13f);
                        //						}
                    }
                    else
                        gEI.DrawString("", PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 0.0f, (i - iStartIndexET) * 13f);
                }
                //				}						
                gEI.Dispose();
                gEI = null;
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(exp.Message);
            }
#endif
            ////Console.WriteLine("end iFrame = "+ iFrame);
        }


        /*variables to contain start and end points of Line tracing*/
        private int iStartIndexLT = 0, iEndIndexLT = 0, iFrameLT = 0, prevLine = 0;

        private void displayTrace()
        {

            string str;
#if (EXCEPTION)
            try
            {
#endif
                if ((bool)arrLevels[currentLevelIndex].EndofProg || !traceOn)
                {
                    lblTraceFirst.Text = "";
                    lblBlack.Text = "";
                    lblBlack.Visible = false;
                    lblTraceSecond.Text = "";
                }
                //				//Console.WriteLine("Entered display trace");
                //				//Console.WriteLine("iProgLen : " + iProgLen.ToString());
                //				//Console.WriteLine("tCurLine.iLength : " + tCurLine.iLength.ToString());

                if (traceOn && arrLevels[currentLevelIndex].iProgLen > 0 && arrLevels[currentLevelIndex].tCurLine.iLength - 1 > 0 && !(bool)arrLevels[currentLevelIndex].EndofProg)
                {
                    iEndIndexLT = arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].iEndIndexLT;
                    iStartIndexLT = arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].iStartIndexLT;
                    //				if(TraceX == tCurLine.iLength-1)
                    //					iStartIndexLT = iEndIndexLT = 0;
                    if (prevLine == 0 || prevLine != arrLevels[currentLevelIndex].tHState.curLine || arrLevels[currentLevelIndex].tHState.curLine == 0)
                    {
                        //getTextForLTFrame();
                        blnLineTraceStarted = true;
#if(MODULAR_INTERPRETER)
                        if (objHinterpreter != null)
                        {
                            objHinterpreter.SetBlnLineTraceStarted(blnLineTraceStarted);
                        }
#endif
                    }
                    //					if(iEndIndexLT <= TraceX-TraceWidth || TraceX == 0)
                    //					{				
                    //						////Console.WriteLine("if(iEndIndexLT <= TraceX) = " +iEndIndexLT+ " TraceX="+TraceX);
                    //						//iEndIndexLT = TraceX;
                    //						getIndexsToDispLT();
                    //						
                    //					}
                    if (CharNoLT == null)
                        getTextForLTFrame();
                    for (int z = 0; z < CharNoLT.Length - 1; z++)
                    {
                        if (TraceX >= CharNoLT[z] && TraceX <= CharNoLT[z + 1])
                        {
                            iStartIndexLT = CharNoLT[z];
                            iEndIndexLT = CharNoLT[z + 1] + 1;
                            break;
                        }
                    }
                    for (int k = 0; k < arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].frameCharNo.Length - 1; k++)
                    {
                        if (TraceX >= arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].frameCharNo[k] && TraceX <= arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].frameCharNo[k + 1])
                        {
                            if (iFrameLT != k)
                            {
                                ////Console.WriteLine("vinay");
                                if (traceOn)
                                    EditorTrace(arrLevels[currentLevelIndex].tCurLine.iLineNum);
                                break;
                            }
                        }
                    }
                    int iTraceX = TraceX - iStartIndexLT;
                    string txtstr = new string(arrLevels[currentLevelIndex].acCurrentLine, iStartIndexLT, iEndIndexLT - iStartIndexLT);
                    int iStartIndexLTTemp = 0;
                    int iEndIndexLTTemp = txtstr.Length;
                    //					str = new string(acCurrentLine,iStartIndexLT,iEndIndexLT);
                    //					lblLT.Text = str;
                    //					str = null;
                    ////Console.WriteLine("istart"+iStartIndexLT);
                    ////Console.WriteLine("iend" + iEndIndexLT);
                    //					if(lblLT.Width+WIDTHOFFSET <= lblLineTracing.Width)
                    //					{
#if (EXCEPTION)
                    try
                    {
#endif
                        ////Console.WriteLine("lblTraceFirst.text = new string("+acCurrentLine+","+iStartIndexLT+","+(TraceX-iStartIndexLT)); 
                        //str = new string(acCurrentLine,iStartIndexLT,TraceX-iStartIndexLT);	
                        lblTraceFirst.Text = "";
                        lblBlack.Text = "";
                        lblBlack.Visible = false;
                        lblTraceSecond.Text = "";
                        str = txtstr.Substring(iStartIndexLTTemp, iTraceX - iStartIndexLTTemp);
                        ////Console.WriteLine(str+":lblTraceFirst");
                        lblTraceFirst.Text = str;
                        ////Console.WriteLine(lblTraceFirst.Text);
                        str = null;
#if (EXCEPTION)
                    }
                    catch
                    {
                        //						//Console.WriteLine(exp.Message + ", lblTraceFirst.Text, 11");
                    }
#endif
                    if (TraceWidth != 0)
                    {
#if (EXCEPTION)
                        try
                        {
#endif
                            ////Console.WriteLine("lblBlack.text = new string("+acCurrentLine+","+(TraceX - iStartIndexLT)+","+TraceWidth);
                            //str = new string(acCurrentLine,TraceX - iStartIndexLT,TraceWidth);
                            //str = new string(acCurrentLine,TraceX, TraceWidth);

                            str = txtstr.Substring(iTraceX, TraceWidth);
                            ////Console.WriteLine(str+":lblBlack");
                            //							lblLT.Text = str;
                            //							if (lblTraceFirst.Width + lblLT.Width < lblLineTracing.Width)
                            //							{
                            lblBlack.Location = new Point(lblTraceFirst.Location.X + lblTraceFirst.Width - 1, lblTraceFirst.Location.Y - 1);
                            lblBlack.Text = str;
                            lblBlack.Visible = true;
                            //							}
                            str = null;
#if (EXCEPTION)
                        }
                        catch
                        {
                            //							//Console.WriteLine(e.Message + " txtstr.Lengh = "+ txtstr.Length.ToString() +" iTraceX = " + iTraceX.ToString() +"TraceWidth = "+TraceWidth.ToString()+ ", lblBlack.Text, 21");
                        }
#endif
                    }
                    else
                    {
                        lblBlack.Visible = false;
                    }
                    ////Console.WriteLine(new string(acCurrentLine,TraceX+TraceWidth,tCurLine.iLength-1));
                    if (!(bool)arrLevels[currentLevelIndex].EndofProg)
#if (EXCEPTION)
                        try
                        {
#endif
                            ////Console.WriteLine("lblTraceSecond.text = new string("+acCurrentLine+","+(TraceX+TraceWidth-iStartIndexLT)+","+(iEndIndexLT-TraceX-TraceWidth)); 	
                            if (iEndIndexLTTemp - iTraceX - TraceWidth > 0)
                            {
                                ////Console.WriteLine("iEndIndexLT-TraceX-TraceWidth-1<=0"+(iEndIndexLT-TraceX-TraceWidth));
                                //str = new string(acCurrentLine,TraceX+TraceWidth-iStartIndexLT,iEndIndexLT-TraceX-TraceWidth);
                                //str = new string(acCurrentLine,TraceX+TraceWidth,iEndIndexLT-TraceX-TraceWidth);
                                str = txtstr.Substring(iTraceX + TraceWidth, iEndIndexLTTemp - iTraceX - TraceWidth);
                                ////Console.WriteLine(str+":lblTraceSecond");

                                lblLT.Text = str.Trim();
                                //lblTraceSecond.Text = str.Trim();


                                int totalLineTraceWidth = lblTraceFirst.Width + lblBlack.Width + lblLT.Width;

                                if ((totalLineTraceWidth > lblLineTracing.Width) && (str.Length > 0))
                                {
                                    str = str.Remove(str.Length - 1, 1);
                                }

                                lblTraceSecond.Location = new Point(lblBlack.Location.X + lblBlack.Width - 1, lblTraceFirst.Location.Y);
                                lblTraceSecond.Text = str.Trim();
                                lblTraceSecond.Visible = true;

                                str = null;
                            }
                            else
                            {
                                lblTraceSecond.Text = "";
                                lblTraceSecond.Visible = false;
                            }
#if (EXCEPTION)
                        }
                        catch
                        {
                            //see this part this gives error of index out of reange.
                            //							//Console.WriteLine("lblTraceSecond.Text "+exp.Message);
                            lblTraceSecond.Visible = false;
                        }
#endif
                    //}
#if (EXCEPTION)
                    try
                    {
#endif
                        //						if(lblBlack.Location.X+lblBlack.Width < lblLineTracing.Location.X + lblLineTracing.Width)
                        //						{

                        ////Console.WriteLine(lblLineTracing.Width + " " + lblBlack.Width + " " + lblTraceFirst.Width);
                        //lblBlack.SuspendLayout();
                        //lblBlack.Location = new Point(lblTraceFirst.Location.X + lblTraceFirst.Width-1,lblTraceFirst.Location.Y-1);
                        //lblBlack.ResumeLayout(false);
                        //lblTraceSecond.SuspendLayout();
                        //lblTraceSecond.Location = new Point(lblBlack.Location.X + lblBlack.Width-2,lblTraceFirst.Location.Y);
                        //lblTraceSecond.ResumeLayout(false);
                        lblBlack.BringToFront();

                        //						}
                        //						else
                        //						{
                        ////							iStartIndexLT = iEndIndexLT;
                        ////							displayTrace();
                        //						}
#if (EXCEPTION)
                    }
                    catch
                    {
                        ////Console.WriteLine(e.Message + ", displayTrace, 31");
                    }
#endif
                    arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].iEndIndexLT = iEndIndexLT;
                    arrLevels[currentLevelIndex].atLineInfo[arrLevels[currentLevelIndex].tCurLine.iLineNum].iStartIndexLT = iStartIndexLT;
                }
                if (mnuTrace.Checked == false)
                {
                    lblLineTracing.Text = "";
                    lblTraceFirst.Text = "";
                    lblTraceSecond.Text = "";
                    lblBlack.Text = "";
                    lblBlack.Visible = false;
                }
#if (EXCEPTION)
            }
            catch (Exception exp)
            {
                ////Console.WriteLine(fe.Message + ", displayTrace, 41");
            }
#endif



        }

        bool blnLineTraceStarted = false;
        /// <summary>
        /// displays line tracing.
        /// </summary>

        //		private void displayTrace1()
        //		{
        //			
        //			string str;
        //#if (EXCEPTION)
        //			try
        //			{
        //#endif
        //				if((bool)EndofProg || !traceOn)
        //				{
        //					lblTraceFirst.Text = "";
        //					lblBlack.Text = "";
        //					lblTraceSecond.Text = "";
        //				}
        //				getTextForLTFrame();
        //				if(traceOn && iProgLen > 0 && tCurLine.iLength-1 > 0 && !(bool)EndofProg)
        //				{
        //					iEndIndexLT = atLineInfo[tCurLine.iLineNum].iEndIndexLT;
        //					iStartIndexLT = atLineInfo[tCurLine.iLineNum].iStartIndexLT;
        //					//				if(TraceX == tCurLine.iLength-1)
        //					//					iStartIndexLT = iEndIndexLT = 0;					
        //					if(iEndIndexLT <= TraceX-TraceWidth || TraceX == 0)
        //					{				
        //						////Console.WriteLine("if(iEndIndexLT <= TraceX) = " +iEndIndexLT+ " TraceX="+TraceX);
        //						//iEndIndexLT = TraceX;
        //						getIndexsToDispLT();
        //						blnLineTraceStarted = true;
        //					}
        //					for(int k = 0; k < atLineInfo[tCurLine.iLineNum].frameCharNo.Length-1; k++)
        //					{
        //						if(TraceX >= atLineInfo[tCurLine.iLineNum].frameCharNo[k] && TraceX <= atLineInfo[tCurLine.iLineNum].frameCharNo[k+1])
        //						{
        //							if(iFrameLT != k)
        //							{
        //								////Console.WriteLine("vinay");
        //								if(traceOn)
        //									EditorTrace(tCurLine.iLineNum);
        //								break;
        //							}
        //						}
        //					}
        //					//					str = new string(acCurrentLine,iStartIndexLT,iEndIndexLT);
        //					//					lblLT.Text = str;
        //					//					str = null;
        //					////Console.WriteLine("istart"+iStartIndexLT);
        //					////Console.WriteLine("iend" + iEndIndexLT);
        //					//					if(lblLT.Width+WIDTHOFFSET <= lblLineTracing.Width)
        //					//					{
        //#if (EXCEPTION)
        //					try
        //					{
        //#endif
        //						////Console.WriteLine("lblTraceFirst.text = new string("+acCurrentLine+","+iStartIndexLT+","+(TraceX-iStartIndexLT)); 
        //						str = new string(acCurrentLine,iStartIndexLT,TraceX-iStartIndexLT);				
        //						////Console.WriteLine(str+":lblTraceFirst");
        //						lblTraceFirst.Text = str;
        //						str = null;
        //#if (EXCEPTION)
        //					}
        //					catch
        //					{
        //						////Console.WriteLine(e.Message + ", lblTraceFirst.Text, 11");
        //					}
        //#endif
        //					if(TraceWidth != 0)
        //					{
        //						lblBlack.Visible = true;
        //#if (EXCEPTION)
        //						try
        //						{
        //#endif
        //							////Console.WriteLine("lblBlack.text = new string("+acCurrentLine+","+(TraceX - iStartIndexLT)+","+TraceWidth); 
        //							//str = new string(acCurrentLine,TraceX - iStartIndexLT,TraceWidth);
        //							str = new string(acCurrentLine,TraceX, TraceWidth);
        //							////Console.WriteLine(str+":lblBlack");
        //							lblBlack.Text = str;
        //							str = null;
        //#if (EXCEPTION)
        //						}
        //						catch
        //						{
        //							////Console.WriteLine(e.Message + ", lblBlack.Text, 21");
        //						}
        //#endif
        //					}
        //					else
        //					{
        //						lblBlack.Visible = false;
        //					}					
        //					////Console.WriteLine(new string(acCurrentLine,TraceX+TraceWidth,tCurLine.iLength-1));
        //					if(!(bool)EndofProg)
        //#if (EXCEPTION)
        //						try
        //						{
        //#endif
        //							////Console.WriteLine("lblTraceSecond.text = new string("+acCurrentLine+","+(TraceX+TraceWidth-iStartIndexLT)+","+(iEndIndexLT-TraceX-TraceWidth)); 	
        //							if(iEndIndexLT-TraceX-TraceWidth>=0)
        //							{
        //								////Console.WriteLine("iEndIndexLT-TraceX-TraceWidth-1<=0"+(iEndIndexLT-TraceX-TraceWidth));
        //								//str = new string(acCurrentLine,TraceX+TraceWidth-iStartIndexLT,iEndIndexLT-TraceX-TraceWidth);
        //								str = new string(acCurrentLine,TraceX+TraceWidth,iEndIndexLT-TraceX-TraceWidth);
        //								////Console.WriteLine(str+":lblTraceSecond");
        //								lblTraceSecond.Text = str;
        //								str = null;
        //							}
        //							else
        //								lblTraceSecond.Text = "";
        //#if (EXCEPTION)
        //						}
        //						catch
        //						{
        //							//see this part this gives error of index out of reange.
        //							////Console.WriteLine("lblTraceSecond.Text "+exp.Message);
        //						}
        //#endif
        //					//}
        //#if (EXCEPTION)
        //					try
        //					{
        //#endif
        //						//						if(lblBlack.Location.X+lblBlack.Width < lblLineTracing.Location.X + lblLineTracing.Width)
        //						//						{
        //										
        //						////Console.WriteLine(lblLineTracing.Width + " " + lblBlack.Width + " " + lblTraceFirst.Width);
        //						//lblBlack.SuspendLayout();
        //						lblBlack.Location = new Point(lblTraceFirst.Location.X + lblTraceFirst.Width-1,lblTraceFirst.Location.Y-1);
        //						//lblBlack.ResumeLayout(false);
        //						//lblTraceSecond.SuspendLayout();
        //						lblTraceSecond.Location = new Point(lblBlack.Location.X + lblBlack.Width-2,lblTraceFirst.Location.Y);
        //						//lblTraceSecond.ResumeLayout(false);
        //						lblBlack.BringToFront();
        //						
        //						//						}
        //						//						else
        //						//						{
        //						////							iStartIndexLT = iEndIndexLT;
        //						////							displayTrace();
        //						//						}
        //#if (EXCEPTION)
        //					}
        //					catch
        //					{
        //						////Console.WriteLine(e.Message + ", displayTrace, 31");
        //					}
        //#endif
        //					atLineInfo[tCurLine.iLineNum].iEndIndexLT = iEndIndexLT;
        //					atLineInfo[tCurLine.iLineNum].iStartIndexLT = iStartIndexLT;
        //				}		
        //#if (EXCEPTION)
        //			}
        //			catch
        //			{
        //				////Console.WriteLine(fe.Message + ", displayTrace, 41");
        //			}
        //#endif
        //			
        //		}


        /// <summary>
        /// variables that contains the boxes starting point as TraceX and top as TraceY and width of the 
        /// trace box.
        /// </summary>
        private int TraceX, TraceWidth;

        //TraceY=0,

        /// <summary>
        /// bool variable which says the box should be displayed or not.
        /// </summary>
        //
        //private bool displayBox = false;

        #endregion

        #region Other Events

        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
        }


        private static object objCompleteMonitor = new object();
        /// <summary>
        /// load method or herbert form.
        /// </summary>
        /// <param name="sender">object</param>
        /// <param name="e">System.EventArgs</param>
        private void HerbertMain_Load(object sender, System.EventArgs e)
        {
            try
            {
#if(PROBE)
            

                if (sbErrorLog == null)
                    sbErrorLog = new StringBuilder();
                //sbErrorLog.Append("IC2007 PROBE: In Herbert Main_Load :: Current Culture:" + CultureInfo.CurrentCulture.ToString() + "::TimeStamp:" + DateTime.Now);
                //WSLogErrors();
#endif
                //Added By: Rajesh 
                //Date: 4/7/06
                //comment: To make compatible for .net 2.0
                System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls = false;
                if (GlobalData.iShowSwtichContest == 0)
                {
                    menuSwitchContest.Visible = false;
                }
                //end
                //Get the Operating system information so that we can change the form size for windows XP
                string str = GetOperationSystemInformation();
                if (str.IndexOf("Windows XP") != -1)
                {
                    iFormHeight = iFormHeight + 9;
                }
#if(FT)
			this.MaximizeBox = true;
			pnlContainer.Location = new Point(0,0);
			this.Height = 375;
#endif
#if(MS10MAR)
                this.MaximizeBox = true;
                this.lblBlack.Visible = false;

                //this.Height = this.Height;
                //pnlToolBar.Visible = true;

#endif
#if(MS03MAR)
			pnlContainer.Location = new Point(0,0);
			//this.Height = 375-31;
			this.FormBorderStyle = FormBorderStyle.FixedSingle;
			this.MaximizeBox = false;
#endif
#if(TOOLBAR)
                /*==============================================================================
					*  Modified By : Vivek Balagangadharan
					*  Description : Locking the toolbar panel to avoid "object in use elsewhere" error.
					*  Modified On : 19-Apr-2006
					* ==============================================================================*/
                lock (pnlToolBar)
                {
                    if (!pnlToolBar.Visible)
                    {
                        pnlToolBar.Visible = true;
                    }
                }

                pnlContainer.Location = new Point(0, 32);
                this.Height = iFormHeight;
                this.MinimumSize = new Size(this.Width, this.Height);
#else
			pnlToolBar.Visible = false;
			pnlContainer.Location = new Point(0,0);
			this.Height = iFormHeight-31;
			this.MinimumSize = new Size(this.Width, this.Height);
			this.mnuToolBar.Visible = false;
#endif
                oldWidth = this.Width;
                oldHeight = this.Height;
                arrLevels = new Level[1];
                arrLevels[0] = new Level(0);
                //strCLRVersion = Environment.Version.ToString();			
                if (GlobalData.HerbertMode != HMode.Tutorial)
                {

                    //				lock(txtCodeEditor)
                    //				{
                    txtCodeEditor.ReadOnly = true;
                    //				}
                    lblLoading.Visible = true;
#if(CONTEST)
                    btRestore.Enabled = false; // to disable Restore button while loading data - added by Nikhil Kardale
                    mnuSeperator2Edit.Enabled = false;
                    mnuRestoreBest.Enabled = false;
                    mnuMainDesign.Visible = false;
#endif
                    lblLoading.Location = new Point(this.Width / 2 - lblLoading.Width / 2, this.Height / 2 - lblLoading.Height / 2);

                }
                else
                {
                    lblLoading.Visible = false;
#if(CONTEST)
                    // added by NikhilK on 07/01/2008 to fix issue id. 3230
                    lblLevelSolved.Visible = false;
#endif
                }
                //			else
                //				pbStartUp.Visible = false;


                //Vijay, debugging
# if(DESIGNER)
			//add preprocessor
			//if(GlobalData.HerbertMode == HMode.Designer)
			//TxtLevelPoints.Text = Level.getLevelPoints(currentLevelIndex).ToString();

            // added by Nikhil Kardale to avoid displaying 'Solved - Unsolved' message for the zeroth level at the time of loading
            if (lblLevelNo.Text == "0")
            {
                lblLevelSolved.Visible = false;
            }
            else
            {
                lblLevelSolved.Visible = true;
            }

			txtLevelPoints.Enabled = false;
            this.lblMsgBox.Top = 268;
            this.lblMsgBox.Left = 236;
# endif

# if(DESIGNER)
			if(GlobalData.HerbertMode == HMode.Designer)
			{
				//lblMsgBox.Location = new Point(130,268);
				//lblMsgBox.Width = LevelChangeBar.Location.X-3 + LevelChangeBar.Width-130;
			}
			else
			{
# endif
                lblMsgBox.Location = new Point(3, 268);
#if(CONTEST)
#else
                lblMsgBox.Width = LevelChangeBar.Location.X - 3 + LevelChangeBar.Width;
#endif
# if(DESIGNER)
			}
# endif
# if(DESIGNER)
			//			TxtLevelPoints.Visible = false;
			//			lblLevelPoints.Visible = false;
#endif
                lblBytesUsed.Text = "0";
                lblLevelNo.Text = "0";
                //if (lblLevelNo.Text == "0")
                //{
                //    lblLevelSolved.Visible = false;
                //}
                lblTotalLevels.Text = "0";
                lblTotalLevels.Left = lblLevelsTxt.Left - lblTotalLevels.Width;
                LevelChangeBar.Enabled = false;

                DialogResult YesNoLoad = DialogResult.Yes;
                string helpPath = "";
                try
                {
                    helpPath = System.Configuration.ConfigurationSettings.AppSettings.Get("HelpPath");
                }
                catch
                {
                    //helpPath = "http://www.wildnoodle.com/help";
                    helpPath = "http://localhost/help";
                }

                try
                {
                    IDataObject iData = Clipboard.GetDataObject();
                }
                catch
                {
                    mnuTxtPaste.Enabled = false;
                    if (btPaste.Visible)
                        btPaste.Enabled = false;
                    YesNoLoad = MessageBox.Show(this, "Your current security settings will not allow you to use all of the functionality in Herbert.\nIn particular, the following feature(s) will be disabled:\n- Paste operation using Edit menu and paste button.\n\nFor more details, please see help section of our website at " + helpPath + ".\nDo you want to continue with these features disabled?", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
                    helpPath = null;
                }
                if (YesNoLoad == DialogResult.No)
                {
                    blnLoadError = true;
                    this.Close();
                    return;
                }
#if(CONTEST)
                // added by Nikhil Kardale on 4/7/2007 to make timer invisible while loading data (to fix issue no. 7803)
                lblTimer.Visible = false;
                lblTimeLeft.Visible = false;
#endif
                lblMsgBox.Width = 495;
                if (GlobalData.HerbertMode == HMode.Tutorial)
                    loadData();
                else
                {
                    //load data for levels and game score data.
                    //GameTimer.Enabled = true;
                    LevelTimer.Enabled = true;
                    Thread t = new Thread(new ThreadStart(loadData));
                    t.Name = "Load Data (" + DateTime.Now.ToShortTimeString() + ")";
                    t.Priority = ThreadPriority.Lowest;
                    t.Start();
                }
            }
            catch (Exception Exp)
            {
#if(DEBUG)
                MessageBox.Show(this, "ICHerbert Probe Message: " + Exp.Message + "\n Stackstrace:" + Exp.StackTrace + "\nInnerException: " + Exp.InnerException + "\n ", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
#endif
#if(PROBE)
                 MessageBox.Show(this, "ICHerebrt Probe Message: " + Exp.Message +"\n Stackstrace:" + Exp.StackTrace+"\nInnerException: "+ Exp.InnerException+"\n ", "Herbert - Information", MessageBoxButtons.YesNo, MessageBoxIcon.Information);
#endif
            }

        }

        /// <summary>
        /// Added By rajeshc 24/04/07 , To handle the PAgeup an Page down events
        /// </summary>
        /// <param name="n">Level no </param>
        private void HerbertMain_ScrollToLevel(int n)
        {
            int cI = (LevelChangeBar.Maximum - LevelChangeBar.Minimum) / LevelChangeBar.SmallChange;

            ScrollEventArgs e = new ScrollEventArgs(ScrollEventType.EndScroll, 0);
            //Added By Rajesh 04/07/2007 for issue 7810
            if (((n + 1) * LevelChangeBar.SmallChange) > LevelChangeBar.Maximum)
            {
                n = (LevelChangeBar.Maximum / LevelChangeBar.SmallChange) - 1;
            }

            e = new ScrollEventArgs(ScrollEventType.EndScroll, n * LevelChangeBar.SmallChange);


            this.LevelChangeBar_Scroll(this.LevelChangeBar, e);
            this.LevelChangeBar.Value = n * LevelChangeBar.SmallChange;
        }

        /// <summary>
        /// this event is raised when application is closing.
        /// </summary>
        /// <param name="sender">Sender which raised this event.</param>
        /// <param name="e">Event Arg which allows to cancel the closing.</param>
        private void HerbertMain_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            //check if time is not over means user initiated the application.
#if(CONTEST)
            if (isSiteDefaultUserId != 1)
            {
#endif
#if(DESIGNER)
            if(GlobalData.HerbertMode==HMode.Designer)
			{
#endif
                if (!blnUploadingSolutions)
                {
                    if (!blnLoadError && dataLoaded)
                    {
                        if (GlobalData.HerbertMode == HMode.Tutorial)
                        {
                            //vijay
                            killThread();
                            //progClosing = true;
                        }
#if(DESIGNER)
					else if(GlobalData.HerbertMode == HMode.Designer && blnIsValid)
					{
							///Added   by Rajesh
							///comment to stop Designer from Designing expired contest 
							///Date    7/4/2006 
							if(TimeOver)
							{
								//save data to database
                                MessageBox.Show(this, "Sorry! You are out of time for this contest. The application will now close.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);                               
                                GlobalData.isContestFinished = true;
								//this.Close();
							}
								///end
							else 
							{
								GlobalData.isContestFinished = false;
                                if(arrLevels[currentLevelIndex].IsLevelChanged)
								{
                                    // DialogResult present previously removed by Nikhil Kardale on 19/03/2008 to resolve issue id. 10902
                                    GlobalData.IsDesignerClosed = true;
								    mnuSaveLevel_Click(null,null);
								    if(!isCurrentLevelSaved)
								    {
									    e.Cancel = true;
									    return;
								    }
								}
								else
								{
                                    GlobalData.IsDesignerClosed = false;
                                    System.Windows.Forms.DialogResult YesQuit = System.Windows.Forms.DialogResult.Yes; ;
                                    if (!GlobalData.IsShowContestList)
                                    {
                                        YesQuit = MessageBox.Show(this, "Do you want to close the designer?", "Herbert - Warning", System.Windows.Forms.MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                                    }                                    
									if(YesQuit == System.Windows.Forms.DialogResult.No)
									{
										e.Cancel = true;
										return;
									}
									else
									{
										//vijay
										//MessageBox.Show(this,GlobalData.userId.ToString());
										NullGuid();
										killThread();
										//progClosing = true;
										//vijay, check for unsaved data
										return;
									}
								}
							}
					}
#endif
                        else if (GlobalData.HerbertMode == HMode.Contest)
                        {
                            if (blnIsValid)
                            {
                                if (TimeOver)
                                {
                                    GlobalData.isContestFinished = true;
                                    //save data to database

                                    

                                    MessageBox.Show(this, "Sorry! You are out of time for this contest - 19045. The application will now close.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                }
                                else
                                {
                                    GlobalData.isContestFinished = false;
                                }
                                /*if(MaintenanceStarted)
                                {
                                    //changes for polling and messages from database.
                                    MessageBox.Show(this,"Sorry! Maintenance work has started. The application will now close.","Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                }*/


                                LevelTimer.Enabled = false;
                                //vijay
                                killThread();
                                //progClosing = true;
                                //Vijay, debugging

                                if (arrLevels[currentLevelIndex].goClicked)
                                    HaltHrbt_Click(null, null);
                                YesNoCancel = System.Windows.Forms.DialogResult.Yes;
                                if (!blnAfterTimeOver)

# if(CONTEST)
#if(SESSIONMAGEMENT)
                                    //Check added By Rajesh to check if the contest is closed.
                                    if (GlobalData.IsLoadFromFile)
                                    {
                                        HerbertBoard.Refresh();
                                        tPolling = new Thread(new ThreadStart(PoolForMaintData));
                                        tPolling.Name = "Message Polling (" + DateTime.Now.ToShortTimeString() + ")";
                                        tPolling.Priority = ThreadPriority.Highest;
                                        tPolling.Start();
                                        tPolling.Join();
                                        if (GameInterval <= 0)
                                        {
                                            MessageBox.Show(this, "Sorry! You are out of time for this contest. The application will now close.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                            GlobalData.GUID = null;//Not to allow to save the data in the db for savedataindb()
                                            blnUploadingSolutions = false;
                                            GlobalData.IsShowContestList = false;
                                            GlobalData.isContestFinished = true;
                                        }
                                        else
                                        {
                                            GlobalData.isContestFinished = false;
                                            if (GlobalData.GUID != null)
                                                SaveDataInDB();
                                        }
                                    }
                                    else

#endif
                                        if (GlobalData.GUID != null)
                                            SaveDataInDB();
#endif

                                if (YesNoCancel == System.Windows.Forms.DialogResult.Cancel)
                                {
                                    if (TimeOver)
                                    {
                                        //save data to database
                                        MessageBox.Show(this, "Sorry! You are out of time for this contest. The application will now close.", "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                        GlobalData.isContestFinished = true;
                                        YesNoCancel = System.Windows.Forms.DialogResult.Yes;
# if(CONTEST)
                                        if (!blnAfterTimeOver)
                                            if (GlobalData.GUID != null)
                                            {
                                                SaveDataInDB();
                                            }
#endif
                                    }
                                    else
                                    {
                                        GlobalData.isContestFinished = false;
                                        //GameTimer.Enabled = true;
                                        LevelTimer.Enabled = true;
                                        e.Cancel = true;
                                        if (arrLevels[currentLevelIndex].goClicked || arrLevels[currentLevelIndex].stepByStep)
                                        {
                                            mnuHaltHrbt.Enabled = false;
                                            arrLevels[currentLevelIndex].blnHaltState = false;
                                            mnuGoHrbt.Enabled = true;
                                            arrLevels[currentLevelIndex].blnGoState = true;
                                            mnuStepHrbt.Enabled = true;
                                            arrLevels[currentLevelIndex].blnStepState = true;
                                            mnuResetHerbt.Enabled = true;
                                            arrLevels[currentLevelIndex].blnResetState = true;
                                            mnuResumeHrtb.Enabled = true;
                                            arrLevels[currentLevelIndex].blnResumeState = true;
                                        }
                                        else
                                            IniOrResetRunMenu();
                                        return;
                                    }
                                }
                            }
                            else
                                MessageBox.Show(this, "Please wait. Another instance of Herbert is still loading.", "Herbert - Error", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                        }
                    }
                    else if (!blnLoadError && !dataLoaded)
                    {
                        blnCloseInitiated = true;
                        lblLoading.Text = "Closing Herbert...";
                        e.Cancel = true;
                        return;
                    }
                }
                else
                {
                    e.Cancel = true;
                    return;
                }
            }
            killThreadNoWait();
        }


        /// <summary>
        /// paint event of herbert main form to draw the side bar 
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void HerbertMain_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
#if(FT)
			Graphics hg = e.Graphics;
			hg.Clear(this.pnlToolBar.BackColor);
			Pen BlackPen = new Pen(Color.Black,2);
#if(TOOLBAR)
			hg.DrawLine(BlackPen,0,31,this.Width,31);
#endif
			BlackPen = new Pen(Color.Black, 5);
			hg.DrawLine(BlackPen,pnlContainer.Location.X+pnlContainer.Width+1,pnlContainer.Location.Y+3,pnlContainer.Location.X+pnlContainer.Width+1,pnlContainer.Location.Y+pnlContainer.Height+4);
			hg.DrawLine(BlackPen,pnlContainer.Location.X+1,pnlContainer.Location.Y+pnlContainer.Height+1,pnlContainer.Location.X+pnlContainer.Width,pnlContainer.Location.Y+pnlContainer.Height+1);
			BlackPen.Dispose();
			hg.Dispose();
			BlackPen = null;
			hg = null;
#endif
            int debugLineCounter = 0;

#if(MS10MAR)
            try
            {
                Graphics hg = e.Graphics;
                hg.Clear(this.pnlToolBar.BackColor);
                debugLineCounter++; //1

                Pen BlackPen;
                if (mnuToolBar.Checked)
                {
                    BlackPen = new Pen(Color.Black, 2);
                    hg.DrawLine(BlackPen, 0, 31, this.Width + 2, 31);
                }
                debugLineCounter++; //2

                BlackPen = new Pen(Color.Black, 4);
                hg.DrawLine(BlackPen, pnlContainer.Location.X + pnlContainer.Width + 1, pnlContainer.Location.Y + 1, pnlContainer.Location.X + pnlContainer.Width + 1, pnlContainer.Location.Y + pnlContainer.Height + 3);
                debugLineCounter++; //3

                hg.DrawLine(BlackPen, pnlContainer.Location.X + 1, pnlContainer.Location.Y + pnlContainer.Height + 1, pnlContainer.Location.X + pnlContainer.Width, pnlContainer.Location.Y + pnlContainer.Height + 1);
                debugLineCounter++; //4

                BlackPen.Dispose();
                hg.Dispose();
                BlackPen = null;
                hg = null;
                debugLineCounter++; //5
            }
            catch (Exception exp)
            {
                if (isExceptionLogged)
                {
                    try
                    {
                        sbErrorLog.Append("\n Exception in HerbertMain_Paint");
                        sbErrorLog.Append("\n Exception Message: " + exp.Message);
                        sbErrorLog.Append("\n Stack Trace: " + exp.StackTrace);
                        sbErrorLog.Append("\n Inner Exception: " + exp.InnerException.ToString());
                        sbErrorLog.Append("\n LineCounter: " + debugLineCounter.ToString());
                        LogErrors();
                    }
                    catch
                    {
                    }
                }
            }
#endif
        }


        /// <summary>
        /// keeps the total char count as per the herbert char count.
        /// </summary>
        private int iCharCount = 0;

        /// <summary>
        /// temporary string which keeps the text of text code editor.
        /// </summary>
        private string txtcode = "";

        /// <summary>
        /// this even is used to reset herbert if text is changed.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void txtCodeEditor_TextChanged(object sender, System.EventArgs e)
        {
            //Thread th = new Thread(new ThreadStart(deSelectError));
            //th.Start();
            //calculate the bytes used and display it on text change of editor.

            if (!blnSmoothScroll)
            {
                iCharCount = CountChars(txtCodeEditor.Text);
                lblBytesUsed.Text = iCharCount.ToString();
            }

#if(DESIGNER)
			if(!errorShown && !isLevelChanging)
			{
				arrLevels[currentLevelIndex].IsLevelChanged = true;
				arrLevels[currentLevelIndex].IsLevelRun = false;
				arrLevels[currentLevelIndex].isLevelSolutionValid = false;
			}
#endif
            //if text is changed in code editor than reset the herbert.
            //deSelectError();
            int iProgLenTemp = 0;

            lock (txtCodeEditor)
            {
                iProgLenTemp = (txtCodeEditor.Text.Replace("\r", "")).Length;
            }
            if ((arrLevels[currentLevelIndex].iProgLen != iProgLenTemp) && !arrLevels[currentLevelIndex].blnHReset && !errorShown && !blnSmoothScroll)
            {
                if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg)
                    ResetHerbtMenu_Click(null, null);
            }
#if(DESIGNER)
			//indicates that the level scroll is over
			///Rajesh
			
				mnuSaveLevel.Enabled=true;
			///end

			
#endif
            //txtCodeEditor.Font = PanalTxtCodeEdit.Font;
        }


        /// <summary>
        /// function is not used in web based herbert.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void txtCodeEditor_KeyDown(object sender, System.Windows.Forms.KeyEventArgs e)
        {

            if (!arrLevels[currentLevelIndex].syntaxCheck || !arrLevels[currentLevelIndex].checkSyntaxGo || blnSystemError)
            {
                if (!e.Control)
                    deSelectError();
                ResetHerbtMenu_Click(null, null);
            }
            if (e.Control && e.KeyCode == Keys.A)
            {
                txtCodeEditor.SelectAll();
            }
            //Code to Handle the Pageup and Page Down Events
            switch (e.KeyCode)
            {
                case Keys.PageDown:
                    int iLevelno = currentLevelIndex;
                    LevelsPagingDown(iLevelno);
                    break;
                case Keys.PageUp:
                    iLevelno = currentLevelIndex;
                    LevelsPagingUp(iLevelno);
                    break;
            }
        }


        /// <summary>
        /// set a bool variable to true to indicate herbert thread that 
        /// paint is complete.
        /// </summary>
        /// <param name="sender">object</param>
        /// <param name="e">System.Windows.Forms.PaintEventArgs</param>
        private void herbertPicBox_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
#if (EXCEPTION)
            try
            {
#endif
                hrbtRedrawn = true;
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(e1.Message + ", herbertPicBox_Paint, 11");
            }
#endif
        }


        /// <summary>
        /// event fired on menu GO click.
        /// </summary>
        /// <param name="sender">object</param>
        /// <param name="e">System.EventArgs</param>
        private void btGo_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
#endif
            //deSelectError();
            killThread();
#if(DESIGNER)
//			if(GlobalData.HerbertMode == HMode.Designer)
//			{
//				if(txtLevelPoints.Text.Trim() == "")
//				{
//					SendKeys.
//				}
//			}
			if(GlobalData.HerbertMode == HMode.Designer)
			{
				///Added by Rajesh To handle Delete key event.
				///end
				try
				{
					lvlpoints = int.Parse(txtLevelPoints.Text);
				}
				catch
				{
					lvlpoints=0;
				}
				txtLevelPoints.ReadOnly = true;
				txtLevelPoints.Text = lvlpoints.ToString();
				txtLevelPoints.ReadOnly = false;
			}
			if(GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate)
			{
				
				arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelIndex);
				
				if(currentLevelId == 0)
					lock(txtCodeEditor)
					{
						arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
					}
			}
#endif
            //Level.temp_levelTimer = arrLevels[currentLevelIndex].timeSpent;
            hrbtRedrawn = true;
            arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
            if (!arrLevels[currentLevelIndex].blnHReset)
                resetHerbert();
            //<10/03/05>
            arrLevels[currentLevelIndex].CurDir = 0;
            herbertState = 0;
            getImages();
            if (currentLevelId > 0)
# if(CONTEST)
                InitialOrResetHrbt = arrLevels[currentLevelIndex].getRoboXY(currentLevelId);
#endif
# if(DESIGNER)
				InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
#endif
            else
            {
#if (DESIGNER)
				if(GlobalData.HerbertMode == HMode.Designer)
				{
					//InitialOrResetHrbt = Level.getRoboPos();
					InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
				}
				else
				{
#endif
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                    InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                else
                    InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
#if (DESIGNER)
				}
#endif
            }

            //lock(this.herbertPicBox)
            {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                //lock(arrHrbtImage[0])
                {
#if (INVOKER)

                    if (this.herbertPicBox.InvokeRequired)
                    {
                        if (herbtSpeed == 0)
                            lock (imgForPicBox)
                            {
                                imgForPicBox = arrHrbtImage[0];
                            }
                        else
                            imgForPicBox = arrHrbtImage[0];
                        this.herbertPicBox.Invoke(mi);
                        /////Console.WriteLine("Invoking....");
                    }
                    else
                    {
#endif
                        this.herbertPicBox.Image = arrHrbtImage[0];
#if (INVOKER)
                    }

                    //this.herbertPicBox.Image = arrHrbtImage[0];

#endif
                }
                //herbertPicBox.Invalidate();
                //Application.DoEvents();
#endif
            }
            //resets the herbert's position variables like prePos$, destPos$ etc.
            arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut;
            arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut;
            arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
            arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
#if (EXCEPTION)
            try
            {
#endif
                //lock(this.herbertPicBox)
                {
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                        if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                        {
                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                        }
                        else
                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                    else
                        herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                }
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(exp.Message + ", resetHerbert, 11");
            }
#endif
            //</10/03/05>
            arrLevels[currentLevelIndex].tHState.Flags = 0;
            arrLevels[currentLevelIndex].tHState.CurrentOp = ' ';
            arrLevels[currentLevelIndex].tHState.curLine = 0;
            arrLevels[currentLevelIndex].tHState.PC = 0;
            arrLevels[currentLevelIndex].tCurLine.iFirstCmd = 0;
            arrLevels[currentLevelIndex].tCurLine.iLength = 0;
            arrLevels[currentLevelIndex].tCurLine.iLineNum = 0;
            //atLineInfo = new AtLineInfoStruct[MAXLINES];
            arrLevels[currentLevelIndex].aiStack = new int[STACKSIZE];
            //09/03/05
            /*reset all status variables to appropriate values.*/
            arrLevels[currentLevelIndex].blnHReset = false;
            arrLevels[currentLevelIndex].goClicked = true;
            arrLevels[currentLevelIndex].iSP = 0;
            arrLevels[currentLevelIndex].stackInitialisationCounter = 0;

            if (arrLevels[currentLevelIndex].blnRorLStep)
            {
                arrLevels[currentLevelIndex].blnRorLStep = false;
                //Command = StepCharRorL.ToString().ToUpper();
            }

            //Added by Vivek Balagangadharan
            // Description : Added to solve the issue 1427 
            // Added On : 26-Aug-2005
            arrLevels[currentLevelIndex].blnFirstStepClick = true;

            /*set menu enable or disable acording to need.*/
            arrLevels[currentLevelIndex].stepByStep = false;

            mnuStepHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnStepState = false;
            btStep.Enabled = false;
            mnuResumeHrtb.Enabled = false;
            arrLevels[currentLevelIndex].blnResumeState = false;
            mnuGoHrbt.Enabled = false;
            arrLevels[currentLevelIndex].blnGoState = false;
            mnuHaltHrbt.Enabled = true;
            arrLevels[currentLevelIndex].blnHaltState = true;
            /*assign number of chars used at this level to level Class*/
            arrLevels[currentLevelIndex].charused = CountChars(txtCodeEditor.Text);
            //if(!arrLevels[currentLevelId].IsLevelFinished)
#if(CONTEST)
            DisableRestore();
#endif
            lock (txtCodeEditor)
            {
                arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
            }
            DispMessage("");
            arrLevels[currentLevelIndex].tHState.Flags |= HFSSTEP;
            arrLevels[currentLevelIndex].tHState.Flags &= ~HFSTEPD;
            /*get program length*/
            //char a = '\r';
            TrimTextData();
            lock (txtCodeEditor)
            {
                /*get program as char array. by removing the extra char for enter in simple text box.*/
                arrLevels[currentLevelIndex].pcProg = txtCodeEditor.Text.Replace("\r", "").ToCharArray();
                //iProgLen = txtCodeEditor.Text.Length;
                arrLevels[currentLevelIndex].iProgLen = arrLevels[currentLevelIndex].pcProg.Length;
            }
            //check syntax if valid then start thread.
            getTextData();
            txtCodeEditor.Visible = true;
            //txtCodeEditor.Text = arrLevels[currentLevelIndex].iCurrentProgram;
#if(MODULAR_INTERPRETER)

            CallInterpreter();
            arrLevels[currentLevelIndex].checkSyntaxGo = objHinterpreter.CheckSyntax();
            //arrLevels[currentLevelIndex].checkSyntaxGo = CheckSyntax();

#else
			arrLevels[currentLevelIndex].checkSyntaxGo = CheckSyntax();
#endif
#if(DESIGNER)
			arrLevels[currentLevelIndex].IsLevelFinished = false;
			arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;
#endif
            if (arrLevels[currentLevelIndex].checkSyntaxGo)
            {
                if (mnuTrace.Checked)
                {
                    SetupEditorTrace(0);
                    lock (txtCodeEditor)
                    {
                        txtCodeEditor.Visible = false;
                    }
                    PanalTxtCodeEdit.Invalidate();
                }
#if(DESIGNER)

				/*==============================================================================
					 *  Added By : Vivek Balagangadharan
					 *  Description : Added to make sure that the level is run before saving a level design
					 *  Added On : 14-Apr-2006
					 * ==============================================================================*/
				if(GlobalData.HerbertMode == HMode.Designer)
				{
					arrLevels[currentLevelIndex].IsLevelRun = true;
				}
				/* End */
#endif
                startThread();
            }
        }


        /// <summary>
        /// event is raised when halt button is clicked.
        /// </summary>
        /// <param name="sender">object</param>
        /// <param name="e">System.EventArgs</param>		
        private void btHalt_Click(object sender, System.EventArgs e)
        {
            //progClosing = true;
            killThread();
            //Thread.Sleep(300);
        }


        /// <summary>
        /// event is raised when exit menu is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ExitMenu_Click(object sender, System.EventArgs e)
        {
            this.Close();
        }


        /// <summary>
        /// this event is raised when Go menu is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void RunHerbtMenu_Click(object sender, System.EventArgs e)
        {
#if(PATTERN_GENERATER)
            if (GlobalData.iPatternId != "-1" || arrLevels[currentLevelIndex].IsPatternEnabled)
            {
                try
                {
                    arrLevels[currentLevelIndex].IsPatternEnabled = false;
                    this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                    btShowPattern.FlatStyle = FlatStyle.Standard;
                    // addded by Nikhil Kardale on 20/03/2008 to resolve issue id. 10904
                    mnuShowPattern.Checked = false;
                    mnuShowPattern.Text = "Show Pattern";
                    arrLevels[currentLevelIndex].drawLevel(Level.GetLevelId(currentLevelIndex));
                    arrLevels[currentLevelIndex].IsValidPatternImage = false;
                }
                catch { }
            }
#endif
#if(CONTEST)
            DisableRestore();
#endif
            if (arrLevels[currentLevelIndex].blnGoState)
            {
#if(DESIGNER)
                txtLevelPoints.Enabled = false;               
#endif
                DisableMenu();
                arrLevels[currentLevelIndex].stepByStep = false;
                arrLevels[currentLevelIndex].iTotalGos++;
                arrLevels[currentLevelIndex].iLastVisits = arrLevels[currentLevelIndex].pNumVisits;
                arrLevels[currentLevelIndex].iLastBytes = CountChars(txtCodeEditor.Text);
                arrLevels[currentLevelIndex].iLastCharsTyped = arrLevels[currentLevelIndex].iTotalCharsTyped;
                arrLevels[currentLevelIndex].iLastGos = arrLevels[currentLevelIndex].iTotalGos;
                arrLevels[currentLevelIndex].iLastProgram = txtCodeEditor.Text;
                arrLevels[currentLevelIndex].iLastTimeSpent = arrLevels[currentLevelIndex].iTotalTimeSpent;
                arrLevels[currentLevelIndex].iLastDate = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);
#if(DESIGNER)
				lblLevelSolved.Text = "(Unsolved)";		
#endif
                btGo_Click(this, null);
#if(CONTEST)
                DisableRestore();
#endif
                mnuGoHrbt.Enabled = false;
                arrLevels[currentLevelIndex].blnGoState = false;
                if (arrLevels[currentLevelIndex].checkSyntaxGo)
                {
                    btGoPause.Enabled = true;
                    btGoPause.Image = pbPause.Image;
                    this.hTooltip.SetToolTip(this.btGoPause, "Pause");
                    mnuHaltHrbt.Enabled = true;
                    arrLevels[currentLevelIndex].blnHaltState = true;
                    arrLevels[currentLevelIndex].goPauseState = 1;
                }
                btStep.Enabled = false;
                btStop.Enabled = true;
                mnuResetHerbt.Enabled = true;
#if(DESIGNER)
				mnuMainDesign.Enabled = false;
#endif


# if(DESIGNER)

				///Added By Rajesh To disable Board if design menu is disable.
				///end 
				HerbertBoard.Enabled=false;
				txtLevelPoints.ReadOnly = true;

///commented by Rajesh
///To Maintain Designer menu state: 
//				mnuWhitebttn.Checked = false;
//				mnuWallRight.Checked = false;
//				mnuWallDown.Checked = false;
//				mnuWallDown.Checked = false;
//				mnuHerbie.Checked = false;
///end
#endif
                arrLevels[currentLevelIndex].blnResetState = true;
            }
        }


        /// <summary>
        /// this event is raised when about menu is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuAboutHerbert_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            MessageBox.Show(this, "Herbert " + Application.ProductVersion + "\n\nCopyright (c) 2005-"+ DateTime.Now.Year.ToString() +" Wild Noodle\nhttp://www.wildnoodle.com", "About Herbert", MessageBoxButtons.OK, MessageBoxIcon.Information);
#endif
#if(DESIGNER)
            MessageBox.Show(this, "Designer " + Application.ProductVersion + "\n\nCopyright (c) 2005-"+ DateTime.Now.Year.ToString() +" Wild Noodle\nhttp://www.wildnoodle.com", "About Designer", MessageBoxButtons.OK, MessageBoxIcon.Information);
#endif
        }


        /// <summary>
        /// paint event of herbert board.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void HerbertBoard_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            Graphics gHrbtBoard = e.Graphics;

#if (EXCEPTION)
            try
            {
#endif
                lock (arrLevels[currentLevelIndex].LevelImg)
                {
                    gHrbtBoard.DrawImage(arrLevels[currentLevelIndex].LevelImg, 0, 0);
                }

                hrbtBoardRedrawn = true;
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(exp1.Message + ", HerbertBoard_Paint, 13");
            }
#endif
# if(DESIGNER)
			if(drawWall)
			{
				Pen BlackPen = new Pen(System.Drawing.Brushes.Black,3);
				BlackPen.Width = 2+GlobalData.ZoomInZoomOut;
				if(GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
				{
					if(mnuWallDown.Checked)
					{						
						gHrbtBoard.DrawLine(BlackPen,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY2*HConstants.DOTSPACE+HOFFSET+3);
					}
					else if(mnuWallRight.Checked)
					{
						gHrbtBoard.DrawLine(BlackPen,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3,iLineX2*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3);
					}
				}
				else
				{
					if(mnuWallDown.Checked)
					{						
						gHrbtBoard.DrawLine(BlackPen,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineY2*HConstants.DOTSPACE+HOFFSET+3)+2);
					}
					else if(mnuWallRight.Checked)
					{
						gHrbtBoard.DrawLine(BlackPen,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineX2*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3));
					}
				}
				BlackPen.Dispose();
				BlackPen = null;					
			}
			//			if(eraseWall)
			//			{
			//				Pen WhitePen = new Pen(System.Drawing.Brushes.Black,3);
			//				WhitePen.Width = 2+GlobalData.ZoomInZoomOut;
			//				if(GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
			//				{
			//					if(mnuWallDown.Checked)
			//					{						
			//						gHrbtBoard.DrawLine(WhitePen,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY2*HConstants.DOTSPACE+HOFFSET+3);
			//					}
			//					else if(mnuWallRight.Checked)
			//					{
			//						gHrbtBoard.DrawLine(WhitePen,iLineX1*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3,iLineX2*HConstants.DOTSPACE+HOFFSET+3,iLineY1*HConstants.DOTSPACE+HOFFSET+3);
			//					}
			//				}
			//				else
			//				{
			//					if(mnuWallDown.Checked)
			//					{						
			//						gHrbtBoard.DrawLine(WhitePen,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineY2*HConstants.DOTSPACE+HOFFSET+3)+2);
			//					}
			//					else if(mnuWallRight.Checked)
			//					{
			//						gHrbtBoard.DrawLine(WhitePen,2*(iLineX1*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3),2*(iLineX2*HConstants.DOTSPACE+HOFFSET+3)+1,2*(iLineY1*HConstants.DOTSPACE+HOFFSET+3));
			//					}
			//				}
			//				WhitePen.Dispose();
			//				WhitePen = null;					
			//			}
#endif
        }


        /// <summary>
        /// paint event of PanalTxtCodeEdit
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void PanalTxtCodeEdit_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
#if (EXCEPTION)
            try
            {
#endif
                if (traceOn)
                {
                    Graphics gPTCE = e.Graphics;
                    Pen BlackPen = new Pen(Color.Black, 1);
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                        gPTCE.DrawImage(EditorImg, 0, 0, 329, 390);
                    else
                        gPTCE.DrawImage(EditorImg, 0, 0, 248, 184);
                    gPTCE.DrawRectangle(BlackPen, lineX, lineY, lineWidth, LineHeight);

                    BlackPen.Dispose();
                    gPTCE.Dispose();
                    BlackPen = null;
                    gPTCE = null;
                }
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(fe.Message + ", PanalTxtCodeEdit_Paint, 11");
            }
#endif
        }


        /// <summary>
        /// this event is raised when speedbar is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void SpeedBar_ValueChanged(object sender, System.EventArgs e)
        {
            //herbtSpeed = (1000 - SpeedBar.Value*10);
            herbtSpeed = (1000 - SpeedBar.Value * 10);
            //if herbert's sleep time is less than 3 than make it to 5 to avoide 
            //error relate to "Object is currently in use elsewhere."
            if (herbtSpeed < 100 && herbtSpeed != 0)
                herbtSpeed = herbtSpeed - (100 - SpeedBar.Value) * 5;
            //suggest by vijay on 20060221
            //			if(herbtSpeed < 2)
            //				herbtSpeed = 4;

#if(MODULAR_INTERPRETER)
            if (objHinterpreter != null)
            {
                objHinterpreter.SetHerbertSpeed(herbtSpeed);
            }
#endif
        }


        /// <summary>
        /// this event is raised when reset item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ResetHerbtMenu_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
            else
            {
                EnableRestore();
            }
#endif
            //it kills the thread so that herbert stops moving.
            if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg && arrLevels[currentLevelIndex].blnResetState)
            {
                arrLevels[currentLevelIndex].blnFirstStepClick = true;
                DisableMenu();


#if(DESIGNER)
                mnuMainDesign.Enabled=true;
				HerbertBoard.Enabled=true;
				txtLevelPoints.ReadOnly = false;
                txtLevelPoints.Enabled = true;
#endif
                killThread();
                deSelectError();
                arrLevels[currentLevelIndex].stepByStep = false;
                //if game is not reset till now then reset it.
                if (!arrLevels[currentLevelIndex].blnHReset)
                {
                    resetHerbert();
                }
                //reset the menu item's status in run menu.
#if(THREADSLEEP)
				Thread.Sleep(400);
#endif
                IniOrResetRunMenu();
            }
        }


        bool bSelfChange = false;
        //private int[] levelstodisp;

        /// <summary>
        /// event is raised when LevelChangeBar is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void LevelChange_ValueChanged(object sender, System.EventArgs e)
        {
            int tmpLevelDownCount = 0;
            int tmpLevelUpCount = 0;
            //Console.WriteLine("Entered LevelChange_ValueChanged");
            if (bSelfChange)
            {
                bSelfChange = false;
                return;
            }
            if (!blnProgramaticallyLevelChanged && blnScrollMouseRelease)
            {
                int iWait = (int)(herbtSpeed * 2) + 200;

                if (Monitor.TryEnter(bMonitorLChange, iWait))
                {
                    bMonitorLChange = true;
                    //Trace.WriteLine("change level");
                    try
                    {
                        Monitor.Exit(bMonitorLChange);
                    }
                    catch { }
                }
                else
                {
                    bSelfChange = true;
                    LevelChangeBar.Value = currentLevelIndex * 10;
                    return;
                }
                //Commented by Ani to prevent aborting in interpret
                //after moveherbie but before interpreter.
                //blnChangeLevel = true;
                if (Monitor.TryEnter(bSemaphore, iWait))
                {
                    bSemaphore = false;
                    #region Ani's innovation
                    // for immediate closure of the running herbert thread.
                    // instead of loosing any time in function call to kill thread
                    // & doing events each time.
                    //					lock(arrLevels[currentLevelIndex].progClosing)
                    //					{
                    //						if(!(bool)arrLevels[currentLevelIndex].progClosing)
                    //							arrLevels[currentLevelIndex].progClosing = true;
                    //					}
                    killThread();
                    #endregion
                    // killThread();
                    setLevelScrollProperly();
                    //Console.WriteLine("About to call ChangeLevel");
#if(DESIGNER)
                    //Added By rajesh
                    if (txtLevelPoints.Focused)
                        txtLevelPoints.Enabled = false; 
#endif
                    this.lblBlack.Visible = false;
                    ChangeLevel();
#if(DESIGNER)
                     //Added By rajesh
                    txtLevelPoints.Enabled = true;
#endif

                    bSemaphore = true;
                    try
                    {
                        Monitor.Exit(bSemaphore);
                    }
                    catch { }
                    bMonitorLChange = false;
                    //blnChangeLevel=false;
                }
                else
                {
                    bSelfChange = true;
                    bMonitorLChange = false;
                    LevelChangeBar.Value = currentLevelIndex * 10;
                    return;
                }
            }
#if(CONTEST)

            // added by NikhilK on 25/10/2007 to disable button on last level
            if (currentLevelIndex == arrLevels.Length - 1)

                btnNextUnsolved.Enabled = false;
            else
                btnNextUnsolved.Enabled = true;

            // added by NikhilK on 25/10/2007 to disable button on first level
            if (currentLevelIndex == 1 || currentLevelIndex == 0)
                btnPrevUnsolved.Enabled = false;
            else
                btnPrevUnsolved.Enabled = true;

            // -- code for bucketing enabled --
            if (isBucketingEnabled)
            {
                if (currentLevelIndex == (GlobalData.currentUnsolvedBucket * GlobalData.numLevelsPerBucket))
                {
                    btnNextUnsolved.Enabled = false;
                }

                // added by NikhilK on 25/10/2007 to disable Next Unsolved Level button 
                // if all further levels are already solved (bucketing enabled)

                for (int i = currentLevelIndex + 1; i <= (GlobalData.currentUnsolvedBucket * GlobalData.numLevelsPerBucket); i++)
                {
                    if (arrLevels[i].IsLevelFinishedPersistant)
                        tmpLevelDownCount++;
                }
                if (tmpLevelDownCount == ((GlobalData.currentUnsolvedBucket * GlobalData.numLevelsPerBucket) - currentLevelIndex))
                    btnNextUnsolved.Enabled = false;

                // added by NikhilK on 25/10/2007 to disable Previous Unsolved Level button
                // if all previous levels are already solved (bucketing enabled)
                for (int i = currentLevelIndex - 1; i > 0; i--)
                {
                    if (arrLevels[i].IsLevelFinishedPersistant)
                        tmpLevelUpCount++;
                }
                if (tmpLevelUpCount == (currentLevelIndex - 1))
                    btnPrevUnsolved.Enabled = false;
            }
            else
            {
                // added by NikhilK on 25/10/2007 to disable Next Unsolved Level button 
                // if all further levels are already solved
                for (int i = currentLevelIndex + 1; i < arrLevels.Length; i++)
                {
                    if (arrLevels[i].IsLevelFinishedPersistant)
                        tmpLevelDownCount++;
                }
                if (tmpLevelDownCount == ((arrLevels.Length - 1) - currentLevelIndex))
                    btnNextUnsolved.Enabled = false;

                // added by NikhilK on 25/10/2007 to disable Previous Unsolved Level button 
                // if all previous levels are already solved
                for (int i = currentLevelIndex - 1; i > 0; i--)
                {
                    if (arrLevels[i].IsLevelFinishedPersistant)
                        tmpLevelUpCount++;
                }
                if (tmpLevelUpCount == (currentLevelIndex - 1))
                    btnPrevUnsolved.Enabled = false;
            }
#endif
        }
        object bSemaphore = true;
        object bMonitorLChange = false;

        //int iRorLCount = 0;
        /// <summary>
        /// event is raised if step item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void StepHrbt_Click(object sender, System.EventArgs e)
        {
            ///Added By Rajesh
            ///Date 18/8/06
            ///Issue id: 3788
#if DESIGNER
            if (txtLevelPoints.Text == "")
            {
                txtLevelPoints.Text = "0";
            }
#endif
            ///End
            if (arrLevels[currentLevelIndex].blnStepState)
            {
                ////Console.WriteLine("Inside Step");
                if (arrLevels[currentLevelIndex].blnFirstStepClick)
                {

                    arrLevels[currentLevelIndex].blnFirstStepClick = false;
                    arrLevels[currentLevelIndex].iTotalGos++;
                    arrLevels[currentLevelIndex].iLastVisits = arrLevels[currentLevelIndex].pNumVisits;
                    arrLevels[currentLevelIndex].iLastBytes = CountChars(txtCodeEditor.Text);
                    arrLevels[currentLevelIndex].iLastCharsTyped = arrLevels[currentLevelIndex].iTotalCharsTyped;
                    arrLevels[currentLevelIndex].iLastGos = arrLevels[currentLevelIndex].iTotalGos;
                    arrLevels[currentLevelIndex].iLastProgram = txtCodeEditor.Text;
                    arrLevels[currentLevelIndex].iLastTimeSpent = arrLevels[currentLevelIndex].iTotalTimeSpent;
                    arrLevels[currentLevelIndex].iLastDate = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);
                }
#if(DESIGNER)
				arrLevels[currentLevelIndex].IsLevelFinished = false;
				arrLevels[currentLevelIndex].IsLevelFinishedPersistant = false;
#endif

                DisableMenu();
                //killThreadNoWait();
                arrLevels[currentLevelIndex].syntaxCheck = true;
                arrLevels[currentLevelIndex].SyntaxError = false;
                //check if step by step is true and if go is clicked then no need to 
                //check for syntax anymore.
                if (!arrLevels[currentLevelIndex].stepByStep && !arrLevels[currentLevelIndex].goClicked)
                {	////Console.WriteLine("Inside Ini");			
                    //09/03/05
                    if (GlobalData.HerbertMode == HMode.Designer && arrLevels[currentLevelIndex].IsLevelUpdate)
                    {
#if(DESIGNER)				
						arrLevels[currentLevelIndex].saveUpdatedLevelData(currentLevelIndex);
#endif

                        if (currentLevelId == 0)
                            lock (txtCodeEditor)
                            {
                                arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                            }
                    }
                    arrLevels[currentLevelIndex].CurDir = 0;
                    herbertState = 0;
                    getImages();
                    if (currentLevelId > 0)
# if(CONTEST)
                        InitialOrResetHrbt = arrLevels[currentLevelIndex].getRoboXY(currentLevelId);
#endif
# if(DESIGNER)
						InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
#endif
                    else
                    {
#if (DESIGNER)
						if(GlobalData.HerbertMode == HMode.Designer)
						{
							//							InitialOrResetHrbt = Level.getRoboPos();
							InitialOrResetHrbt = GetHerbertPos(currentLevelIndex);
						}
						else
						{
#endif
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                            InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                        else
                            InitialOrResetHrbt = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
#if (DESIGNER)
						}
#endif
                    }

                    //lock(this.herbertPicBox)
                    {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[0];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}

#endif
                        //lock(arrHrbtImage[0])
                        {
#if (INVOKER)

                            if (this.herbertPicBox.InvokeRequired)
                            {
                                if (herbtSpeed == 0)
                                    lock (imgForPicBox)
                                    {
                                        imgForPicBox = arrHrbtImage[0];
                                    }
                                else
                                    imgForPicBox = arrHrbtImage[0];
                                this.herbertPicBox.Invoke(mi);
                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[0];
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[0];


#endif
                        }
                        //herbertPicBox.Invalidate();
                        //Application.DoEvents();
#endif
                    }
                    //resets the herbert's position variables like prePos$, destPos$ etc.
                    arrLevels[currentLevelIndex].preDestPosX = arrLevels[currentLevelIndex].prePosX = arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = InitialOrResetHrbt.X / GlobalData.ZoomInZoomOut;
                    arrLevels[currentLevelIndex].preDestPosY = arrLevels[currentLevelIndex].prePosY = arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = InitialOrResetHrbt.Y / GlobalData.ZoomInZoomOut;
                    arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                    arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
#if (EXCEPTION)
                    try
                    {
#endif
                        //lock(this.herbertPicBox)
                        {
                            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                                {
                                    this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                                }
                                else
                                    this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                            else
                                herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
                        }
#if (EXCEPTION)
                    }
                    catch
                    {
                        ////Console.WriteLine(exp.Message + ", resetHerbert, 11");
                    }
#endif
                    arrLevels[currentLevelIndex].tHState.Flags = 0;
                    arrLevels[currentLevelIndex].tHState.CurrentOp = ' ';
                    arrLevels[currentLevelIndex].tHState.curLine = 0;
                    arrLevels[currentLevelIndex].tHState.PC = 0;
                    arrLevels[currentLevelIndex].tCurLine.iFirstCmd = 0;
                    arrLevels[currentLevelIndex].tCurLine.iLength = 0;
                    arrLevels[currentLevelIndex].tCurLine.iLineNum = 0;
                    //atLineInfo = new AtLineInfoStruct[MAXLINES];
                    arrLevels[currentLevelIndex].aiStack = new int[STACKSIZE];
                    arrLevels[currentLevelIndex].iSP = 0;
                    arrLevels[currentLevelIndex].stackInitialisationCounter = 0;
                    //09/03/05
                    arrLevels[currentLevelIndex].blnRorLStep = false;
                    //Level.temp_levelTimer = arrLevels[currentLevelIndex].timeSpent;
                    lock (txtCodeEditor)
                    {
                        arrLevels[currentLevelIndex].iCurrentProgram = txtCodeEditor.Text;
                    }
                    arrLevels[currentLevelIndex].charused = CountChars(txtCodeEditor.Text);
                    DispMessage("");
                    arrLevels[currentLevelIndex].tHState.Flags |= HFSSTEP;
                    arrLevels[currentLevelIndex].tHState.Flags &= ~HFSTEPD;
                    arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].curPosX;
                    arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].curPosY;
                    TrimTextData();
                    getTextData();
                    lock (txtCodeEditor)
                    {
                        /*get program as char array.*/
                        arrLevels[currentLevelIndex].pcProg = txtCodeEditor.Text.Replace("\r", "").ToCharArray();
                        //iProgLen = txtCodeEditor.Text.Length;
                        arrLevels[currentLevelIndex].iProgLen = arrLevels[currentLevelIndex].pcProg.Length;
                    }
                    //displayTrace();	
                    arrLevels[currentLevelIndex].stepByStep = true;
                    arrLevels[currentLevelIndex].blnLevelFinishedMsg = false;
#if(MODULAR_INTERPRETER)

                    CallInterpreter();
                    arrLevels[currentLevelIndex].syntaxCheck = objHinterpreter.CheckSyntax();
                    //arrLevels[currentLevelIndex].syntaxCheck = CheckSyntax();
#else
			        arrLevels[currentLevelIndex].syntaxCheck = CheckSyntax();
#endif
                    if (arrLevels[currentLevelIndex].syntaxCheck)
                    {
                        if (mnuTrace.Checked)
                        {
                            SetupEditorTrace(0);
                            lock (txtCodeEditor)
                            {
                                txtCodeEditor.Visible = false;
                            }
                            PanalTxtCodeEdit.Invalidate();
                        }
                    }
                    //					if(!arrLevels[currentLevelIndex].IsLevelFinished)
                    //						arrLevels[currentLevelIndex].numSolveAtmpt++;
                }
                else
                    arrLevels[currentLevelIndex].stepByStep = true;

                //OneStepDone becomes false if herbert consumes one char given to it. 
                arrLevels[currentLevelIndex].OneStepDone = true;
                arrLevels[currentLevelIndex].goClicked = false;
                //Level.temp_levelTimer = arrLevels[currentLevelIndex].timeSpent;
                int t_hrtbSpeed = herbtSpeed;
                //set herbert sleep time to 0 after taking it's backup. so that in 
                //case of step by step thread doesn't sleeps.
                herbtSpeed = 0;
                //bool blnInerpert = false;
                //progClosing = false;
                ////Console.WriteLine("1 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);
                while (arrLevels[currentLevelIndex].OneStepDone && !(bool)arrLevels[currentLevelIndex].EndofProg && arrLevels[currentLevelIndex].syntaxCheck && !arrLevels[currentLevelIndex].SyntaxError)
                {
#if(DESIGNER)
				
					/*==============================================================================
					 *  Added By : Vivek Balagangadharan
					 *  Description : Added to make sure that the level is run before saving a level design
					 *  Added On : 14-Apr-2006
					 * ==============================================================================*/
					if(GlobalData.HerbertMode == HMode.Designer)
					{
						arrLevels[currentLevelIndex].IsLevelRun = true;
					}
					/* End */
#endif
                    hrbtRedrawn = true;
                    hrbtBoardRedrawn = true;
                    if (arrLevels[currentLevelIndex].blnRorLStep)
                    {
                        arrLevels[currentLevelIndex].blnRorLStep = false;
                        if (PathOn)
                            arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                        //arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX,arrLevels[currentLevelIndex].curPosY);
                        if (arrLevels[currentLevelIndex].StepCharRorL != ' ')
                        {
                            Command = arrLevels[currentLevelIndex].StepCharRorL.ToString().ToUpper();
                            //Added by Sujith/Vivek on 06/28/2005 for issue id: 1426
                            if (arrLevels[currentLevelIndex].PreDir == arrLevels[currentLevelIndex].CurDir)
                                break;
                        }
                    }
                    if (MoveHerbie())
                    {
                        if (blnChangeLevel)
                        {
                            blnChangeLevel = false;
                            break;
                        }
                        if (arrLevels[currentLevelIndex].blnIsWallHit && GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                        {
                            if (PathOn)
                                arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].preDestPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].preDestPosY * GlobalData.ZoomInZoomOut);
                            //arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].preDestPosX,arrLevels[currentLevelIndex].preDestPosY);
                            arrLevels[currentLevelIndex].destPosX = arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].preDestPosX;
                            arrLevels[currentLevelIndex].destPosY = arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].preDestPosY;
                            arrLevels[currentLevelIndex].blnIsWallHit = false;
                            if (PathOn)
                                arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut);
                            //arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].curPosX,arrLevels[currentLevelIndex].curPosY);
                        }
#if(MODULAR_INTERPRETER)
                        CallInterpreter();
                        objHinterpreter.Interpreter();
#else
                        Interpreter();	
#endif
                        arrLevels[currentLevelIndex].OneStepDone = false;
                    }
                    else if (herbtSpeed != 0)
                    {
                        Thread.Sleep(herbtSpeed);
                    }

                }
                ////Console.WriteLine("2 "+curPosX + ", " +curPosY + ", "+destPosX + ", "+destPosY);
                //reset the sleep time.
                herbtSpeed = t_hrtbSpeed;
                EnableMenu();
                //DisableMenu();
                mnuHaltHrbt.Enabled = false;
                arrLevels[currentLevelIndex].blnHaltState = false;
                btStop.Enabled = true;
                this.hTooltip.SetToolTip(this.btGoPause, "Resume");
                //			mnuResetHerbt.Enabled = true;
                //			mnuStepHrbt.Enabled = true;
                //			btStep.Enabled = true;
                if ((bool)arrLevels[currentLevelIndex].EndofProg || !arrLevels[currentLevelIndex].syntaxCheck || blnSystemError)
                {
                    mnuResetHerbt.Enabled = true;
                    arrLevels[currentLevelIndex].blnResetState = true;
                    mnuGoHrbt.Enabled = false;
                    arrLevels[currentLevelIndex].blnGoState = false;
                    mnuResumeHrtb.Enabled = false;
                    arrLevels[currentLevelIndex].blnResumeState = false;
                    mnuStepHrbt.Enabled = false;
                    arrLevels[currentLevelIndex].blnStepState = false;
                    btGoPause.Enabled = false;
                    btStep.Enabled = false;
                    btStop.Enabled = true;
                }
#if(DESIGNER)
				mnuMainDesign.Enabled = false;
#endif

# if(DESIGNER)
                //added By Rajesh.
				//txtLevelPoints.ReadOnly = true;
				//				mnuWhitebttn.Checked = false;
				//				mnuWallRight.Checked = false;
				//				mnuWallDown.Checked = false;
				//				mnuWallDown.Checked = false;
				//				mnuHerbie.Checked = false;
#endif
                arrLevels[currentLevelIndex].blnHReset = false;
            }
            else
            {
                if (txtCodeEditor.Text == "")
                {
                    arrLevels[currentLevelIndex].blnLevelFinishedMsg = true;
                }
            }

        }


        //bool blnHrbtHalted = false;
        /// <summary>
        /// event is raised when halt menu is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void HaltHrbt_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
            else
            {
                EnableRestore();
            }
#endif
            if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg && arrLevels[currentLevelIndex].blnHaltState)
            {
#if(DESIGNER)
                txtLevelPoints.Enabled = true;
                txtLevelPoints.ReadOnly = false;
#endif
                DisableMenu();
                killThread();

                //Thread.Sleep(100);
                ////Console.WriteLine("CurDir2 " + CurDir);
                //HrbtHaltDir = CurDir;
                //tHState.iPC -=1;
                //////Console.WriteLine("H "+CurDir);
                //hrbthalted = true;	commented by karthikeyan 16/03
                herbertState = 0;
#if (EXCEPTION)
                try
                {
#endif
                    //lock(this.herbertPicBox)
                    {
#if (OLDCODE)
					this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
#endif

#if (NEWCODE)
#if (OLDNEWCODE)
	if (this.herbertPicBox.Image != null) 
	{
		this.herbertPicBox.Image.Dispose();
		this.herbertPicBox.Image = null;
	}
#endif
                        //lock(arrHrbtImage[stateArray[herbertState]])
                        {
#if (INVOKER)

                            if (this.herbertPicBox.InvokeRequired)
                            {
                                if (herbtSpeed == 0)
                                    lock (imgForPicBox)
                                    {
                                        imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                    }
                                else
                                    imgForPicBox = arrHrbtImage[stateArray[herbertState]];
                                this.herbertPicBox.Invoke(mi);

                                /////Console.WriteLine("Invoking....");
                            }
                            else
                            {
#endif
                                this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];
                                HerbertBoard.Invalidate();
#if (INVOKER)
                            }

                            //this.herbertPicBox.Image = arrHrbtImage[stateArray[herbertState]];

#endif
                        }
                        //herbertPicBox.Invalidate();

                        //Application.DoEvents();
#endif
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(exp1.Message + ", HaltHrbt_Click, 10");
                }
                try
                {
#endif

                    //change the location of herbert picture box and 2 is used 
                    //because we can't specify the center point of a picture box
                    //to draw it. we can only specify TOP-LEFT (x,y) coordinates
                    // and (curPosX, curPosY) is center point where this picture 
                    //box should be displayed.
                    //lock(this.herbertPicBox)
                    {
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                            if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                            {
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].prePosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].prePosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                            }
                            else
                                this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].prePosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].prePosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                        else
                            this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].prePosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].prePosY * GlobalData.ZoomInZoomOut) - 2));
                    }
#if (EXCEPTION)
                }
                catch
                {
                    ////Console.WriteLine(e1.Message + ", HaltHrbt_Click, 11");
                }

#endif



                if (arrLevels[currentLevelIndex].CurDir == 0)
                    arrLevels[currentLevelIndex].ErasePath(arrLevels[currentLevelIndex].destPosX * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY + 1) * GlobalData.ZoomInZoomOut,
                        arrLevels[currentLevelIndex].preDestPosX * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].preDestPosY - 3) * GlobalData.ZoomInZoomOut);
                else if (arrLevels[currentLevelIndex].CurDir == 1)
                    arrLevels[currentLevelIndex].ErasePath((arrLevels[currentLevelIndex].destPosX - 1) * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].destPosY * GlobalData.ZoomInZoomOut,
                        (arrLevels[currentLevelIndex].preDestPosX + 3) * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].preDestPosY * GlobalData.ZoomInZoomOut);
                else if (arrLevels[currentLevelIndex].CurDir == 2)
                    arrLevels[currentLevelIndex].ErasePath(arrLevels[currentLevelIndex].destPosX * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].destPosY - 1) * GlobalData.ZoomInZoomOut,
                        arrLevels[currentLevelIndex].preDestPosX * GlobalData.ZoomInZoomOut, (arrLevels[currentLevelIndex].preDestPosY + 3) * GlobalData.ZoomInZoomOut);
                else if (arrLevels[currentLevelIndex].CurDir == 3)
                    arrLevels[currentLevelIndex].ErasePath((arrLevels[currentLevelIndex].destPosX + 1) * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].destPosY * GlobalData.ZoomInZoomOut,
                        (arrLevels[currentLevelIndex].preDestPosX - 3) * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].preDestPosY * GlobalData.ZoomInZoomOut);
                //arrLevels[currentLevelIndex].drawPath(arrLevels[currentLevelIndex].preDestPosX * GlobalData.ZoomInZoomOut, arrLevels[currentLevelIndex].preDestPosY * GlobalData.ZoomInZoomOut);
                arrLevels[currentLevelIndex].prePathPosX = arrLevels[currentLevelIndex].preDestPosX;
                arrLevels[currentLevelIndex].prePathPosY = arrLevels[currentLevelIndex].preDestPosY;
                //				//Console.WriteLine("arrLevels[currentLevelIndex].prePathPosX "+ arrLevels[currentLevelIndex].prePathPosX );
                //				//Console.WriteLine("arrLevels[currentLevelIndex].prePathPosY "+ arrLevels[currentLevelIndex].prePathPosY );
                //				//Console.WriteLine("arrLevels[currentLevelIndex].curPosX "+ arrLevels[currentLevelIndex].curPosX );
                //				//Console.WriteLine("arrLevels[currentLevelIndex].curPosY "+ arrLevels[currentLevelIndex].curPosY);
#if(CONTEST)
                if (mnuPath.Checked && currentLevelIndex != 0)
                {
                    //added By Rajesh 21/05/07
                    if (!(arrLevels[currentLevelIndex].curPosX == arrLevels[currentLevelIndex].destPosX && arrLevels[currentLevelIndex].curPosY == arrLevels[currentLevelIndex].destPosY))
                        arrLevels[currentLevelIndex].fRemovePath();
                }
#endif
                arrLevels[currentLevelIndex].curPosX = arrLevels[currentLevelIndex].prePosX;
                arrLevels[currentLevelIndex].curPosY = arrLevels[currentLevelIndex].prePosY;
                HerbertBoard.Refresh();
#if(THREADSLEEP)
				Thread.Sleep(100);
#endif
                EnableMenu();
                mnuHaltHrbt.Enabled = false;
                arrLevels[currentLevelIndex].blnHaltState = false;
                arrLevels[currentLevelIndex].goPauseState = 0;
                btGoPause.Image = pbRun.Image;
                btStop.Enabled = true;
                this.hTooltip.SetToolTip(this.btGoPause, "Resume");
                //blnHrbtHalted = true;
            }
        }


        /// <summary>
        /// event is raised when reseume item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ResumeHrtb_Click(object sender, System.EventArgs e)
        {
            if (arrLevels[currentLevelIndex].blnResumeState)
            {
#if(DESIGNER)
                txtLevelPoints.Enabled = false;                
#endif
                DisableMenu();
                getImages();

#if(CONTEST)
                if (mnuPath.Checked && currentLevelIndex != 0 &&
                    !(arrLevels[currentLevelIndex].destPosX == arrLevels[currentLevelIndex].preDestPosX &&
                    arrLevels[currentLevelIndex].destPosY == arrLevels[currentLevelIndex].preDestPosY))
                {
                    arrLevels[currentLevelIndex].fSavePath(currentLevelIndex);
                }
#endif
#if(PATTERN_GENERATER)
                //if(GlobalData.iPatternId=="-1")
                arrLevels[currentLevelIndex].fSavePath(currentLevelIndex);
#endif
                RotateImages(arrLevels[currentLevelIndex].CurDir);
#if(THREADSLEEP)
				Thread.Sleep(100);
#endif
                if (arrLevels[currentLevelIndex].blnRorLStep)
                {
                    arrLevels[currentLevelIndex].blnRorLStep = false;
                    Command = arrLevels[currentLevelIndex].StepCharRorL.ToString().ToUpper();
                }
                if (traceOn)
                {
                    if (PanalTxtCodeEdit.Visible == false)
                    {
                        PanalTxtCodeEdit.Visible = true;
                    }
                    if (txtCodeEditor.Visible == true)
                    {
                        txtCodeEditor.Visible = false;
                    }
                }
                mnuStepHrbt.Enabled = false;
                arrLevels[currentLevelIndex].blnStepState = false;
                btStep.Enabled = false;
                mnuGoHrbt.Enabled = false;
                arrLevels[currentLevelIndex].blnGoState = false;
                mnuResumeHrtb.Enabled = false;
                arrLevels[currentLevelIndex].blnResumeState = false;
                mnuHaltHrbt.Enabled = true;
                arrLevels[currentLevelIndex].blnHaltState = true;
                mnuResetHerbt.Enabled = true;
                arrLevels[currentLevelIndex].blnResetState = true;
                //stepByStep = false;
                arrLevels[currentLevelIndex].goClicked = true;
                arrLevels[currentLevelIndex].goPauseState = 1;
                btGoPause.Image = pbPause.Image;
                btGoPause.Enabled = true;
                btStop.Enabled = true;
                this.hTooltip.SetToolTip(this.btGoPause, "Pause");
                startThread();
#if(CONTEST)
                DisableRestore();
#endif
                HerbertBoard.Refresh();
            }
        }


        /// <summary>
        /// this event is raised when cut item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TxtCut_Click(object sender, System.EventArgs e)
        {
            if (txtCodeEditor.SelectedText != "")
            {
                //				Clipboard.SetDataObject(txtCodeEditor.SelectedText);
                //				txtCodeEditor.SelectedText = "";
                txtCodeEditor.Cut();
#if(CONTEST)
                if (GlobalData.HerbertMode == HMode.Tutorial)
                {
                    DisableRestore();
                }
                else
                {
                    EnableRestore();
                }
#endif
            }
        }


        /// <summary>
        /// this event is raised when copy item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TxtCopy_Click(object sender, System.EventArgs e)
        {
            if (txtCodeEditor.SelectedText != "")
                //Clipboard.SetDataObject(txtCodeEditor.SelectedText);
                txtCodeEditor.Copy();
        }


        /// <summary>
        /// this event is raised when paste item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TxtPaste_Click(object sender, System.EventArgs e)
        {
#if (EXCEPTION)
            try
            {
#endif
                // Paste current text in Clipboard into text box.
                txtCodeEditor.Paste();
#if (EXCEPTION)
            }
            catch
            {
                ////Console.WriteLine(exp.Message + ", TxtPaste_Click, 11");
                MessageBox.Show(this, "Your current security settings prevent you from doing this operation.\n Please use CTRL+V or check security mentioned in our website.", "Herbert - warning", MessageBoxButtons.OK, MessageBoxIcon.Warning);
            }
#endif
        }


        /// <summary>
        /// this event is raised when clear item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TxtClear_Click(object sender, System.EventArgs e)
        {
            //txtCodeEditor.Clear();
            txtCodeEditor.SelectedText = "";
            //			if(txtCodeEditor.Text == "")
            //				txtCodeEditor.Rtf = "";
        }


        /// <summary>
        /// this event is raised when undo item is clicked.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TxtUndo_Click(object sender, System.EventArgs e)
        {
            if (txtCodeEditor.CanUndo == true)
            {
                // Undo the last operation.
                txtCodeEditor.Undo();
                // Clear the undo buffer to prevent last action from being redone.
                //txtCodeEditor.ClearUndo();
            }
        }


        /// <summary>
        /// this event is raised when clicked on panal.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void PanalTxtCodeEdit_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //halts herbert. and displays txtcodeeditor.
            if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg)
            {
                txtCodeEditor.Visible = true;
                if (arrLevels[currentLevelIndex].goClicked)
                    HaltHrbt_Click(null, null);
            }
        }


        /// <summary>
        /// this variable is used for indication that the one click processing is still going on
        /// if it's value is false.
        /// </summary>
        private bool blnClickFinished = true;

        /// <summary>
        /// event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void txtCodeEditor_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            //by vijay, endofprog condition added

            if (blnClickFinished)
            {
                try
                {
                    blnClickFinished = false;
                    if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg && arrLevels[currentLevelIndex].syntaxCheck && arrLevels[currentLevelIndex].checkSyntaxGo && !blnSystemError)
                    {
                        if (!(bool)progClosing)
                            HaltHrbt_Click(null, null);
                    }
                    else if (!arrLevels[currentLevelIndex].syntaxCheck || !arrLevels[currentLevelIndex].checkSyntaxGo || blnSystemError)
                    {
                        ResetHerbtMenu_Click(null, null);
                        deSelectError();
                    }
                    //show the context menu.
                    if (e.Button == MouseButtons.Right)
                    {
                        //cM.Show(this.txtCodeEditor, new Point(e.X,e.Y));			
                    }
                    arrLevels[currentLevelIndex].syntaxCheck = true;
                    arrLevels[currentLevelIndex].checkSyntaxGo = true;
                }
                finally
                {
                    blnClickFinished = true;
                }
            }
        }



        /// <summary>
        /// this count is used to re initalize the timer interval
        /// </summary>
        private int count = 0;

        /// <summary>
        /// This bool variable tells that polling is going on or not.<p><u>True</u>: Polling is going on</p>
        /// <p><u>False</u>: No polling is going on.</p>
        /// </summary>
        private bool blnPooling = false;

        /// <summary>
        /// This is to test whether the game interval changed in the PoolForMaint()
        /// This is required for the offline herbert.
        /// </summary>
        private bool blnTimeIntervalChanged = false;

        /// <summary>
        /// Therad used for polling.
        /// </summary>
        private Thread tPolling = null;

        /// <summary>
        /// timer event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        ///		
        private void GameTimer_Tick(object sender, System.EventArgs e)
        {
            //			if(dataLoaded && !blnTutorial && blnIsValid)
            //			{
            //				if(GameInterval <= 0)
            //				{	
            //					try
            //					{
            //						if(tPolling != null)
            //							tPolling.Abort();
            //					}
            //					catch
            //					{
            //					}
            //					mnuMainFile.Enabled = false;
            //					mnuMainEdit.Enabled = false;
            //					mnuMainOptions.Enabled = false;
            //					mnuMainRun.Enabled = false;
            //					mnuMainDesign.Enabled = false;
            //					mnuMainHelp.Enabled = false;
            //					LevelChangeBar.Enabled = false;
            //					SpeedBar.Enabled = false;
            //					txtCodeEditor.ReadOnly = true;
            //					btRight.Enabled = false;
            //					btLeft.Enabled = false;
            //					btStraight.Enabled = false;
            //					btGoPause.Enabled = false;
            //					btStep.Enabled = false;
            //					btStop.Enabled = false;
            //					if(mnuTxtPaste.Enabled != false)
            //						btPaste.Enabled = false;
            //					btCopy.Enabled = false;
            //					btCut.Enabled = false;
            //					btTrace.Enabled = false;
            //					btPath.Enabled = false;
            //
            //					LevelTimer.Enabled = false;
            //					GameTimer.Enabled = false;
            //					TimeOver = true;
            //					this.Close();
            //					return;
            //				}				
            //				//Added by Vivek to check maintenance time
            //				if(MTimeInSecRemainingToStart>=0)
            //				{
            //					if(MTimeInSecRemainingToStart==0)
            //					{
            //						try
            //						{
            //							if(tPolling != null)
            //								tPolling.Abort();
            //						}
            //						catch
            //						{
            //						}
            //						mnuMainFile.Enabled = false;
            //						mnuMainEdit.Enabled = false;
            //						mnuMainOptions.Enabled = false;
            //						mnuMainRun.Enabled = false;
            //						mnuMainDesign.Enabled=false;
            //						mnuMainHelp.Enabled = false;
            //						LevelChangeBar.Enabled = false;
            //						SpeedBar.Enabled = false;
            //						txtCodeEditor.ReadOnly = true;
            //						btRight.Enabled = false;
            //						btLeft.Enabled = false;
            //						btStraight.Enabled = false;
            //						btGoPause.Enabled = false;
            //						btStep.Enabled = false;
            //						btStop.Enabled = false;
            //						if(mnuTxtPaste.Enabled != false)
            //							btPaste.Enabled = false;
            //						btCopy.Enabled = false;
            //						btCut.Enabled = false;
            //						btTrace.Enabled = false;
            //						btPath.Enabled = false;
            //
            //						LevelTimer.Enabled = false;
            //						GameTimer.Enabled = false;
            //						MaintenanceStarted = true;
            //						this.Close();
            //						return;
            //					}
            //					MTimeInSecRemainingToStart--;
            //				}
            //				if(iNumWarningMsg > 0 && !blnUploadingSolutions && count != 0)
            //				{
            //					for(int i = 0; i < iNumWarningMsg; i++)
            //					{
            //						try
            //						{
            //							if(iTimeRemainingForWarningX[i] >= 0)
            //							{
            //								//								//Console.WriteLine(i.ToString() + " iTimeRemainingForWarningX[i] " + iTimeRemainingForWarningX[i]);
            //								//								//Console.WriteLine(i.ToString() + " " + strWarningMsgX[i]);
            //								//								//Console.WriteLine(iTimeRemainingForWarningX[i] == 0 && iValidityOfWarningX[i] == 1 && !blnMsgShown[i]);
            //								//								//Console.WriteLine(iTimeRemainingForWarningX[i] - iPoolingRandTime[i] == 0 && !blnPooling && blnToDoPooling[i]);
            //								if(iTimeRemainingForWarningX[i] == 0 && iValidityOfWarningX[i] == 1 && blnMsgShown[i])
            //								{
            //									blnMsgShown[i] = false;
            //									MessageBox.Show(this,strWarningMsgX[i],"Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);	
            //								}
            //								else if(iTimeRemainingForWarningX[i] - iPoolingRandTime[i] == 0 && !blnPooling && blnToDoPooling[i])
            //								{
            //									blnPooling = true;
            //									blnToDoPooling[i] = false;
            //									tPolling = new Thread(new ThreadStart(PoolForMaintData));
            //									tPolling.Priority = ThreadPriority.Highest;
            //									tPolling.Start();	
            //									////Console.WriteLine("Polling for " + strWarningMsgX[i]);
            //								}							
            //								iTimeRemainingForWarningX[i]--;
            //							}
            //						}
            //						catch(Exception exp)
            //						{
            //							////Console.WriteLine(exp.Message);
            //						}
            //					}
            //				}				
            //				GameInterval--;
            //				if(count == 0)
            //				{
            //					LevelTimer.Enabled = true;
            //					count++;
            //					GameTimer.Interval = 60000;
            //				}
            //			}
        }

        //private int iMaintainWarn = 0;
        //private int iMaintainWarn1 = 0;
        //private int iMaintainWarn2 = 0;
        //private int iMaintainWarn3 = 0;

        private int secondCounter = 0;

#if(CONTEST)
        /// <summary>
        /// Boolean variable indicating whether silent save before the contest closes, is done or not
        /// </summary>
        private bool blnIsSilentSaveInvoked = false;
#endif

        /// <summary>
        /// timer event. for level time calculation
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>

        private void LevelTimer_Tick(object sender, System.EventArgs e)
        {
            if (iNumTimesLevelVisitedHelper < 1)
            {
                iNumTimesLevelVisitedHelper++;
                if (currentLevelIndex < arrLevels.Length)
                    arrLevels[currentLevelIndex].pNumVisits++;
            }
            //			arrLevels[currentLevelIndex].timeSpent += 1;
            // added by karthikeyan for total time spent
            if (arrLevels != null)
            {
                if (currentLevelIndex < arrLevels.Length)
                    arrLevels[currentLevelIndex].iTotalTimeSpent++;
            }
            if (lblLoading.Visible)
            {
                iLoadtime++;
            }


            if (dataLoaded && !blnTutorial && blnIsValid)
            {
                if (GameInterval <= 0)
                {
                    //Contest time over.
                    try
                    {
                        if (tPolling != null)
                            tPolling.Abort();
                    }
                    catch
                    {
                    }
                    mnuMainFile.Enabled = false;
                    mnuMainEdit.Enabled = false;
                    mnuMainOptions.Enabled = false;
                    mnuMainRun.Enabled = false;
                    mnuMainHelp.Enabled = false;
                    LevelChangeBar.Enabled = false;
                    SpeedBar.Enabled = false;
                    txtCodeEditor.ReadOnly = true;
                    btRight.Enabled = false;
                    btLeft.Enabled = false;
                    btStraight.Enabled = false;
                    btGoPause.Enabled = false;
                    btStep.Enabled = false;
                    btStop.Enabled = false;
                    if (mnuTxtPaste.Enabled != false)
                        btPaste.Enabled = false;
                    btCopy.Enabled = false;
                    btCut.Enabled = false;
                    btTrace.Enabled = false;
                    btPath.Enabled = false;

                    LevelTimer.Enabled = false;
                    //GameTimer.Enabled = false;
                    TimeOver = true;
                    GlobalData.IsreloadApplication = true;
                    GlobalData.IsShowContestList = true;
                    this.Close();
                    if (GlobalData.IsShowContestList)
                    {
                        GlobalData.GUID = "";
                        GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                    }
                    return;
                }
                //Added by Vivek to check maintenance time
                /*if(MTimeInSecRemainingToStart>=0)
                {
                    if(MTimeInSecRemainingToStart==0)
                    {
                        //Maintanence time has come.
                        try
                        {
                            if(tPolling != null)
                                tPolling.Abort();
                        }
                        catch
                        {
                        }
                        mnuMainFile.Enabled = false;
                        mnuMainEdit.Enabled = false;
                        mnuMainOptions.Enabled = false;
                        mnuMainRun.Enabled = false;
                        mnuMainHelp.Enabled = false;
                        LevelChangeBar.Enabled = false;
                        SpeedBar.Enabled = false;
                        txtCodeEditor.ReadOnly = true;
                        btRight.Enabled = false;
                        btLeft.Enabled = false;
                        btStraight.Enabled = false;
                        btGoPause.Enabled = false;
                        btStep.Enabled = false;
                        btStop.Enabled = false;
                        if(mnuTxtPaste.Enabled != false)
                            btPaste.Enabled = false;
                        btCopy.Enabled = false;
                        btCut.Enabled = false;
                        btTrace.Enabled = false;
                        btPath.Enabled = false;

                        LevelTimer.Enabled = false;
                        //GameTimer.Enabled = false;
                        MaintenanceStarted = true;
                        this.Close();
                        return;
                    }
                    //					if(secondCounter >= 60)
                    //					{
                    MTimeInSecRemainingToStart--;
                    //					}
					
                }*/

                if (iNumWarningMsg > 0 && !blnUploadingSolutions && count != 0)
                {
                    //check for polling.
                    for (int i = 0; i < iNumWarningMsg; i++)
                    {
                        try
                        {
                            ////Console.WriteLine(i.ToString()+":"+iTimeRemainingForWarningX[i].ToString());
                            if (iTimeRemainingForWarningX[i] >= 0)
                            {
                                if (iTimeRemainingForWarningX[i] == 0 && blnMsgShown[i])
                                {

                                    blnMsgShown[i] = false;
                                    MessageBox.Show(this, strWarningMsgX[i], "Herbert - Information", MessageBoxButtons.OK, MessageBoxIcon.Information);
                                    if (isForceClose[i])
                                    {
                                        this.Close();
                                        return;
                                    }
                                }
                                else if (iTimeRemainingForWarningX[i] - (iPoolingRandTime[i] * 60) == 0 && !blnPooling && blnToDoPooling[i])
                                {
                                    blnPooling = true;
                                    blnToDoPooling[i] = false;
                                    tPolling = new Thread(new ThreadStart(PoolForMaintData));
                                    tPolling.Name = "Message Polling (" + DateTime.Now.ToShortTimeString() + ")";
                                    tPolling.Priority = ThreadPriority.Highest;
                                    tPolling.Start();
                                }
                                iTimeRemainingForWarningX[i]--;
                            }
                        }
                        catch
                        {
                            ////Console.WriteLine(exp.Message);
                        }
                    }
                }


                if (secondCounter >= 60)
                {
                    secondCounter = 0;

                    mHeartBeatCounter++;
                }
                GameInterval--;
#if(CONTEST)
                DateTime dt = new DateTime();
                int iDays = 0;
                int iHours = 0;
                int iMinutes = 0;
                int iSeconds = 0;
                //added by NikhilK on 4/6/2007 for timer functionality.
                iSeconds = GameInterval;
                iMinutes = (iSeconds / 60);
                iHours = (iMinutes / 60);
                iDays = (iHours / 24);

                iSeconds = iSeconds % 60;
                iMinutes = iMinutes % 60;
                iHours = iHours % 24;
                lblTimeLeft.Text = iDays.ToString() + "d " + iHours.ToString() + "h " + iMinutes.ToString() + "m " + iSeconds.ToString() + "s";
#endif
#if(CONTEST)
                if (dataLoaded)
                    TotalTimeInSilentSaveSecRemaining--;
                if (TotalTimeInSilentSaveSecRemaining <= 0 && !blnIsSilentSaveInvoked && isSiteDefaultUserId != 1)
                {
                    try
                    {
                        Thread thdSilentSave = new Thread(new ThreadStart(UploadSolutionsInDBForThread));
                        thdSilentSave.Name = "UploadSolutionsInDBForThread";
                        thdSilentSave.Priority = ThreadPriority.Normal;
                        blnIsSilentSaveInvoked = true;
                        thdSilentSave.Start();
                    }
                    catch
                    { }
                }
#endif
                if (count == 0)
                {
                    LevelTimer.Enabled = true;
                    count++;
                    //GameTimer.Enabled = false;
                }

                //update herbert heart beat.
                if (mHeartBeatCounter == mHBIntervalInMin)
                {
                    mHeartBeatCounter = 0;
                    tPolling = new Thread(new ThreadStart(PoolForMaintData));
                    tPolling.Name = "Maintainance Polling (" + DateTime.Now.ToShortTimeString() + ")";
                    tPolling.Priority = ThreadPriority.Highest;
                    tPolling.Start();
                }
                //				//Console.WriteLine( GameInterval.ToString() + ":" + secondCounter.ToString());
                secondCounter++;
#if(PATTERN_GENERATER)

                if (File.Exists("Pattern.pat") && (GlobalData.iPatternId != "-1" || GlobalData.iLevelId != "-1") && dataLoaded == true)
                {
                    try
                    {

                        FileStream stream = new FileStream("Pattern.pat", FileMode.Open, FileAccess.ReadWrite, FileShare.Read);
                        string strPatternid = "";
                        using (StreamReader s1 = new StreamReader(stream))
                        {
                            strPatternid = s1.ReadToEnd();

                        }
                        stream.Close();
                        if (strPatternid.Contains("pid="))
                        {
                            strPatternid = strPatternid.Replace("pid=", "");
                            if (!GlobalData.iPatternId.Equals(strPatternid) && strPatternid != "")
                            {
                                GlobalData.iPatternId = strPatternid;
                                GlobalData.IsreloadApplication = true;
                                dataLoaded = false;
                                //File.Delete("Pattern.pat");
                                GlobalData.iLevelId = "-1";
                                GlobalData.IsShowContestList = true;
                                this.Close();
                            }
                            else
                            {
                                GlobalData.IsreloadApplication = false;
                                File.Delete("Pattern.pat");
                            }
                        }
                        else if (strPatternid.Contains("lid="))
                        {
                            strPatternid = strPatternid.Replace("lid=", "");
                            if (!GlobalData.iLevelId.Equals(strPatternid) && strPatternid != "")
                            {
                                GlobalData.iLevelId = strPatternid;
                                GlobalData.IsreloadApplication = true;
                                dataLoaded = false;
                                //File.Delete("Pattern.pat");
                                GlobalData.iPatternId = "-1";
                                GlobalData.IsShowContestList = true;
                                this.Close();
                            }
                            else
                            {
                                GlobalData.IsreloadApplication = false;
                                File.Delete("Pattern.pat");
                            }
                        }

                    }
                    catch (Exception Exp)
                    {
#if(DEBUG)
                        MessageBox.Show(Exp.Message);
#endif
                    }
                }
#endif
            }
        }


        private int oldWidth = 0, oldHeight = 0;

        private void HerbertMain_Resize(object sender, System.EventArgs e)
        {
#if(MS10MAR || FT)
            try
            {
                if (dataLoaded)
                {
                    this.SuspendLayout();
                    if (this.WindowState == FormWindowState.Maximized)
                    {

                        //						if(!((this.Width < 840) || (this.Height< 600)))
                        //						{
                        if (!((this.Width < 800) || (this.Height < 575)))
                        {
                            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                            {
                                GlobalData.ZoomInZoomOut = HConstants.ZOOMIN;
                                ZoomInZoomOut();
                            }
                        }

                    }
                    else if (this.WindowState == FormWindowState.Normal)
                    {
                        //this.AutoScroll = false;
#if(TOOLBAR)
                        if (this.Width < 513 || this.Height < iFormHeight - (mnuToolBar.Checked ? 0 : 34))
                        {
                            //this.Width = 513;
                            //							this.Width = this.pnlContainer.Width;
                            //							this.Height = 375;
                            if (mnuToolBar.Checked)
                                this.Size = new Size(513, iFormHeight);
                            else
                                this.Size = new Size(513, iFormHeight - 34);
#else
						if(this.Width < 510 || this.Height < iFormHeight-34)
						{
//							this.Width = 513;
//							this.Height = iFormHeight-34;
							this.Size = new Size(513, iFormHeight-34);
#endif
                            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                            {
                                GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                ZoomInZoomOut();
                            }
                        }
                        else
                            if (oldWidth < this.Width || oldHeight < this.Height)
                            {
                                if ((this.Width >= 840 && this.Height >= 600))
                                {
                                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                                    {
                                        GlobalData.ZoomInZoomOut = HConstants.ZOOMIN;
                                        ZoomInZoomOut();
                                    }
                                }
                                /*==============================================================================
                                 *  Added By : Vivek Balagangadharan
                                 *  Description : To solve issue 3738
                                 *  Added On : 20-Apr-2006
                                 * ==============================================================================*/
                                else
                                {
                                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                    {
                                        GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                        ZoomInZoomOut();
                                    }
                                }
                                /* End */
                            }
                            else if ((this.Width < 840 && this.Height >= 600) || (this.Width >= 840 && this.Height < 600))
                            {
                                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                                {
                                    GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                    ZoomInZoomOut();
                                }
                            }
                            else if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN && (this.Width < 800 || this.Height < 600))
                            {
                                GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                                ZoomInZoomOut();
                            }
                    }
#if(TOOLBAR)
                    if (mnuToolBar.Checked)
                        this.pnlContainer.Location = new System.Drawing.Point((this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1) > 0 ? this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1 : 0, (((this.ClientSize.Height - pnlToolBar.Height - 2) / 2 - pnlContainer.Height / 2) > 32) ? (this.ClientSize.Height - pnlToolBar.Height - 2) / 2 - pnlContainer.Height / 2 : pnlToolBar.Height + 2);
                    else
                        this.pnlContainer.Location = new System.Drawing.Point((this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 2) > 0 ? this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 2 : 0, ((this.ClientSize.Height / 2 - pnlContainer.Height / 2) > 0) ? this.ClientSize.Height / 2 - pnlContainer.Height / 2 : 0);
#else
					this.pnlContainer.Location = new System.Drawing.Point(this.ClientSize.Width/2-pnlContainer.Width/2-2, ((this.ClientSize.Height/2 - pnlContainer.Height/2)>0)?this.ClientSize.Height/2 - pnlContainer.Height/2:0);
					//this.pnlContainer.Location = new System.Drawing.Point(this.ClientSize.Width/2-pnlContainer.Width/2, (this.ClientSize.Height)/2 - pnlContainer.Height/2);
#endif
                    oldWidth = this.Width;
                    oldHeight = this.Height;
                    this.Invalidate();
                    this.ResumeLayout(false);
                }
                else
                {
                    if (this.Size != new Size(513, iFormHeight) && this.WindowState != FormWindowState.Minimized)
                    {
                        ////Console.WriteLine(this.Size.Height + ", "+this.Size.Width);
                        this.WindowState = FormWindowState.Normal;
                        this.Size = new Size(513, iFormHeight);
                    }
                }
            }
            catch//(Exception exp)
            {
                //MessageBox.Show(this,exp.StackTrace.ToString());
            }
#endif

        }


        /// <summary>
        /// step button event which calls step menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btStep_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
            else
            {
                EnableRestore();
            }
#endif
            StepHrbt_Click(null, null);
#if(THREADSLEEP)
			Thread.Sleep(100);
#endif
        }


        /// <summary>
        /// copy button even which calls copy menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btCopy_Click(object sender, System.EventArgs e)
        {
            TxtCopy_Click(null, null);
        }


        /// <summary>
        /// cut buttons event which calls the cut menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btCut_Click(object sender, System.EventArgs e)
        {
            TxtCut_Click(null, null);
        }


        /// <summary>
        /// paste button event which calls paste menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btPaste_Click(object sender, System.EventArgs e)
        {
            TxtPaste_Click(null, null);
        }


        /// <summary>
        /// stop button event which calls reset menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btStop_Click(object sender, System.EventArgs e)
        {
#if(CONTEST)
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
                DisableRestore();
            }
            else
            {
                EnableRestore();
            }
#endif
            this.hTooltip.SetToolTip(this.btGoPause, "Go");
            ResetHerbtMenu_Click(null, null);
        }


        /// <summary>
        /// left button event which inserts a 'l' in code editor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btLeft_Click(object sender, System.EventArgs e)
        {
            lock (txtCodeEditor)
            {
                int i = txtCodeEditor.SelectionStart;
                string str = txtCodeEditor.Text.Insert(i, "l");
                txtCodeEditor.Text = str;
                txtCodeEditor.SelectionStart = i + 1;
                txtCodeEditor.SelectionLength = 0;
                str = null;
            }
            if (arrLevels[currentLevelIndex].iTotalCharsTyped == 0)
                arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);

            arrLevels[currentLevelIndex].iTotalCharsTyped++;

            //			if(!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
            //			{
            //				if(arrLevels[currentLevelIndex].numCharsTyped == 0)
            //					arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval);
            //				arrLevels[currentLevelIndex].numCharsTyped++;
            //			}
        }


        /// <summary>
        /// Straight event which inserts a 's' in code editor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btStraight_Click(object sender, System.EventArgs e)
        {
            lock (txtCodeEditor)
            {
                int i = txtCodeEditor.SelectionStart;
                string str = txtCodeEditor.Text.Insert(i, "s");
                txtCodeEditor.Text = str;
                txtCodeEditor.SelectionStart = i + 1;
                txtCodeEditor.SelectionLength = 0;
                str = null;
            }
            if (arrLevels[currentLevelIndex].iTotalCharsTyped == 0)
                arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);

            arrLevels[currentLevelIndex].iTotalCharsTyped++;

            //			if(!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
            //			{
            //				if(arrLevels[currentLevelIndex].numCharsTyped == 0)
            //					arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval);
            //				arrLevels[currentLeve
        }


        /// <summary>
        /// right button event which inserts a 'r' in code editor.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btRight_Click(object sender, System.EventArgs e)
        {
            lock (txtCodeEditor)
            {
                int i = txtCodeEditor.SelectionStart;
                string str = txtCodeEditor.Text.Insert(i, "r");
                txtCodeEditor.Text = str;
                txtCodeEditor.SelectionStart = i + 1;
                txtCodeEditor.SelectionLength = 0;
                str = null;
            }
            if (arrLevels[currentLevelIndex].iTotalCharsTyped == 0)
                arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);

            arrLevels[currentLevelIndex].iTotalCharsTyped++;
            //			if(!arrLevels[currentLevelIndex].IsLevelFinishedPersistant)
            //			{
            //				if(arrLevels[currentLevelIndex].numCharsTyped == 0)
            //					arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddMinutes(TotalTimeInSecRemaining - GameInterval);
            //				arrLevels[currentLevelIndex].numCharsTyped++;
            //			}
        }


        private void txtCodeEditor_KeyPress(object sender, System.Windows.Forms.KeyPressEventArgs e)
        {
            if (e.KeyChar.ToString() == "\r")
            {
                lock (txtCodeEditor)
                {
                    if (txtCodeEditor.Lines.Length > 14)
                    {
                        int indexLastCR = txtCodeEditor.Text.LastIndexOf('\n');
                        int s = txtCodeEditor.SelectionStart;
                        txtCodeEditor.Text = txtCodeEditor.Text.Remove(indexLastCR - 1, 2);
                        txtCodeEditor.SelectionStart = indexLastCR - 1;
                    }
                }
            }
            if (arrLevels[currentLevelIndex].iTotalCharsTyped == 0)
            {
                if (Char.IsLetterOrDigit(e.KeyChar) || Char.IsSymbol(e.KeyChar) || e.KeyChar == '-' || e.KeyChar == '(' || e.KeyChar == ')')
                    arrLevels[currentLevelIndex].FirstCharTypedDT = InstanceStartTime.AddSeconds(TotalTimeInSecRemaining - GameInterval);
            }
            if (Char.IsLetterOrDigit(e.KeyChar) || Char.IsSymbol(e.KeyChar) || e.KeyChar == '-' || e.KeyChar == '(' || e.KeyChar == ')')
                arrLevels[currentLevelIndex].iTotalCharsTyped++;
        }


        /// <summary>
        /// this tells the state of go button whether it is displaying the go image or pause image.
        /// </summary>
        //private int goPauseState = 0;

        /// <summary>
        ///	Go button event, depending on the state of the button it calls run menu event or 
        ///	resume of halt menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btGoPause_Click(object sender, System.EventArgs e)
        {

            if (!arrLevels[currentLevelIndex].blnLevelFinishedMsg)
                if (arrLevels[currentLevelIndex].goPauseState == 0)
                {
                    btGoPause.Image = pbPause.Image;
#if(CONTEST)
                    DisableRestore();
#endif
                    arrLevels[currentLevelIndex].goPauseState = 1;
#if(DESIGNER)
                    txtLevelPoints.Enabled = false;
                    //Added By Rajesh  24/07/07 To reset the level stat.
                    arrLevels[currentLevelIndex].ResetDesignerStats();
                    //End
#endif
                    if (arrLevels[currentLevelIndex].goClicked || arrLevels[currentLevelIndex].stepByStep)
                    {
                        ResumeHrtb_Click(null, null);
                    }
                    else
                    {
                        RunHerbtMenu_Click(null, null);
#if(CONTEST)
                        DisableRestore();
#endif
                    }
                }
                else
                {
#if(DESIGNER)
                    txtLevelPoints.Enabled = true;
#endif
                    btGoPause.Image = pbRun.Image;
#if(CONTEST)
                    if (GlobalData.HerbertMode == HMode.Tutorial)
                    {
                        DisableRestore();
                    }
                    else
                    {
                        EnableRestore();
                    }
#endif
                    if (arrLevels[currentLevelIndex].goClicked || arrLevels[currentLevelIndex].stepByStep)
                        this.hTooltip.SetToolTip(this.btGoPause, "Resume");
                    else
                        this.hTooltip.SetToolTip(this.btGoPause, "Go");
                    arrLevels[currentLevelIndex].goPauseState = 0;
                    HaltHrbt_Click(null, null);
                }
        }

        /// <summary>
        /// menu item for showing and hiding the tool bar.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuToolBar_Click(object sender, System.EventArgs e)
        {
            try
            {
                if (mnuToolBar != null)
                {

                    mnuToolBar.Checked = !(mnuToolBar.Checked);


                    int pnlX = 0, pnlY = 0;

                    if (mnuToolBar.Checked)
                    {
                        pnlToolBar.Visible = true;
                        if (this.WindowState == FormWindowState.Normal)
                            this.Height = this.Height + ((iFormHeight - this.Height) > 0 ? iFormHeight - this.Height : 0);
                        if (this.Width / 2 - pnlContainer.Width / 2 > 0 && this.Width > 513)
                            //Commented by Sujith on 06/23/2005 to fix toolbar issue
                            //					pnlX = this.Width/2 - pnlContainer.Width/2;
                            //Added by Sujith on 06/23/2005 to fix toolbar issue
                            pnlX = (this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1) > 0 ? this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1 : 0;
                        else
                            pnlX = 0;
                        if (this.Height / 2 - pnlContainer.Height / 2 > 0 && this.Height > iFormHeight)
                            //Commented by Sujith on 06/23/2005 to fix toolbar issue
                            //					pnlY = this.Height/2 - pnlContainer.Height/2;
                            //Added by Sujith on 06/23/2005 to fix toolbar issue
                            pnlY = ((((this.ClientSize.Height - pnlToolBar.Height - 2) / 2 - pnlContainer.Height / 2) > 32) ? (this.ClientSize.Height - pnlToolBar.Height - 2) / 2 - pnlContainer.Height / 2 : pnlToolBar.Height + 2);
                        else
                            pnlY = 0;
                        //Commented by Sujith on 06/22/2005 for fixing resizing issue
                        //Start -->
                        //				if(this.WindowState == FormWindowState.Normal)
                        //					pnlContainer.Location = new Point(pnlX,pnlY + 32);
                        //<-- End
                        //Added by Sujith on 06/22/2005 for fixing resizing issue
                        //Start -->
                        if (this.WindowState == FormWindowState.Normal)
                        {
                            if (this.Height == iFormHeight)
                                pnlContainer.Location = new Point(pnlX, pnlY + 32);
                            else
                                pnlContainer.Location = new Point(pnlX, pnlY);
                        }
                        //<-- End
                        else if (this.WindowState == FormWindowState.Maximized)
                            pnlContainer.Location = new Point(pnlX, pnlY);

                        this.MinimumSize = new Size(513, iFormHeight);
                    }
                    else
                    {
                        pnlToolBar.Visible = false;
                        this.MinimumSize = new Size(0, 0);
                        //Commented by Sujith on 06/22/2005 for fixing resizing issue
                        //Start -->
                        //				if(this.WindowState == FormWindowState.Normal)
                        //					this.Height = this.Height-31;
                        //<-- End
                        //Added by Sujith on 06/22/2005 for fixing resizing issue
                        //Start -->
                        if (this.WindowState == FormWindowState.Normal)
                        {
                            if (this.Height == iFormHeight)
                                this.Height = this.Height - 31;
                            else
                                this.Height = this.Height;
                        }
                        //<-- End
                        this.MinimumSize = new Size(513, iFormHeight - 32);
                        if (this.Width / 2 - pnlContainer.Width / 2 > 0 && this.Width > 513)
                            //					pnlX = this.Width/2 - pnlContainer.Width/2;
                            pnlX = (this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1) > 0 ? this.ClientSize.Width / 2 - pnlContainer.Width / 2 - 1 : 0;
                        else
                            pnlX = 0;
                        if (this.Height / 2 - pnlContainer.Height / 2 > 0)
                            //					pnlY = this.Height/2 - pnlContainer.Height/2;
                            pnlY = (this.ClientSize.Height / 2 - pnlContainer.Height / 2) > 0 ? this.ClientSize.Height / 2 - pnlContainer.Height / 2 : 0;
                        else
                            pnlY = 0;
                        if (pnlY - 32 < 0)
                            pnlY = 32;
                        pnlContainer.Location = new Point(pnlX, pnlY - 32);
                        //				this.pnlContainer.Location = new System.Drawing.Point((this.ClientSize.Width/2-pnlContainer.Width/2-2)>0?this.ClientSize.Width/2-pnlContainer.Width/2-2:0, ((this.ClientSize.Height/2 - pnlContainer.Height/2)>0)?this.ClientSize.Height/2 - pnlContainer.Height/2:0);
                    }
                    this.Invalidate();
                }
            }
            catch { }
        }

        private void mnuSmoothScroll_Click(object sender, EventArgs e)
        {
            mnuSmoothScroll.Checked = !(mnuSmoothScroll.Checked);
            if (mnuSmoothScroll.Checked)
            {
                isSmoothScrollEnabled = true;
                blnSkeepLevel = true;
                blnSkeepSmoothScrollPaint = false;
            }
            else
            {
                isSmoothScrollEnabled = false;
                blnSkeepLevel = false;
                blnSkeepSmoothScrollPaint = false;
            }
        }


        /// <summary>
        /// path button event which calls path menu event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btPath_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            PathMenu_Click(null, null);
#if(THREADSLEEP)
			Thread.Sleep(100);
#endif
        }


        /// <summary>
        /// trace button event.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btTrace_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            TraceMenu_Click(null, null);
#if(THREADSLEEP)
			Thread.Sleep(100);
#endif
        }

        /// <summary>
        /// game main area paint.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void pnlContainer_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            try
            {
                Graphics pnlConG = e.Graphics;
                pnlConG.Clear(Color.White);
                pnlConG.FillRectangle(System.Drawing.Brushes.White, 0, 0, pnlContainer.Width, pnlContainer.Height);
                Pen blackPen = new Pen(System.Drawing.Brushes.Black, 3);
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                {
                    pnlConG.DrawRectangle(blackPen, 3, 3, pnlMain.Width + 7, pnlMain.Height + 7);
                }
                else
                    pnlConG.DrawRectangle(blackPen, 3, 3, pnlMain.Width + 8, pnlMain.Height + 8);
            }
            catch
            {
            }
        }

        /// <summary>
        /// text code editor keyup event. which takes care of resetting herbert.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void txtCodeEditor_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
        {
            if (!(txtCodeEditor.Text.Equals(txtcode)) && txtCodeEditor.Text.Length == txtcode.Length)
                ResetHerbtMenu_Click(null, null);
#if(PATTERN_GENERATER)
            if (!(txtCodeEditor.Text.Equals(txtcode)) && txtCodeEditor.Text.Length != txtcode.Length)
            {
                if (GlobalData.HerbertMode == HMode.Designer && currentLevelIndex>=0)
                    arrLevels[currentLevelIndex].fDisposePathStore();
            }
#endif
            txtcode = txtCodeEditor.Text;
        }

        /// <summary>
        /// sets the image in herbert picture box and refreshes it.
        /// </summary>
        private void setImage()
        {
            try
            {
                if (herbtSpeed == 0)
                    lock (imgForPicBox)
                    {
                        this.herbertPicBox.Image = new Bitmap(imgForPicBox);
                    }
                else
                    this.herbertPicBox.Image = new Bitmap(imgForPicBox);
                //Application.DoEvents();
            }
            catch
            {
                //				herbertPicBox = new MyPicBox();
                //				this.herbertPicBox.Location = new Point(arrLevels[currentLevelIndex].curPosX, arrLevels[currentLevelIndex].curPosY);
                //				this.herbertPicBox.Image = new Bitmap(imgForPicBox);
                //				this.herbertPicBox.Size = new Size(14, 14);
                //				this.herbertPicBox.BackColor = Color.Transparent;
                //				this.herbertPicBox.Image = arrHrbtImage[herbertState];
                //				this.herbertPicBox.Paint += new System.Windows.Forms.PaintEventHandler(this.herbertPicBox_Paint);
                //				this.HerbertBoard.Controls.Add(this.herbertPicBox);
                //MessageBox.Show("setImage 1\n"+exp.Message+"\n"+exp.StackTrace+"\n"+exp.Source+"\n"+exp.InnerException);
            }
            try
            {
                if (this.WindowState != FormWindowState.Minimized)
                    this.herbertPicBox.Invalidate();
            }
            catch
            {
                //MessageBox.Show("setImage 2\n"+exp.Message+"\n"+exp.StackTrace+"\n"+exp.Source+"\n"+exp.InnerException);
            }

        }


        /// <summary>
        /// buffer image.
        /// </summary>
        private Image imgForPicBox = null;

        /// <summary>
        /// method invoker which gets and sets image.
        /// </summary>
        private MethodInvoker mi = null;

        /// <summary>
        /// this bool variable is true if updating of solutions is going on.
        /// <p>and it is false if updating is finished.</p>
        /// </summary>
        bool blnUploadingSolutions = false;


        #region Logging errors

        /*==============================================================================
		*  Function Name : LogErrors
		*  Parameters : none
		*  Return values : none
		*  Description : Function for logging any errors or exceptions in the exe.
		*  Created On : 30-Jan-2006
		*  Created By : Vivek Balagangadharan
		* ==============================================================================*/
        private void LogErrors()
        {
            try
            {
                Thread tLogError = new Thread(new ThreadStart(WSLogErrors));
                tLogError.Name = "WS Error Log (" + DateTime.Now.ToShortTimeString() + ")";
                tLogError.Priority = ThreadPriority.Lowest;
                tLogError.Start();

            }
            catch { }
        }

        private void WSLogErrors()
        {
            sbErrorLog.Append("\nCurrent Culture::" + CultureInfo.CurrentCulture.ToString() + "::TimeStamp:" + DateTime.Now + "::CLR Version:" + System.Environment.Version.ToString() + "::OS Version:" + System.Environment.OSVersion.ToString());
            Object IdContestant = null;
            GlobalData.initlizeWS(); //try initializing and log error
            if ((object)GlobalData.ContestantId != null)
            {
                IdContestant = DisableMyMenu(GlobalData.ContestantId, GlobalData.GUID, 2);
            }
            else
            {
                IdContestant = (object)"0";
            }
            Object error = DisableMyMenu(sbErrorLog.ToString(), GlobalData.GUID, 2);
            Object oper = EnableMyMenu(GlobalData.GUID);
            //clear the string builder object
            sbErrorLog.Remove(0, sbErrorLog.Length);
#if(DLL)

#else
            try
            {
                GlobalData.HS.DisplayInfo(IdContestant, oper, error);
            }
            catch { }
#endif
        }
        #endregion



#if(DESIGNER)	
		bool blnNotValidDesignerPoints = false;
		string lvlPointTxt = "";
		

		int lvlpoints = 0;
#endif
        #endregion

        #region Clean up
        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }
        #endregion

        #region Smooth scrolling

        private bool blnSmoothScroll = false;

        private int iImageStartX = 0, iImageStartY = 0, iPrvIndex, iNextIndex;

        private Point prvPoint, nxtPoint;

        private Bitmap prvImg, nextImg, imgMainPanel;

        private void fScrollBoard()
        {
            int controlerror = 8;
            herbertPicBox.Visible = false;
            blnSmoothScroll = true;
            prvPoint = InitialOrResetHrbt;
            nxtPoint = InitialOrResetHrbt;

#if(DESIGNER)
            if (iPrvIndex > 0)
                prvPoint = GetHerbertPos(iPrvIndex);
            else if (arrLevels[iPrvIndex].IsLevelUpdate && iPrvIndex == 0)
                prvPoint = GetHerbertPos(iPrvIndex);
            else
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                    prvPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                else
                    prvPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
            }
            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                prvPoint = new Point(prvPoint.X - 2, prvPoint.Y - 2);
            else
                prvPoint = new Point((prvPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (prvPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1 + 2));

            if (iNextIndex > 0)
                nxtPoint = GetHerbertPos(iNextIndex);
            else if (arrLevels[iNextIndex].IsLevelUpdate && iNextIndex == 0)
                nxtPoint = GetHerbertPos(iNextIndex);
            else
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                    nxtPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                else
                    nxtPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
            }

            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                nxtPoint = new Point(nxtPoint.X - 2, nxtPoint.Y - 2);
            else
                nxtPoint = new Point((nxtPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (nxtPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
#endif
#if(CONTEST)
            if (iPrvIndex != 0)
                //prvPoint = arrLevels[iPrvIndex].getRoboXY(Level.GetLevelId(iPrvIndex));
                prvPoint = new Point(arrLevels[iPrvIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[iPrvIndex].curPosY * GlobalData.ZoomInZoomOut);
            else
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                    prvPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                else
                    prvPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
            }

            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                prvPoint = new Point(prvPoint.X - 2, prvPoint.Y - 2);
            else
            {
                if (arrLevels[iPrvIndex].CurDir == 1 || arrLevels[iPrvIndex].CurDir == 3 || arrLevels[iPrvIndex].CurDir == 2)
                {
                    prvPoint = new Point((prvPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (prvPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1));
                }
                else
                    prvPoint = new Point((prvPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (prvPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
            }

            if (iNextIndex != 0)
                //nxtPoint = arrLevels[iPrvIndex].getRoboXY(Level.GetLevelId(iNextIndex));
                nxtPoint = new Point(arrLevels[iNextIndex].curPosX * GlobalData.ZoomInZoomOut, arrLevels[iNextIndex].curPosY * GlobalData.ZoomInZoomOut);
            else
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                    nxtPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1), BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1));
                else
                    nxtPoint = new Point(BoardWidth / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + (GlobalData.ZoomInZoomOut - 1) - 1, BoardHeight / 2 + (4 - 8) * GlobalData.ZoomInZoomOut + 2 * (GlobalData.ZoomInZoomOut - 1) - 2);
            }

            if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                nxtPoint = new Point(nxtPoint.X - 2, nxtPoint.Y - 2);
            else
            {
                if (arrLevels[iNextIndex].CurDir == 1 || arrLevels[iNextIndex].CurDir == 3 || arrLevels[iNextIndex].CurDir == 2)
                {
                    nxtPoint = new Point((nxtPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (nxtPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1));
                }
                else
                    nxtPoint = new Point((nxtPoint.X - 2 * GlobalData.ZoomInZoomOut - 1), (nxtPoint.Y - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
            }
#endif



#if(CONTEST)
            arrLevels[iPrvIndex].ResetLevelState(Level.GetLevelId(iPrvIndex));
            arrLevels[iNextIndex].ResetLevelState(Level.GetLevelId(iNextIndex));
#endif
#if(DESIGNER)
            arrLevels[iPrvIndex].resetLevelDesigner(Level.GetLevelId(iPrvIndex));
            arrLevels[iNextIndex].resetLevelDesigner(Level.GetLevelId(iNextIndex));
#endif

            prvImg = new Bitmap(arrLevels[iPrvIndex].LevelImg, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);
            nextImg = new Bitmap(arrLevels[iNextIndex].LevelImg, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);

            Graphics pgs = Graphics.FromImage(prvImg);

            getImages();
#if(CONTEST)
            RotateImages(arrLevels[iPrvIndex].CurDir);
#endif

            /*==============================================================================
			*  Added By: Vivek Balagangadharan
			*  Description: To fix the issueId
			*  Added On: 19-Apr-2006
			*  Special Comments: This is assuming that initial direction of Herbert is always up. 
			* ==============================================================================*/
#if(DESIGNER)
            RotateImages(0);
#endif



            //pgs.DrawImage(new Bitmap(arrHrbtImage[0]), hp.X,hp.Y, arrHrbtImage[0].Width,arrHrbtImage[0].Height);
            pgs.DrawImage(new Bitmap(arrHrbtImage[0]), prvPoint.X, prvPoint.Y, arrHrbtImage[0].Width, arrHrbtImage[0].Height);
            pgs.Dispose();

            Graphics ngs = Graphics.FromImage(nextImg);
            getImages();
            RotateImages(arrLevels[iNextIndex].CurDir);

            //for fixing issue 3188
            //lock(this.herbertPicBox)
            {
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                    if (arrLevels[currentLevelIndex].CurDir == 1 || arrLevels[currentLevelIndex].CurDir == 3 || arrLevels[currentLevelIndex].CurDir == 2)
                    {
                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1));
                    }
                    else
                        this.herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2 * GlobalData.ZoomInZoomOut - 1 + 2));
                else
                    herbertPicBox.Location = new System.Drawing.Point(((arrLevels[currentLevelIndex].curPosX * GlobalData.ZoomInZoomOut) - 2), ((arrLevels[currentLevelIndex].curPosY * GlobalData.ZoomInZoomOut) - 2));
            }
            herbertPicBox.Invalidate();
            //ngs.DrawImage(new Bitmap(arrHrbtImage[0]), hp.X, hp.Y, arrHrbtImage[0].Width,arrHrbtImage[0].Height);
            ngs.DrawImage(new Bitmap(arrHrbtImage[0]), nxtPoint.X, nxtPoint.Y, arrHrbtImage[0].Width, arrHrbtImage[0].Height);
            ngs.Dispose();

            Pen bp = new Pen(Brushes.Black, 1);

            imgMainPanel = new Bitmap(pnlMain.Width, 2 * pnlMain.Height);
            Graphics gsmp = Graphics.FromImage(imgMainPanel);
            gsmp.Clear(Color.White);
            lblLevelSolved.Visible = false;
            lblLevelNo.Visible = false;
            lblLevelTxt.Visible = false;
            lblMaxChars.Visible = false;
            lblBytesUsed.Visible = false;
            lblTxtBytes.Visible = false;
            lblScorePerDot.Visible = false;
            lblScoreCurrent.Visible = false;
            lblPointTxt.Visible = false;
#if(DESIGNER)
            txtLevelPoints.ReadOnly = true;
#endif

            if (iPrvIndex < iNextIndex)
            {
#if(STROPT)
                StringBuilder strDisplay = new StringBuilder("");

#endif
#if(STR)
				string str = "";
#endif
                if (arrLevels[iPrvIndex].IsLevelFinishedPersistant)
#if(STR)
					str = "(Solved!)";					
#endif
#if(STROPT)
                    strDisplay.Append("(Solved!)");
#endif
                else
#if(STR)
					str = "(Unsolved)";
#endif
#if(STROPT)
                    strDisplay.Append("(Unsolved)");
#endif

#if(STR)				
				gsmp.DrawString(str,lblLevelSolved.Font,System.Drawing.Brushes.Black,lblLevelSolved.Left,lblLevelSolved.Top);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblLevelSolved.Font, System.Drawing.Brushes.Black, lblLevelSolved.Left, lblLevelSolved.Top);
#endif

                gsmp.DrawString(iPrvIndex.ToString(), lblLevelNo.Font, System.Drawing.Brushes.Black, lblLevelNo.Left, lblLevelNo.Top);
                gsmp.DrawString("Level", lblLevelTxt.Font, System.Drawing.Brushes.Black, lblLevelTxt.Left, lblLevelTxt.Top);

#if(STR)
				str = "(max " + arrLevels[iPrvIndex].getMaxChar(Level.GetLevelId(iPrvIndex)).ToString() +")";
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(Max ");
                strDisplay.Append(arrLevels[iPrvIndex].getMaxChar(Level.GetLevelId(iPrvIndex)).ToString());
                strDisplay.Append(")");
#endif
#if(STR)
				gsmp.DrawString(str, lblMaxChars.Font, System.Drawing.Brushes.Black,lblMaxChars.Left,lblMaxChars.Top);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblMaxChars.Font, System.Drawing.Brushes.Black, lblMaxChars.Left, lblMaxChars.Top);
#endif
#if(CONTEST)
                txtCodeEditor.Text = arrLevels[iPrvIndex].iCurrentProgram;
#endif
#if(DESIGNER)
                txtCodeEditor.Text = Level.getLevelProgram(iPrvIndex).Replace("\n", "\r\n");
#endif
                gsmp.DrawString(CountChars(txtCodeEditor.Text).ToString(), lblBytesUsed.Font, System.Drawing.Brushes.Black, lblBytesUsed.Left, lblBytesUsed.Top);
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                    gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top);
                else
                    gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top);


#if(STR)
				str = "(" + arrLevels[iPrvIndex].scoreCurrently.ToString() + " now)";
				gsmp.DrawString(str, lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(");
                strDisplay.Append(arrLevels[iPrvIndex].scoreCurrently.ToString());
                strDisplay.Append(" now)");
                gsmp.DrawString(strDisplay.ToString(), lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top);

#endif

                if (iPrvIndex > 0)
#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + Level.getLevelPoints(iPrvIndex).ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(Level.getLevelPoints(iPrvIndex).ToString());
                }
#endif
                else
#if(CONTEST)
#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + iPrvIndex.ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(iPrvIndex.ToString());
                }
#endif

#endif
#if(DESIGNER)
                {
                    txtLevelPoints.Text = Level.getLevelPoints(iPrvIndex).ToString();
#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
#if(STROPT)
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(lvlpoints.ToString());
#endif
                }
#endif
#if(STR)
				gsmp.DrawString(str, lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top);
#endif
                gsmp.DrawString("Points:", lblPointTxt.Font, System.Drawing.Brushes.Black, lblPointTxt.Left, lblPointTxt.Top);

                getTextData();
                for (int i = 0; i < txtLines.Length; i++)
                {
                    gsmp.DrawString(txtLines[i], PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 1.0F, i * 13.0F + PanalTxtCodeEdit.Top - 7);
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT && i == 12)
                        break;
                }

                gsmp.FillRectangle(Brushes.White, PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Top - 3, pnlMain.Width - PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Height);
                gsmp.DrawImage(prvImg, HerbertBoard.Left - controlerror + 1, HerbertBoard.Top - controlerror + 1, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);
                prvImg.Dispose();
                gsmp.DrawRectangle(bp, HerbertBoard.Left - controlerror, HerbertBoard.Top - controlerror, 208 * GlobalData.ZoomInZoomOut - 1, 208 * GlobalData.ZoomInZoomOut - 1);
                gsmp.DrawRectangle(bp, PanalTxtCodeEdit.Left - controlerror, PanalTxtCodeEdit.Top - controlerror, PanalTxtCodeEdit.Width - 1, PanalTxtCodeEdit.Height - 1);
                gsmp.DrawRectangle(bp, lblLineTracing.Left - controlerror, lblLineTracing.Top - controlerror, lblLineTracing.Width - 1, lblLineTracing.Height - 1);


                if (arrLevels[iNextIndex].IsLevelFinishedPersistant)
                {
                    lblLevelSolved.Text = "(Solved!)";

#if(STR)
				str = "(Solved!)";
#endif
#if(STROPT)

                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append("(Solved!)");

#endif
                }
                else
                {
                    lblLevelSolved.Text = "(Unsolved)";

#if(STR)
				str = "(Unsolved)";
#endif
#if(STROPT)

                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append("(Unsolved)");

#endif
                }
                
#if(STR)
				gsmp.DrawString(str,lblLevelSolved.Font,System.Drawing.Brushes.Black,lblLevelSolved.Left,lblLevelSolved.Top+pnlMain.Height);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblLevelSolved.Font, System.Drawing.Brushes.Black, lblLevelSolved.Left, lblLevelSolved.Top + pnlMain.Height);
#endif

                gsmp.DrawString(iNextIndex.ToString(), lblLevelNo.Font, System.Drawing.Brushes.Black, lblLevelNo.Left, lblLevelNo.Top + pnlMain.Height);
                lblLevelNo.Text = iNextIndex.ToString();
                gsmp.DrawString("Level", lblLevelTxt.Font, System.Drawing.Brushes.Black, lblLevelTxt.Left, lblLevelTxt.Top + pnlMain.Height);

#if(STR)
				str = "(max " + arrLevels[iNextIndex].getMaxChar(Level.GetLevelId(iNextIndex)).ToString() +")";
				gsmp.DrawString(str, lblMaxChars.Font, System.Drawing.Brushes.Black,lblMaxChars.Left,lblMaxChars.Top+pnlMain.Height);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(Max ");
                strDisplay.Append(arrLevels[iNextIndex].getMaxChar(Level.GetLevelId(iNextIndex)).ToString());
                strDisplay.Append(")");
                gsmp.DrawString(strDisplay.ToString(), lblMaxChars.Font, System.Drawing.Brushes.Black, lblMaxChars.Left, lblMaxChars.Top + pnlMain.Height);

#endif

#if(CONTEST)
                txtCodeEditor.Text = arrLevels[iNextIndex].iCurrentProgram;
#endif
#if(DESIGNER)
                txtCodeEditor.Text = Level.getLevelProgram(iNextIndex).Replace("\n", "\r\n");
#endif
                gsmp.DrawString(CountChars(txtCodeEditor.Text).ToString(), lblBytesUsed.Font, System.Drawing.Brushes.Black, lblBytesUsed.Left, lblBytesUsed.Top + pnlMain.Height);
                lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
                if (GlobalData.ZoomInZoomOut == HConstants.ZOOMIN)
                    gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top + pnlMain.Height);
                else
                    gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top + pnlMain.Height);
                //gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black,lblTxtBytes.Left+1,lblTxtBytes.Top+pnlMain.Height);


#if(STR)
				str = "(" + arrLevels[iNextIndex].scoreCurrently.ToString() + " now)";
				gsmp.DrawString(str, lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top+pnlMain.Height);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(");
                strDisplay.Append(arrLevels[iNextIndex].scoreCurrently.ToString());
                strDisplay.Append(" now)");
                gsmp.DrawString(strDisplay.ToString(), lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top + pnlMain.Height);

#endif

                if (iNextIndex > 0)

#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + Level.getLevelPoints(iNextIndex).ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(Level.getLevelPoints(iNextIndex).ToString());
                }
#endif
                else
#if(CONTEST)

#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + iNextIndex.ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(iNextIndex.ToString());
                }
#endif
#endif
#if(DESIGNER)
                {
                    txtLevelPoints.Text = Level.getLevelPoints(iNextIndex).ToString();
#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
#if(STROPT)
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(lvlpoints.ToString());
#endif
                }
#endif
#if(STR)
				gsmp.DrawString(str, lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top+pnlMain.Height);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top + pnlMain.Height);
#endif
                gsmp.DrawString("Points:", lblPointTxt.Font, System.Drawing.Brushes.Black, lblPointTxt.Left, lblPointTxt.Top + pnlMain.Height);

                getTextData();
                for (int i = 0; i < txtLines.Length; i++)
                {
                    gsmp.DrawString(txtLines[i], PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 1.0F, i * 13.0F + PanalTxtCodeEdit.Top + pnlMain.Height - 7);
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT && i == 12)
                        break;
                }

                gsmp.FillRectangle(Brushes.White, PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Top - 3 + pnlMain.Height, pnlMain.Width - PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Height + pnlMain.Height);
                gsmp.DrawImage(nextImg, HerbertBoard.Left - controlerror + 1, HerbertBoard.Top - controlerror + 1 + pnlMain.Height, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);
                nextImg.Dispose();
                gsmp.DrawRectangle(bp, HerbertBoard.Left - controlerror, HerbertBoard.Top - controlerror + pnlMain.Height, 208 * GlobalData.ZoomInZoomOut - 1, 208 * GlobalData.ZoomInZoomOut - 1);
                gsmp.DrawRectangle(bp, PanalTxtCodeEdit.Left - controlerror, PanalTxtCodeEdit.Top - controlerror + pnlMain.Height, PanalTxtCodeEdit.Width - 1, PanalTxtCodeEdit.Height - 1);
                gsmp.DrawRectangle(bp, lblLineTracing.Left - controlerror, lblLineTracing.Top - controlerror + pnlMain.Height, lblLineTracing.Width - 1, lblLineTracing.Height - 1);



            }
            else
            {
#if(STROPT)
                StringBuilder strDisplay = new StringBuilder("");

#endif
#if(STR)
				string str = "";
#endif
                
                if (arrLevels[iNextIndex].IsLevelFinishedPersistant)
                {
                    lblLevelSolved.Text = "(Solved!)";

#if(STR)
				str = "(Solved!)";
#endif
#if(STROPT)
                    strDisplay.Append("(Solved!)");
#endif
                }
                else
                {
                    lblLevelSolved.Text = "(Unsolved)";

#if(STR)
				str = "(Unsolved)";
#endif
#if(STROPT)
                    strDisplay.Append("(Unsolved)");
#endif
                }
               
#if(STR)
				gsmp.DrawString(str,lblLevelSolved.Font,System.Drawing.Brushes.Black,lblLevelSolved.Left,lblLevelSolved.Top);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblLevelSolved.Font, System.Drawing.Brushes.Black, lblLevelSolved.Left, lblLevelSolved.Top);
#endif
                gsmp.DrawString(iNextIndex.ToString(), lblLevelNo.Font, System.Drawing.Brushes.Black, lblLevelNo.Left, lblLevelNo.Top);
                lblLevelNo.Text = iNextIndex.ToString();
                gsmp.DrawString("Level", lblLevelTxt.Font, System.Drawing.Brushes.Black, lblLevelTxt.Left, lblLevelTxt.Top);
#if(STR)
				str = "(max " + arrLevels[iNextIndex].getMaxChar(Level.GetLevelId(iNextIndex)).ToString() +")";
				gsmp.DrawString(str, lblMaxChars.Font, System.Drawing.Brushes.Black,lblMaxChars.Left,lblMaxChars.Top);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(Max ");
                strDisplay.Append(arrLevels[iNextIndex].getMaxChar(Level.GetLevelId(iNextIndex)).ToString());
                strDisplay.Append(")");
                gsmp.DrawString(strDisplay.ToString(), lblMaxChars.Font, System.Drawing.Brushes.Black, lblMaxChars.Left, lblMaxChars.Top);
#endif


#if(CONTEST)
                txtCodeEditor.Text = arrLevels[iNextIndex].iCurrentProgram;
#endif
#if(DESIGNER)
                txtCodeEditor.Text = Level.getLevelProgram(iNextIndex).Replace("\n", "\r\n");
#endif
                gsmp.DrawString(CountChars(txtCodeEditor.Text).ToString(), lblBytesUsed.Font, System.Drawing.Brushes.Black, lblBytesUsed.Left, lblBytesUsed.Top);
                lblBytesUsed.Text = CountChars(txtCodeEditor.Text).ToString();
                //gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black,lblTxtBytes.Left+1,lblTxtBytes.Top);
                gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top);


#if(STR)
				str = "(" + arrLevels[iNextIndex].scoreCurrently.ToString() + " now)";
				gsmp.DrawString(str, lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(");
                strDisplay.Append(arrLevels[iNextIndex].scoreCurrently.ToString());
                strDisplay.Append(" now)");
                gsmp.DrawString(strDisplay.ToString(), lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top);
#endif


                if (iNextIndex > 0)
#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + Level.getLevelPoints(iNextIndex).ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(Level.getLevelPoints(iNextIndex).ToString());
                }
#endif
                else
#if(CONTEST)
#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + iNextIndex.ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(iNextIndex.ToString());
                }
#endif
#endif
#if(DESIGNER)
                {
                    txtLevelPoints.Text = Level.getLevelPoints(iNextIndex).ToString();
#if(STR)
					str = arrLevels[iNextIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
#if(STROPT)
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iNextIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(lvlpoints.ToString());
#endif
                }
#endif
#if(STR)
				gsmp.DrawString(str, lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top);
#endif
                gsmp.DrawString("Points:", lblPointTxt.Font, System.Drawing.Brushes.Black, lblPointTxt.Left, lblPointTxt.Top);

                getTextData();
                for (int i = 0; i < txtLines.Length; i++)
                {
                    gsmp.DrawString(txtLines[i], PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 1.0F, i * 13.0F + PanalTxtCodeEdit.Top - 7);
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT && i == 12)
                        break;
                }

                gsmp.FillRectangle(Brushes.White, PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Top - 3, pnlMain.Width - PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Height);
                gsmp.DrawImage(nextImg, HerbertBoard.Left - controlerror + 1, HerbertBoard.Top - controlerror + 1, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);
                nextImg.Dispose();
                gsmp.DrawRectangle(bp, HerbertBoard.Left - controlerror, HerbertBoard.Top - controlerror, 208 * GlobalData.ZoomInZoomOut - 1, 208 * GlobalData.ZoomInZoomOut - 1);
                gsmp.DrawRectangle(bp, PanalTxtCodeEdit.Left - controlerror, PanalTxtCodeEdit.Top - controlerror, PanalTxtCodeEdit.Width - 1, PanalTxtCodeEdit.Height - 1);
                gsmp.DrawRectangle(bp, lblLineTracing.Left - controlerror, lblLineTracing.Top - controlerror, lblLineTracing.Width - 1, lblLineTracing.Height - 1);


                if (arrLevels[iPrvIndex].IsLevelFinishedPersistant)
#if(STR)
					str = "(Solved!)";
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append("(Solved!)");
                }
#endif

                else
#if(STR)
					str = "(Unsolved)";
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append("(Unsolved)");
                }
#endif
#if(STR)
				gsmp.DrawString(str,lblLevelSolved.Font,System.Drawing.Brushes.Black,lblLevelSolved.Left,lblLevelSolved.Top+pnlMain.Height);
#endif
#if(STROPT)
                gsmp.DrawString(strDisplay.ToString(), lblLevelSolved.Font, System.Drawing.Brushes.Black, lblLevelSolved.Left, lblLevelSolved.Top + pnlMain.Height);
#endif
                gsmp.DrawString(iPrvIndex.ToString(), lblLevelNo.Font, System.Drawing.Brushes.Black, lblLevelNo.Left, lblLevelNo.Top + pnlMain.Height);
                gsmp.DrawString("Level", lblLevelTxt.Font, System.Drawing.Brushes.Black, lblLevelTxt.Left, lblLevelTxt.Top + pnlMain.Height);


#if(STR)
				str = "(max " + arrLevels[iPrvIndex].getMaxChar(Level.GetLevelId(iPrvIndex)).ToString() +")";
				gsmp.DrawString(str, lblMaxChars.Font, System.Drawing.Brushes.Black,lblMaxChars.Left,lblMaxChars.Top+pnlMain.Height);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(Max ");
                strDisplay.Append(arrLevels[iPrvIndex].getMaxChar(Level.GetLevelId(iPrvIndex)).ToString());
                strDisplay.Append(")");
                gsmp.DrawString(strDisplay.ToString(), lblMaxChars.Font, System.Drawing.Brushes.Black, lblMaxChars.Left, lblMaxChars.Top + pnlMain.Height);
#endif

#if(CONTEST)
                txtCodeEditor.Text = arrLevels[iPrvIndex].iCurrentProgram;
#endif
#if(DESIGNER)
                txtCodeEditor.Text = Level.getLevelProgram(iPrvIndex).Replace("\n", "\r\n");
#endif
                gsmp.DrawString(CountChars(txtCodeEditor.Text).ToString(), lblBytesUsed.Font, System.Drawing.Brushes.Black, lblBytesUsed.Left, lblBytesUsed.Top + pnlMain.Height);
                //gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black,lblTxtBytes.Left+1,lblTxtBytes.Top+pnlMain.Height);
                gsmp.DrawString("Bytes:", lblTxtBytes.Font, System.Drawing.Brushes.Black, lblTxtBytes.Left, lblTxtBytes.Top + pnlMain.Height);

#if(STR)
				str = "(" + arrLevels[iPrvIndex].scoreCurrently.ToString() + " now)";
				gsmp.DrawString(str, lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top+pnlMain.Height);
#endif
#if(STROPT)
                strDisplay.Remove(0, strDisplay.Length);
                strDisplay.Append("(");
                strDisplay.Append(arrLevels[iPrvIndex].scoreCurrently.ToString());
                strDisplay.Append(" now)");
                gsmp.DrawString(strDisplay.ToString(), lblScorePerDot.Font, System.Drawing.Brushes.Black, lblScorePerDot.Left, lblScorePerDot.Top + pnlMain.Height);
#endif

                if (iPrvIndex > 0)
#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + Level.getLevelPoints(iPrvIndex).ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(Level.getLevelPoints(iPrvIndex).ToString());
                }
#endif
                else
#if(CONTEST)

#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + iPrvIndex.ToString();
#endif
#if(STROPT)
                {
                    strDisplay.Remove(0, strDisplay.Length);
                    strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                    strDisplay.Append("/");
                    strDisplay.Append(iPrvIndex.ToString());
                }
#endif
#endif
#if(DESIGNER)
                {
                    txtLevelPoints.Text = Level.getLevelPoints(iPrvIndex).ToString();
#if(STR)
					str = arrLevels[iPrvIndex].levelScore.ToString()+"/" + lvlpoints.ToString();
#endif
#if(STROPT)
                    {
                        strDisplay.Remove(0, strDisplay.Length);
                        strDisplay.Append(arrLevels[iPrvIndex].levelScore.ToString());
                        strDisplay.Append("/");
                        strDisplay.Append(lvlpoints.ToString());
                    }
#endif

                }
#endif
#if(STR)
				gsmp.DrawString(str, lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top+pnlMain.Height);
#endif
#if(STROPT)

                gsmp.DrawString(strDisplay.ToString(), lblScoreCurrent.Font, System.Drawing.Brushes.Black, lblScoreCurrent.Left, lblScoreCurrent.Top + pnlMain.Height);

#endif

                gsmp.DrawString("Points:", lblPointTxt.Font, System.Drawing.Brushes.Black, lblPointTxt.Left, lblPointTxt.Top + pnlMain.Height);

                getTextData();
                for (int i = 0; i < txtLines.Length; i++)
                {
                    gsmp.DrawString(txtLines[i], PanalTxtCodeEdit.Font, System.Drawing.Brushes.Black, 1.0F, i * 13.0F + PanalTxtCodeEdit.Top + pnlMain.Height - 7);
                    if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT && i == 12)
                        break;
                }

                gsmp.FillRectangle(Brushes.White, PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Top - 3 + pnlMain.Height, pnlMain.Width - PanalTxtCodeEdit.Width, PanalTxtCodeEdit.Height + pnlMain.Height);
                gsmp.DrawImage(prvImg, HerbertBoard.Left - controlerror + 1, HerbertBoard.Top - controlerror + 1 + pnlMain.Height, 208 * GlobalData.ZoomInZoomOut, 208 * GlobalData.ZoomInZoomOut);
                prvImg.Dispose();
                gsmp.DrawRectangle(bp, HerbertBoard.Left - controlerror, HerbertBoard.Top - controlerror + pnlMain.Height, 208 * GlobalData.ZoomInZoomOut - 1, 208 * GlobalData.ZoomInZoomOut - 1);
                gsmp.DrawRectangle(bp, PanalTxtCodeEdit.Left - controlerror, PanalTxtCodeEdit.Top - controlerror + pnlMain.Height, PanalTxtCodeEdit.Width - 1, PanalTxtCodeEdit.Height - 1);
                gsmp.DrawRectangle(bp, lblLineTracing.Left - controlerror, lblLineTracing.Top - controlerror + pnlMain.Height, lblLineTracing.Width - 1, lblLineTracing.Height - 1);


            }

            pnlMain.BringToFront();
            //txtCodeEditor.Enabled = false;
            if (iPrvIndex < iNextIndex)
                for (int i = 0; i <= pnlMain.Height && blnSmoothScroll; i = i + 4 * GlobalData.ZoomInZoomOut)
                {
                    iImageStartX = 0;
                    iImageStartY = -i;
                    pnlMain.Refresh();
                    Thread.Sleep(GlobalData.smoothScrollInterval);
                }
            else
                for (int i = pnlMain.Height; i >= 0 && blnSmoothScroll; i = i - 4 * GlobalData.ZoomInZoomOut)
                {
                    iImageStartX = 0;
                    iImageStartY = -i;
                    pnlMain.Refresh();
                    Thread.Sleep(GlobalData.smoothScrollInterval);
                }
            //txtCodeEditor.Enabled = true;
            blnSmoothScroll = false;
            herbertPicBox.Visible = true;
            
            // added by NikhilK on 07/01/2008 to fix issue id. 3230
            if (lblLevelNo.Text != "0")
                lblLevelSolved.Visible = true;
            else
                lblLevelSolved.Visible = false;

            lblLevelNo.Visible = true;
            lblLevelTxt.Visible = true;
            lblMaxChars.Visible = true;
            lblBytesUsed.Visible = true;
            lblTxtBytes.Visible = true;
            lblScorePerDot.Visible = true;
            lblScoreCurrent.Visible = true;
            lblPointTxt.Visible = true;
#if(DESIGNER)
            txtLevelPoints.ReadOnly = false;
#endif
            gsmp.Clear(Color.White);
            gsmp.Dispose();
            pnlMain.SendToBack();
            pnlMain.Refresh();
            //			Image img = Image.FromFile(@"D:\FTProjects\WildNoodles\Herbert\bin\Debug\deliverable\white buttons\White Buttons_Large.jpg");
            //			Image img2 = Image.FromFile(@"D:\FTProjects\WildNoodles\Herbert\bin\Debug\deliverable\gray buttons\gray Buttons_Large.jpg");
            //			Image img3 = Image.FromFile(@"D:\FTProjects\WildNoodles\Herbert\bin\Debug\deliverable\black buttons\black Buttons_Large.jpg");
            //			Image img1 = Image.FromFile(@"D:\FTProjects\WildNoodles\Herbert\bin\Debug\deliverable\dots button\dots_Large.jpg");
            //			int x = 16, y = 16;
            //			Bitmap saveimg = new Bitmap(x*25 + x, y*25+y);
            //			pgs.Clear(Color.White);
            //			
            //			pgs = Graphics.FromImage(saveimg);
            //			pgs.FillRectangle(System.Drawing.Brushes.White,0,0,x*25+x, y*25+y);
            //			for(int i = 0; i < 25; i++)
            //			{
            //				for(int j = 0; j < 25; j++)
            //				{
            //					pgs.DrawImage(img1, i*x, j*x, x, y);
            //					if(i == j)
            //						pgs.DrawImage(img, i*x, j*x, x, y);
            //					if(i+j == 24)
            //						pgs.DrawImage(img2, i*x, j*x, x, y);
            //					if(j == 12)
            //						pgs.DrawImage(img3, i*x, j*x, x, y);
            //				}
            //			}
            //			saveimg.Save("White Buttons_Large1.jpg", System.Drawing.Imaging.ImageFormat.Png);


            GC.Collect();
        }


#if(CONTEST)
        private void HerbertBoard_MouseDown(object sender, System.Windows.Forms.MouseEventArgs e)
        {
            if (blnSmoothScroll == true)
            {
                blnSmoothScroll = false;
                HerbertBoard.Refresh();
            }
        }
#endif
        private void pnlMain_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
        {
            try
            {
                Graphics gsPnlMain = e.Graphics;

                if (mnuSmoothScroll.Checked)
                {
                    if (iPrvIndex < iNextIndex && !blnSkeepSmoothScrollPaint)
                    {
                        gsPnlMain.DrawImage(imgMainPanel, iImageStartX, iImageStartY, pnlMain.Width, 2 * pnlMain.Height);
                    }
                    else if (iPrvIndex > iNextIndex && !blnSkeepSmoothScrollPaint)
                    {
                        gsPnlMain.DrawImage(imgMainPanel, iImageStartX, iImageStartY, pnlMain.Width, 2 * pnlMain.Height);
                    }
                }
            }
            catch
            {
            }
        }



        bool blnPreviousTypeIsThumbTrack = false;

        /// <summary>
        /// invoked when level is scrolled by scroll bar or next-previous button
        /// </summary>
        private void LevelChangeBar_Scroll(object sender, ScrollEventArgs e)
        {

            if (e.Type == ScrollEventType.SmallIncrement || e.Type == ScrollEventType.SmallDecrement)
            {
                blnSkeepLevel = false;
                blnScrollMouseRelease = true;
                blnPreviousTypeIsThumbTrack = false;
            }
            else if (e.Type == ScrollEventType.ThumbTrack)
            {
                blnScrollMouseRelease = false;
                blnPreviousTypeIsThumbTrack = true;
            }
            else if (e.Type == ScrollEventType.EndScroll && blnPreviousTypeIsThumbTrack)
            {
                blnSkeepLevel = true;
                blnScrollMouseRelease = true;
                LevelChange_ValueChanged(null, null);
            }
            else if (e.Type == ScrollEventType.LargeDecrement || e.Type == ScrollEventType.LargeIncrement)
            {
                blnSkeepLevel = false;
                blnScrollMouseRelease = true;
                blnPreviousTypeIsThumbTrack = false;
            }
            else
            {
                blnSkeepLevel = false;
                blnScrollMouseRelease = true;
                if (e.Type != ScrollEventType.ThumbPosition)
                    blnPreviousTypeIsThumbTrack = false;
            }
        }
        #endregion
        /// <summary>
        /// Click event for switching the current contest.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void menuSwitchContest_Click(object sender, EventArgs e)
        {
            // 'DialogResult' added by Nikhil Kardale on 4/7/2007 (to fix issue no. 7805)
            DialogResult SwitchYesNo = new DialogResult();
            SwitchYesNo = MessageBox.Show(this, "Do you want to close the current contest and switch to a different contest?", "Herbert - Error", MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);
            if (SwitchYesNo == DialogResult.Yes)
            {
                GlobalData.IsShowContestList = true;
                this.Close();
                this.lblTotalScore.Text = "0/0";
                GlobalData.herbertTitle = "Herbert - Tutorial";
                if (GlobalData.IsShowContestList)
                {
                    GlobalData.GUID = "";
                    GlobalData.ZoomInZoomOut = HConstants.ZOOMOUT;
                    GlobalData.IsLoadFromFile = false;
                }
                GlobalData.isSwitchContestPerformed = true;
            }
            else
            {
                GlobalData.isSwitchContestPerformed = false;
            }
#if(DESIGNER)
            if (GlobalData.HerbertMode == HMode.Designer)
            {
                GlobalData.IsreloadApplication = true;
            }
#endif

        }
        #region Restore Best Solution Button
        //by Nikhil Kardale on 23/5/2007
        private void btRestore_Click(object sender, EventArgs e)
        {
            if (arrLevels[currentLevelIndex].goPauseState == 1)
            {
#if(CONTEST)
                btRestore.Enabled = false;
                mnuSeperator2Edit.Enabled = false;
                mnuRestoreBest.Enabled = false;
#endif
                return;
            }
            else
            {
                string iBestSoln = arrLevels[currentLevelIndex].iBestProgram;
                if (iBestSoln == "")
                {
                    DispMessage("There is no best solution available");
                }
                else
                {
                    DialogResult RestoreYesNo = new DialogResult();
                    RestoreYesNo = MessageBox.Show(this, "Do you want to revert to your best solution?\nAll changes you have made since then will be lost.", "Restore Best Solution", MessageBoxButtons.YesNo, MessageBoxIcon.Warning, MessageBoxDefaultButton.Button1);
                    if (RestoreYesNo == DialogResult.Yes)
                    {
                        txtCodeEditor.Text = iBestSoln;
                        ResetHerbtMenu_Click(null, null);
                        DispMessage("The best solution has been restored");
                    }
                }
            }
        }
        //by Nikhil Kardale
        private void EnableRestore()
        {
            if (GlobalData.HerbertMode == HMode.Tutorial)
            {
#if(CONTEST)
                btRestore.Enabled = false;
                mnuSeperator2Edit.Enabled = false;
                mnuRestoreBest.Enabled = false;
#endif
                return;
            }
            else
            {
#if(CONTEST)
                if (isSiteDefaultUserId != 1 && GlobalData.HerbertMode == HMode.Contest)
                {
                    btRestore.Enabled = true;
                    mnuSeperator2Edit.Enabled = true;
                    mnuRestoreBest.Enabled = true;
                }
#endif
                return;
            }
        }

        private void DisableRestore()
        {
#if(CONTEST)
            btRestore.Enabled = false;
            mnuSeperator2Edit.Enabled = false;
            mnuRestoreBest.Enabled = false;
#endif
            return;
        }
        #endregion
        #region Page-up and Page-down for levels
        ///<summary>
        /// Methods to Handle the Page-Up and Page-Down Events
        ///</summary>
        // added by Nikhil Kardale on 1/6/2007
        private void LevelsPagingUp(int iLevelNumber)
        {
            int iLevelNum = iLevelNumber;
            if (arrLevels != null)
            {
                if ((currentLevelIndex) >= 5)
                {
                    iLevelNum = currentLevelIndex - 5;
                }
                else
                {
                    iLevelNum = 0;
                }
                if (iLevelNum != currentLevelIndex)
                    HerbertMain_ScrollToLevel(iLevelNum);
            }
        }
        private void LevelsPagingDown(int iLevelNumber)
        {
            int iLevelNum = iLevelNumber;
            if (arrLevels != null)
            {
                if (arrLevels.Length - (currentLevelIndex + 1) >= 5)
                {
                    iLevelNum = currentLevelIndex + 5;
                }
                else
                {
                    iLevelNum = arrLevels.Length - 1;
                }
                if (iLevelNum != currentLevelIndex)
                {
                    HerbertMain_ScrollToLevel(iLevelNum);
                }
            }
        }
        #endregion
#if(DESIGNER || PATTERN_GENERATER)
        private void btShowPattern_Click(object sender, EventArgs e)
        {
            string strtracesign = string.Empty;            
            arrLevels[currentLevelIndex].IsPatternEnabled = !(arrLevels[currentLevelIndex].IsPatternEnabled);
            if (arrLevels[currentLevelIndex].IsPatternEnabled)
            {
                this.hTooltip.SetToolTip(this.btShowPattern, "Remove Pattern");
                btShowPattern.FlatStyle = FlatStyle.Flat;
                mnuShowPattern.Checked = true;
                mnuShowPattern.Text = "Remove Pattern";
            }
            else
            {
                this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                btShowPattern.FlatStyle = FlatStyle.Standard;
                mnuShowPattern.Checked = false;
                mnuShowPattern.Text = "Show Pattern";
            }
            if (arrLevels[currentLevelIndex].IsPatternPresent())
            {                
                arrLevels[currentLevelIndex].drawLevelAfterErase();
                HerbertBoard.Refresh();
            }
            else
            {
                DispMessage("No Pattern available for this level");
                this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                btShowPattern.FlatStyle = FlatStyle.Standard;
                arrLevels[currentLevelIndex].IsPatternEnabled = false;
                // addded by Nikhil Kardale on 20/03/2008 to resolve issue id. 10904
                mnuShowPattern.Checked = false;
                mnuShowPattern.Text = "Show Pattern";
            }
        }

        /// <summary>
        /// Click event for Show Pattern menu item.
        /// </summary>
        /// <param name="Sender"></param>
        /// <param name="e"></param>
        private void mnuShowPattern_Click(object Sender, EventArgs e)
        {
            // method addded by Nikhil Kardale on 20/03/2008 to resolve issue id. 10904

            arrLevels[currentLevelIndex].IsPatternEnabled = !(arrLevels[currentLevelIndex].IsPatternEnabled);
            if (arrLevels[currentLevelIndex].IsPatternEnabled)
            {
                this.hTooltip.SetToolTip(this.btShowPattern, "Remove Pattern");
                btShowPattern.FlatStyle = FlatStyle.Flat;
                mnuShowPattern.Checked = true;
                mnuShowPattern.Text = "Remove Pattern";
            }
            else
            {
                this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                btShowPattern.FlatStyle = FlatStyle.Standard;
                mnuShowPattern.Checked = false;
                mnuShowPattern.Text = "Show Pattern";
            }
            if (arrLevels[currentLevelIndex].IsPatternPresent())
            {
                //btShowPattern.Enabled = true;
                arrLevels[currentLevelIndex].drawLevelAfterErase();
                HerbertBoard.Refresh();
            }
            else
            {
                DispMessage("No Pattern available for this level");
                this.hTooltip.SetToolTip(this.btShowPattern, "Show Pattern");
                btShowPattern.FlatStyle = FlatStyle.Standard;
                arrLevels[currentLevelIndex].IsPatternEnabled = false;
                mnuShowPattern.Checked = false;
                mnuShowPattern.Text = "Show Pattern";
            }
        }
#endif
#if(CONTEST)
        #region SessionManagement
        internal static string GetSessionFilePath(string strKey)
        {
            string strPath = EnableMyMenu(strKey).ToString();
            strPath = strPath.Replace("\\", "k");
            strPath = strPath.Replace("/", "l");
            strPath = strPath.Replace(":", "m");
            strPath = strPath.Replace("*", "n");
            strPath = strPath.Replace("?", "o");
            strPath = strPath.Replace("<", "p");
            strPath = strPath.Replace(">", "q");
            strPath = strPath.Replace("|", "r");
            return strPath;
        }

        internal static string GetDirecteryPath()
        {
            string strDirectryPath = Path.GetPathRoot(Application.StartupPath) + "OfflineSession";
            if (!Directory.Exists(strDirectryPath))
            {
                try
                {
                    Directory.CreateDirectory(strDirectryPath);
                }
                catch
                {
                    strDirectryPath = Application.StartupPath + "OfflineSession";
                }
            }
            return strDirectryPath;
        }
        internal static string GetDirecteryPathForLogin()
        {
            string strDirectryPath = Path.GetPathRoot(Application.StartupPath) + "OfflineSession";
            if (!Directory.Exists(strDirectryPath))
            {
                strDirectryPath = Application.StartupPath + "\\OfflineSession";
            }
            return strDirectryPath;
        }
        private void DeleteUserInfoFromMsterSesssionFile()
        {
            //To delete the user key from master file.
            string retPath = String.Empty;
            string strMasterPath = GetDirecteryPathForLogin() + "\\Herbert.Offline";
            if (File.Exists(strMasterPath))
            {
                try
                {
                    DataSet ds = new DataSet();
                    Designer.XMLEncryptor xmObject = new XMLEncryptor(GlobalData.loginName, GlobalData.password);
                    Designer.XMLEncryptor xmTm = new XMLEncryptor();
                    ds = xmTm.ReadEncryptedXML(strMasterPath);
                    DataRow[] drow = ds.Tables[0].Select("Col1='" + HerbertMain.EnableMyMenu(xmObject.GetKey()).ToString() + "'");
                    if (drow.Length != 0)
                    {
                        retPath = drow[0][1].ToString();
                        ds.Tables[0].Rows.Remove(drow[0]);
                        if (ds.Tables[0].Rows.Count == 0)
                        {
                            //delete master file.                                                        
                            File.Delete(strMasterPath);
                            string strdir = GetDirecteryPathForLogin();
                            if (strdir.Contains("OfflineSession"))
                            {
                                Directory.Delete(strdir);
                            }
                        }
                        else
                        {
                            //write the data into the file.
                            ds.AcceptChanges();
                            xmTm.WriteEncryptedXML(ds, strMasterPath);
                        }
                    }
                }
                catch
                {
                    GlobalData.IsLoadFromFile = false;
                }
            }
            //end
        }
        //added By Rajesh 25/07/07 
        //To Save user session into the file.
        private void CreateSession()
        {

            if (GlobalData.HerbertMode != HMode.Tutorial)
            {
                for (int i = 1; i < arrLevels.Length; i++)
                {
                    arrLevels[i].setGameLevelScoreData();
                }
            }
            ///MemoryStream ms=new MemoryStream();
            //System.Runtime.Serialization.Formatters.Soap.SoapFormatter formatter = new System.Runtime.Serialization.Formatters.Soap.SoapFormatter();

            DataTable dt;
            DataRow dr;
            dr = GlobalData.dsAllHData.Tables["tblGameScore"].Rows[0];
            dr["TotalScore"] = Level.totalScore.ToString();
            dr["OpenLevel"] = currentLevelIndex;
            if (GlobalData.dsAllHData.Tables.IndexOf("tblUserSession") == -1)
            {
                dt = new DataTable("tblUserSession");
                dt.Columns.Add();//For GUID
                dt.Columns.Add();//Timestamp
                dt.Columns.Add();//
                dr = dt.NewRow();
            }
            else
            {
                dt = GlobalData.dsAllHData.Tables["tblUserSession"];
                dr = dt.Rows[0];
            }
            dr[0] = GlobalData.GUID;
            DateTimeFormatInfo dfi = new DateTimeFormatInfo();
            CultureInfo ci = new CultureInfo("en-us");
            dfi.MonthDayPattern = "mm/dd/yy";
            ci.DateTimeFormat = dfi;
            DateTime dtSessionTime = DateTime.UtcNow;
            dr[1] = dtSessionTime.ToString(ci);
            if (GlobalData.dsAllHData.Tables.IndexOf("tblUserSession") == -1)
            {
                dt.Rows.Add(dr);
                GlobalData.dsAllHData.Tables.Add(dt);
            }
            GlobalData.dsAllHData.AcceptChanges();
            //Encryption logic - added by Nikhil Kardale on 30/7/2007
            string strSessionFilePath = EnableMyMenu(GlobalData.loginName).ToString();
            strSessionFilePath = strSessionFilePath.Replace("\\", "k");
            strSessionFilePath = strSessionFilePath.Replace("/", "l");
            strSessionFilePath = strSessionFilePath.Replace(":", "m");
            strSessionFilePath = strSessionFilePath.Replace("*", "n");
            strSessionFilePath = strSessionFilePath.Replace("?", "o");
            strSessionFilePath = strSessionFilePath.Replace("<", "p");
            strSessionFilePath = strSessionFilePath.Replace(">", "q");
            strSessionFilePath = strSessionFilePath.Replace("|", "r");
            //end
            strSessionFilePath = strSessionFilePath.Substring(10, 10) + ".sef";
            //To set the directry structure for the session files.
            string strDirectryPath = GetDirecteryPath();





            //To set the session file
            string strAbosoluteSessionFilePath = strSessionFilePath;
            strSessionFilePath = strDirectryPath + "\\" + strSessionFilePath;
            if (File.Exists(strSessionFilePath))
            {
                File.Delete(strSessionFilePath);
            }
            try
            {
                FileStream fs = File.Create(strSessionFilePath);
                fs.Close();
            }
            catch
            {
                strDirectryPath = Application.StartupPath + "OfflineSession";
                FileStream fs = File.Create(strDirectryPath + "\\" + strAbosoluteSessionFilePath);
                fs.Close();
            }
            Designer.XMLEncryptor xmEncFile = new XMLEncryptor(GlobalData.loginName, GlobalData.password);
            Designer.XMLEncryptor xmTm = new XMLEncryptor();
            xmEncFile.WriteEncryptedXML(GlobalData.dsAllHData, strSessionFilePath);
            File.SetAttributes(strSessionFilePath, FileAttributes.Hidden);
            string strMasterkey = EnableMyMenu(xmEncFile.GetKey()).ToString();
            //Foe master file
            string strMasterPath = strDirectryPath + "\\Herbert.Offline";
            if (File.Exists(strMasterPath))
            {
                try
                {
                    DataSet ds = new DataSet();
                    //ds.ReadXml(strMasterPath, XmlReadMode.ReadSchema);
                    ds = xmTm.ReadEncryptedXML(strMasterPath);
                    DataRow[] drow = ds.Tables[0].Select("Col1='" + strMasterkey + "'");
                    if (drow.Length == 0)
                    {
                        dr = ds.Tables[0].NewRow();
                        dr[0] = strMasterkey;
                        dr[1] = strSessionFilePath;
                        ds.Tables[0].Rows.Add(dr);
                        ds.AcceptChanges();
                    }
                    xmTm.WriteEncryptedXML(ds, strMasterPath);
                }
                catch
                {
                }
            }
            else
            {
                //create master file here
                FileStream fs1 = File.Create(strMasterPath);
                //File.SetAttributes(strMasterPath, FileAttributes.Hidden);
                fs1.Close();
                DataSet ds = new DataSet("HerbertData");
                DataTable dtable = new DataTable("HerbertTable");
                dtable.Columns.Add("Col1");
                dtable.Columns.Add("Col2");
                DataRow drow = dtable.NewRow();
                drow["Col1"] = strMasterkey;
                drow["Col2"] = strSessionFilePath;
                dtable.Rows.Add(drow);
                ds.Tables.Add(dtable);
                xmTm.WriteEncryptedXML(ds, strMasterPath);
            }

            GlobalData.IsSessionSaved = true;
            //end
        }

        #endregion
        #region Previous Unsolved Level and Next Unsolved Level buttons
        // added by Nikhil Kardale on 24/10/2007
        private void btnPrevUnsolved_Click(object sender, EventArgs e)
        {
            bool blnUnsolvedLevelFound = false;
            for (PrevUnsolvedLevel = currentLevelIndex - 1; PrevUnsolvedLevel < arrLevels.Length; PrevUnsolvedLevel--)
            {
                if (!arrLevels[PrevUnsolvedLevel].IsLevelFinishedPersistant)
                {
                    blnUnsolvedLevelFound = true;
                    break;
                }
            }

            HerbertMain_ScrollToLevel(PrevUnsolvedLevel);

        }

        private void btnNextUnsolved_Click(object sender, EventArgs e)
        {
            bool blnUnsolvedLevelFound = false;
            for (NextUnsolvedLevel = currentLevelIndex + 1; NextUnsolvedLevel < arrLevels.Length; NextUnsolvedLevel++)
            {
                if (!arrLevels[NextUnsolvedLevel].IsLevelFinishedPersistant)
                {
                    blnUnsolvedLevelFound = true;
                    break;
                }
            }

            HerbertMain_ScrollToLevel(NextUnsolvedLevel);

        }
        #endregion

        #region Toggle Timer Visibility
        // added by Nikhil Kardale on 29/10/2007
        private void mnuTimer_Click(object sender, EventArgs e)
        {
            try
            {
                if (GlobalData.iTimerEnable == 1)
                {
                    mnuTimer.Checked = !(mnuTimer.Checked);

                    if (mnuTimer.Checked)
                    {
                        lblTimer.Visible = true;
                        lblTimeLeft.Visible = true;
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                            lblMsgBox.Width = 316;
                        else
                            lblMsgBox.Width = 590;
                        GlobalData.isTimerToggleVisible = true;
                    }
                    else
                    {
                        lblTimer.Visible = false;
                        lblTimeLeft.Visible = false;
                        if (GlobalData.ZoomInZoomOut == HConstants.ZOOMOUT)
                            lblMsgBox.Width = 495;
                        else
                            lblMsgBox.Width = 788;
                        GlobalData.isTimerToggleVisible = false;
                    }
                }
            }
            catch { }
        }
        #endregion
#endif
    }



}
